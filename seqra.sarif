{
  "$schema": "https://docs.oasis-open.org/sarif/sarif/v2.1.0/errata01/os/schemas/sarif-schema-2.1.0.json",
  "version": "2.1.0",
  "runs": [
    {
      "originalUriBaseIds": {
        "%SRCROOT%": {
          "uri": "/home/runner/work/_temp/seqra-artifacts/1f09fb0b48a88a2ac7c51fafa03f23cc98e6c994/project/sources/"
        }
      },
      "tool": {
        "driver": {
          "name": "Seqra",
          "organization": "Seqra",
          "rules": [
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Cryptographic algorithms are notoriously difficult to get right. By implementing a custom message digest, you risk introducing security issues into your program. Use one of the many sound message digests already available to you: MessageDigest sha256Digest = MessageDigest.getInstance(\"SHA256\");",
                "text": "Cryptographic algorithms are notoriously difficult to get right. By implementing a custom message digest, you risk introducing security issues into your program. Use one of the many sound message digests already available to you: MessageDigest sha256Digest = MessageDigest.getInstance(\"SHA256\");"
              },
              "id": "java.security.avoid-implementing-custom-digests",
              "name": "java.security.avoid-implementing-custom-digests",
              "properties": {
                "tags": [
                  "CWE-327"
                ]
              },
              "shortDescription": {
                "text": "Custom message digest implementation is too error-prone"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "When a Restful webservice endpoint is configured to use wildcard mediaType {*/*} as a value for the @Consumes annotation, an attacker could abuse the SerializableProvider by sending a HTTP Request with a Content-Type of application/x-java-serialized-object. The body of that request would be processed by the SerializationProvider and could contain a malicious payload, which may lead to arbitrary code execution when calling the $Y.getObject method.",
                "text": "When a Restful webservice endpoint is configured to use wildcard mediaType {*/*} as a value for the @Consumes annotation, an attacker could abuse the SerializableProvider by sending a HTTP Request with a Content-Type of application/x-java-serialized-object. The body of that request would be processed by the SerializationProvider and could contain a malicious payload, which may lead to arbitrary code execution when calling the $Y.getObject method."
              },
              "id": "java.security.insecure-resteasy-deserialization",
              "name": "java.security.insecure-resteasy-deserialization",
              "properties": {
                "tags": [
                  "CWE-502"
                ]
              },
              "shortDescription": {
                "text": "Insecure deserialization of request"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "The application was found setting file permissions to overly permissive values.\nSuch configurations make files readable, writable, or executable by any user on the system,\nwhich can expose sensitive data, allow unauthorized modification of files, or enable arbitrary code execution.\nConsider using the following values if the application user is the only process to access\nthe file:\n\n- `r--` - read only access to the file\n- `w--` - write only access to the file\n- `rw-` - read/write access to the file\n\nExample setting read/write permissions for only the owner of a `Path`:\n```\n// Get a reference to the path\nPath path = Paths.get(\"/tmp/somefile\");\n// Create a PosixFilePermission set from java.nio.file.attribute\nSet<PosixFilePermission> permissions =\njava.nio.file.attribute.PosixFilePermissions.fromString(\"rw-------\");\n// Set the permissions\njava.nio.file.Files.setPosixFilePermissions(path, permissions);\n```",
                "text": "The application was found setting file permissions to overly permissive values.\nSuch configurations make files readable, writable, or executable by any user on the system,\nwhich can expose sensitive data, allow unauthorized modification of files, or enable arbitrary code execution.\nConsider using the following values if the application user is the only process to access\nthe file:\n\n- `r--` - read only access to the file\n- `w--` - write only access to the file\n- `rw-` - read/write access to the file\n\nExample setting read/write permissions for only the owner of a `Path`:\n```\n// Get a reference to the path\nPath path = Paths.get(\"/tmp/somefile\");\n// Create a PosixFilePermission set from java.nio.file.attribute\nSet<PosixFilePermission> permissions =\njava.nio.file.attribute.PosixFilePermissions.fromString(\"rw-------\");\n// Set the permissions\njava.nio.file.Files.setPosixFilePermissions(path, permissions);\n```"
              },
              "id": "java.security.overly-permissive-file-permission-inline",
              "name": "java.security.overly-permissive-file-permission-inline",
              "properties": {
                "tags": [
                  "CWE-732"
                ]
              },
              "shortDescription": {
                "text": "Setting file permissions to overly permissive values"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "GCM IV/nonce is reused, encryption can be totally useless",
                "text": "GCM IV/nonce is reused, encryption can be totally useless"
              },
              "id": "java.security.gcm-nonce-reuse",
              "name": "java.security.gcm-nonce-reuse",
              "properties": {
                "tags": [
                  "CWE-323"
                ]
              },
              "shortDescription": {
                "text": "GCM IV/nonce is reused, encryption can be totally useless"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Use of RC2 was detected. RC2 is vulnerable to related-key attacks, and is therefore considered non-compliant. Instead, use a strong, secure cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").",
                "text": "Use of RC2 was detected. RC2 is vulnerable to related-key attacks, and is therefore considered non-compliant. Instead, use a strong, secure cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\")."
              },
              "id": "java.security.use-of-rc2",
              "name": "java.security.use-of-rc2",
              "properties": {
                "tags": [
                  "CWE-327"
                ]
              },
              "shortDescription": {
                "text": "RC2 is vulnerable to related-key attacks, and is therefore considered non-compliant"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Use of RC4 was detected. RC4 is vulnerable to several attacks, including stream cipher attacks and bit flipping attacks. Instead, use a strong, secure cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").",
                "text": "Use of RC4 was detected. RC4 is vulnerable to several attacks, including stream cipher attacks and bit flipping attacks. Instead, use a strong, secure cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\")."
              },
              "id": "java.security.use-of-rc4",
              "name": "java.security.use-of-rc4",
              "properties": {
                "tags": [
                  "CWE-327"
                ]
              },
              "shortDescription": {
                "text": "RC4 is vulnerable to several attacks, including stream cipher attacks and bit flipping attacks"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Disabling CSRF protection in a Java web application (for example, via `http.csrf().disable()` in Spring Security)\nremoves the server-side check that ensures state‑changing requests (like POST, PUT, DELETE) actually come from\nthe legitimate application pages. When this protection is turned off, any website can cause a victim's browser—while\nthe user is logged in—to silently send authenticated requests to your application, because the browser automatically\nincludes cookies, session IDs, and some auth headers.\n\nThe consequences can include:\n\n- **Unauthorized actions under the victim's account** — changing passwords or email addresses, updating profiles,\n  posting content, or making purchases and transfers without the user's consent.\n- **Compromise of data integrity** — attackers can modify or delete data, approve or reject workflows,\n  or change configuration/settings in admin panels.\n- **Escalation to broader compromise** — CSRF can be chained with other vulnerabilities\n  (e.g., weak auth flows, missing audit/logging) to lead to account takeover or full application compromise.\n- **Business and legal impact** — fraudulent transactions, data tampering, and loss of user trust,\n  potentially triggering regulatory or compliance violations.",
                "text": "Disabling CSRF protection in a Java web application (for example, via `http.csrf().disable()` in Spring Security)\nremoves the server-side check that ensures state‑changing requests (like POST, PUT, DELETE) actually come from\nthe legitimate application pages. When this protection is turned off, any website can cause a victim's browser—while\nthe user is logged in—to silently send authenticated requests to your application, because the browser automatically\nincludes cookies, session IDs, and some auth headers.\n\nThe consequences can include:\n\n- **Unauthorized actions under the victim's account** — changing passwords or email addresses, updating profiles,\n  posting content, or making purchases and transfers without the user's consent.\n- **Compromise of data integrity** — attackers can modify or delete data, approve or reject workflows,\n  or change configuration/settings in admin panels.\n- **Escalation to broader compromise** — CSRF can be chained with other vulnerabilities\n  (e.g., weak auth flows, missing audit/logging) to lead to account takeover or full application compromise.\n- **Business and legal impact** — fraudulent transactions, data tampering, and loss of user trust,\n  potentially triggering regulatory or compliance violations."
              },
              "id": "java.security.csrf-disabled-in-spring-app",
              "name": "java.security.csrf-disabled-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-352"
                ]
              },
              "shortDescription": {
                "text": "CSRF protection is disabled for this configuration"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Detected the decoding of a JWT token without a verify step. JWT tokens must be verified before use, otherwise the token's integrity is unknown. This means a malicious actor could forge a JWT token with any claims. Call '.verify()' before using the token.",
                "text": "Detected the decoding of a JWT token without a verify step. JWT tokens must be verified before use, otherwise the token's integrity is unknown. This means a malicious actor could forge a JWT token with any claims. Call '.verify()' before using the token."
              },
              "id": "java.security.java-jwt-decode-without-verify",
              "name": "java.security.java-jwt-decode-without-verify",
              "properties": {
                "tags": [
                  "CWE-345"
                ]
              },
              "shortDescription": {
                "text": "Decoding of a JWT token without a verify step"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "The application was found to permit the `RuntimePermission` of `createClassLoader`, `ReflectPermission` of `suppressAccessChecks`, or both.\nBy granting the `RuntimePermission` of `createClassLoader`, a compromised application could instantiate their own class loaders and load arbitrary classes.\nBy granting the `ReflectPermission` of `suppressAccessChecks` an application will no longer check Java language access checks on fields and methods of a class. This will effectively grant access to protected and private members.",
                "text": "The application was found to permit the `RuntimePermission` of `createClassLoader`, `ReflectPermission` of `suppressAccessChecks`, or both.\nBy granting the `RuntimePermission` of `createClassLoader`, a compromised application could instantiate their own class loaders and load arbitrary classes.\nBy granting the `ReflectPermission` of `suppressAccessChecks` an application will no longer check Java language access checks on fields and methods of a class. This will effectively grant access to protected and private members."
              },
              "id": "java.security.dangerous-permissions",
              "name": "java.security.dangerous-permissions",
              "properties": {
                "tags": [
                  "CWE-732"
                ]
              },
              "shortDescription": {
                "text": "Weak runtime and/or reflection permissions cause security risks"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Detected SHA1 hash algorithm which is considered insecure. SHA1 is not collision resistant and is therefore not suitable as a cryptographic signature. Instead, use PBKDF2 for password hashing or SHA256 or SHA512 for other hash function applications.",
                "text": "Detected SHA1 hash algorithm which is considered insecure. SHA1 is not collision resistant and is therefore not suitable as a cryptographic signature. Instead, use PBKDF2 for password hashing or SHA256 or SHA512 for other hash function applications."
              },
              "id": "java.security.use-of-sha1",
              "name": "java.security.use-of-sha1",
              "properties": {
                "tags": [
                  "CWE-328"
                ]
              },
              "shortDescription": {
                "text": "SHA1 is not collision resistant and is therefore not suitable as a cryptographic signature"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "A potential hard-coded password was identified in a database connection string.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily rotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running in:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation",
                "text": "A potential hard-coded password was identified in a database connection string.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily rotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running in:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation"
              },
              "id": "java.security.constant-db-password",
              "name": "java.security.constant-db-password",
              "properties": {
                "tags": [
                  "CWE-259"
                ]
              },
              "shortDescription": {
                "text": "Use of hard-coded DB password"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format(\"%02X\", ...)' instead.",
                "text": "'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte. This mistake weakens the hash value computed since it introduces more collisions. Use 'String.format(\"%02X\", ...)' instead."
              },
              "id": "java.security.bad-hexa-conversion",
              "name": "java.security.bad-hexa-conversion",
              "properties": {
                "tags": [
                  "CWE-704"
                ]
              },
              "shortDescription": {
                "text": "Strippping leading zeroes from each byte, this weakens the hash value computed"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Using an arbitrary object ('$PARAMTYPE $PARAM') with Java RMI is an insecure deserialization vulnerability. This object can be manipulated by a malicious actor allowing them to execute code on your system. Instead, use an integer ID to look up your object, or consider alternative serialization schemes such as JSON.",
                "text": "Using an arbitrary object ('$PARAMTYPE $PARAM') with Java RMI is an insecure deserialization vulnerability. This object can be manipulated by a malicious actor allowing them to execute code on your system. Instead, use an integer ID to look up your object, or consider alternative serialization schemes such as JSON."
              },
              "id": "java.security.server-dangerous-object-deserialization",
              "name": "java.security.server-dangerous-object-deserialization",
              "properties": {
                "tags": [
                  "CWE-502"
                ]
              },
              "shortDescription": {
                "text": "Insecure deserelization in Java RMI"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "URL rewriting in Java web applications is a session-tracking technique where the server appends the session ID to URLs (for example, `;jsessionid=ABC123` or `?sessionid=...`) instead of, or in addition to, using cookies. This exposes the session identifier in browser history, logs, bookmarks, analytics systems, and `Referer` headers sent to third-party sites. If an attacker obtains such a URL, they can hijack the user's session. When URL rewriting is used in redirects or links to external domains, the risk of leaking the session ID increases significantly.\n\nVulnerable code sample\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.*;\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\n\npublic class TrackingRedirectServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String productId = request.getParameter(\"id\");\n        if (productId == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing product id\");\n            return;\n        }\n\n        // Build URL to external partner site with tracking info\n        String target = \"https://partner.example.com/track?product=\" +\n                URLEncoder.encode(productId, StandardCharsets.UTF_8.name());\n\n        // VULNERABLE:\n        // encodeRedirectURL may append ;jsessionid=<SESSION_ID> to the URL.\n        // That session ID can then appear in logs, browser history, and\n        // be leaked to the external domain via the Referer header.\n        String encoded = response.encodeRedirectURL(target);\n\n        response.sendRedirect(encoded);\n    }\n}\n```\n\nIn this example, if URL rewriting is enabled, the container may transform `target` into something like:\n\n`https://partner.example.com/track;jsessionid=ABC123?product=42`\n\nThe session ID `ABC123` can then be exposed outside the application's control, making session hijacking much easier.\n\nTo remediate this issue, prefer cookie-based session tracking and disable URL rewriting, especially for external or absolute URLs. Where URL rewriting cannot be fully disabled, restrict it to internal, relative URLs only, and never propagate session IDs to third-party domains.\n\nConfiguration-level mitigation (Servlet 3.0+), in `web.xml`:\n\n```xml\n<session-config>\n    <!-- Use only cookies for session tracking -->\n    <tracking-mode>COOKIE</tracking-mode>\n</session-config>\n```\n\nSafer servlet code example:\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.*;\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\n\npublic class SafeTrackingRedirectServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String productId = request.getParameter(\"id\");\n        if (productId == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing product id\");\n            return;\n        }\n\n        String target = \"https://partner.example.com/track?product=\" +\n                URLEncoder.encode(productId, StandardCharsets.UTF_8.name());\n\n        // SAFE: With tracking-mode=COOKIE, there is no need to use encodeRedirectURL\n        // for external URLs; the session ID will not be appended to the URL.\n        response.sendRedirect(target);\n    }\n}\n```\n\nKey remediation steps:\n- Configure the application server to use only cookies for session tracking (`<tracking-mode>COOKIE</tracking-mode>`).\n- Avoid calling `encodeURL` / `encodeRedirectURL` on absolute or external URLs.\n- If URL rewriting must be used as a fallback for clients without cookies, restrict it to internal, relative paths and always over HTTPS.\n- Additionally, harden session cookies (HttpOnly, Secure, appropriate SameSite, short lifetime, regeneration on login), to reduce the impact if a session ID is exposed.",
                "text": "URL rewriting in Java web applications is a session-tracking technique where the server appends the session ID to URLs (for example, `;jsessionid=ABC123` or `?sessionid=...`) instead of, or in addition to, using cookies. This exposes the session identifier in browser history, logs, bookmarks, analytics systems, and `Referer` headers sent to third-party sites. If an attacker obtains such a URL, they can hijack the user's session. When URL rewriting is used in redirects or links to external domains, the risk of leaking the session ID increases significantly.\n\nVulnerable code sample\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.*;\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\n\npublic class TrackingRedirectServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String productId = request.getParameter(\"id\");\n        if (productId == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing product id\");\n            return;\n        }\n\n        // Build URL to external partner site with tracking info\n        String target = \"https://partner.example.com/track?product=\" +\n                URLEncoder.encode(productId, StandardCharsets.UTF_8.name());\n\n        // VULNERABLE:\n        // encodeRedirectURL may append ;jsessionid=<SESSION_ID> to the URL.\n        // That session ID can then appear in logs, browser history, and\n        // be leaked to the external domain via the Referer header.\n        String encoded = response.encodeRedirectURL(target);\n\n        response.sendRedirect(encoded);\n    }\n}\n```\n\nIn this example, if URL rewriting is enabled, the container may transform `target` into something like:\n\n`https://partner.example.com/track;jsessionid=ABC123?product=42`\n\nThe session ID `ABC123` can then be exposed outside the application's control, making session hijacking much easier.\n\nTo remediate this issue, prefer cookie-based session tracking and disable URL rewriting, especially for external or absolute URLs. Where URL rewriting cannot be fully disabled, restrict it to internal, relative URLs only, and never propagate session IDs to third-party domains.\n\nConfiguration-level mitigation (Servlet 3.0+), in `web.xml`:\n\n```xml\n<session-config>\n    <!-- Use only cookies for session tracking -->\n    <tracking-mode>COOKIE</tracking-mode>\n</session-config>\n```\n\nSafer servlet code example:\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.*;\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\n\npublic class SafeTrackingRedirectServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String productId = request.getParameter(\"id\");\n        if (productId == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing product id\");\n            return;\n        }\n\n        String target = \"https://partner.example.com/track?product=\" +\n                URLEncoder.encode(productId, StandardCharsets.UTF_8.name());\n\n        // SAFE: With tracking-mode=COOKIE, there is no need to use encodeRedirectURL\n        // for external URLs; the session ID will not be appended to the URL.\n        response.sendRedirect(target);\n    }\n}\n```\n\nKey remediation steps:\n- Configure the application server to use only cookies for session tracking (`<tracking-mode>COOKIE</tracking-mode>`).\n- Avoid calling `encodeURL` / `encodeRedirectURL` on absolute or external URLs.\n- If URL rewriting must be used as a fallback for clients without cookies, restrict it to internal, relative paths and always over HTTPS.\n- Additionally, harden session cookies (HttpOnly, Secure, appropriate SameSite, short lifetime, regeneration on login), to reduce the impact if a session ID is exposed."
              },
              "id": "java.security.url-rewriting",
              "name": "java.security.url-rewriting",
              "properties": {
                "tags": [
                  "CWE-200"
                ]
              },
              "shortDescription": {
                "text": "URL rewriting can expose session ID to third parties"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "The application does not provide authentication when communicating a database\nserver. It is strongly recommended that the database server be configured with\nauthentication and restrict what queries users can execute.\n\nPlease see your database server's documentation on how to configure a password.\n\nAdditionally, passwords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily rotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running in:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation",
                "text": "The application does not provide authentication when communicating a database\nserver. It is strongly recommended that the database server be configured with\nauthentication and restrict what queries users can execute.\n\nPlease see your database server's documentation on how to configure a password.\n\nAdditionally, passwords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily rotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running in:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation"
              },
              "id": "java.security.java-empty-db-password",
              "name": "java.security.java-empty-db-password",
              "properties": {
                "tags": [
                  "CWE-306"
                ]
              },
              "shortDescription": {
                "text": "Missing authentication for database"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Use of Blowfish was detected. Blowfish uses a 64-bit block size that makes it vulnerable to birthday attacks, and is therefore considered non-compliant. Instead, use a strong, secure cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").",
                "text": "Use of Blowfish was detected. Blowfish uses a 64-bit block size that makes it vulnerable to birthday attacks, and is therefore considered non-compliant. Instead, use a strong, secure cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\")."
              },
              "id": "java.security.use-of-blowfish",
              "name": "java.security.use-of-blowfish",
              "properties": {
                "tags": [
                  "CWE-327"
                ]
              },
              "shortDescription": {
                "text": "Blowfish uses a 64-bit block size that makes it vulnerable to birthday attacks"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "JMS Object messages depend on Java Serialization for marshalling/unmarshalling of the message payload when ObjectMessage.getObject() is called. Deserialization of untrusted data can lead to security flaws; a remote attacker could via a crafted JMS ObjectMessage to execute arbitrary code with the permissions of the application listening/consuming JMS Messages. In this case, the JMS MessageListener consume an ObjectMessage type received inside the onMessage method, which may lead to arbitrary code execution when calling the $Y.getObject method.",
                "text": "JMS Object messages depend on Java Serialization for marshalling/unmarshalling of the message payload when ObjectMessage.getObject() is called. Deserialization of untrusted data can lead to security flaws; a remote attacker could via a crafted JMS ObjectMessage to execute arbitrary code with the permissions of the application listening/consuming JMS Messages. In this case, the JMS MessageListener consume an ObjectMessage type received inside the onMessage method, which may lead to arbitrary code execution when calling the $Y.getObject method."
              },
              "id": "java.security.insecure-jms-deserialization",
              "name": "java.security.insecure-jms-deserialization",
              "properties": {
                "tags": [
                  "CWE-502"
                ]
              },
              "shortDescription": {
                "text": "Deserialization of untrusted data"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "The application does not provide authentication when communicating an LDAP\nserver. It is strongly recommended that the LDAP server be configured with\nauthentication and restrict what queries users can execute.\n\nExample code that authenticates with a remote LDAP server and encodes any\nuser-supplied input:\n```\n// Create a properties to hold the ldap connection details\nProperties props = new Properties();\n// Use the com.sun.jndi.ldap.LdapCtxFactory factory provider\nprops.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n// The LDAP server URL\nprops.put(Context.PROVIDER_URL, \"ldap://ldap.example.org:3889\");\n// User details for the connection\nprops.put(Context.SECURITY_PRINCIPAL, \"cn=admin,dc=example,dc=org\");\n// LDAP account password\nString ldapAccountPassword = getAccountPasswordFromSecureStoreOrKMS();\n// Pass in the LDAP password\nprops.put(Context.SECURITY_CREDENTIALS, ldapAccountPassword);\n\n// Create the LDAPContext\nInitialDirContext ldapContext = new InitialDirContext(props);\n// Example using SUBTREE_SCOPE SearchControls\nSearchControls searchControls = new SearchControls();\nsearchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n// Get user input for query\nString userQuery = someUserInput;\n// Use searchArguments to hold the user-supplied input\nObject[] searchArguments = new Object[]{userQuery};\n// Hardcode the BaseDN, use the {0} format specifier to use the searchArguments array value,\nand pass in the search controls.\n// searchArguments automatically encode\nNamingEnumeration answer = ldapContext.search(\"dc=example,dc=org\", \"(cn={0})\",\nsearchArguments, searchControls);\n// Process the response answer\nwhile (answer.hasMoreElements()) {\n  ...\n}\n```\n\nFor information on enabling authentication, please see your LDAP server's\ndocumentation.",
                "text": "The application does not provide authentication when communicating an LDAP\nserver. It is strongly recommended that the LDAP server be configured with\nauthentication and restrict what queries users can execute.\n\nExample code that authenticates with a remote LDAP server and encodes any\nuser-supplied input:\n```\n// Create a properties to hold the ldap connection details\nProperties props = new Properties();\n// Use the com.sun.jndi.ldap.LdapCtxFactory factory provider\nprops.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n// The LDAP server URL\nprops.put(Context.PROVIDER_URL, \"ldap://ldap.example.org:3889\");\n// User details for the connection\nprops.put(Context.SECURITY_PRINCIPAL, \"cn=admin,dc=example,dc=org\");\n// LDAP account password\nString ldapAccountPassword = getAccountPasswordFromSecureStoreOrKMS();\n// Pass in the LDAP password\nprops.put(Context.SECURITY_CREDENTIALS, ldapAccountPassword);\n\n// Create the LDAPContext\nInitialDirContext ldapContext = new InitialDirContext(props);\n// Example using SUBTREE_SCOPE SearchControls\nSearchControls searchControls = new SearchControls();\nsearchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n// Get user input for query\nString userQuery = someUserInput;\n// Use searchArguments to hold the user-supplied input\nObject[] searchArguments = new Object[]{userQuery};\n// Hardcode the BaseDN, use the {0} format specifier to use the searchArguments array value,\nand pass in the search controls.\n// searchArguments automatically encode\nNamingEnumeration answer = ldapContext.search(\"dc=example,dc=org\", \"(cn={0})\",\nsearchArguments, searchControls);\n// Process the response answer\nwhile (answer.hasMoreElements()) {\n  ...\n}\n```\n\nFor information on enabling authentication, please see your LDAP server's\ndocumentation."
              },
              "id": "java.security.java-anonymous-ldap",
              "name": "java.security.java-anonymous-ldap",
              "properties": {
                "tags": [
                  "CWE-306"
                ]
              },
              "shortDescription": {
                "text": "Missing authentication for critical function (LDAP)"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Detected MD5 hash algorithm which is considered insecure. MD5 is not collision resistant and is therefore not suitable as a cryptographic signature. Use HMAC instead.",
                "text": "Detected MD5 hash algorithm which is considered insecure. MD5 is not collision resistant and is therefore not suitable as a cryptographic signature. Use HMAC instead."
              },
              "id": "java.security.use-of-md5",
              "name": "java.security.use-of-md5",
              "properties": {
                "tags": [
                  "CWE-328"
                ]
              },
              "shortDescription": {
                "text": "MD5 hash algorithm is considered insecure"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Use of AES with no settings detected. By default, java.crypto.Cipher uses ECB mode. ECB doesn't provide message confidentiality and is not semantically secure so should not be used. Instead, use a strong, secure cipher: java.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").",
                "text": "Use of AES with no settings detected. By default, java.crypto.Cipher uses ECB mode. ECB doesn't provide message confidentiality and is not semantically secure so should not be used. Instead, use a strong, secure cipher: java.crypto.Cipher.getInstance(\"AES/CBC/PKCS7PADDING\")."
              },
              "id": "java.security.use-of-default-aes",
              "name": "java.security.use-of-default-aes",
              "properties": {
                "tags": [
                  "CWE-327"
                ]
              },
              "shortDescription": {
                "text": "Use of AES with no settings detected, so uses insecure ECB mode"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Detected use of the 'none' algorithm in a JWT token. The 'none' algorithm assumes the integrity of the token has already been verified. This would allow a malicious actor to forge a JWT token that will automatically be verified. Do not explicitly use the 'none' algorithm.",
                "text": "Detected use of the 'none' algorithm in a JWT token. The 'none' algorithm assumes the integrity of the token has already been verified. This would allow a malicious actor to forge a JWT token that will automatically be verified. Do not explicitly use the 'none' algorithm."
              },
              "id": "java.security.jjwt-none-alg",
              "name": "java.security.jjwt-none-alg",
              "properties": {
                "tags": [
                  "CWE-327"
                ]
              },
              "shortDescription": {
                "text": "Risky Cryptographic Algorithm for a JWT token."
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "The application was found matching a variable during a regular expression\npattern match, and then calling a Unicode normalize function after validation has occurred.\nThis is usually indicative of a poor input validation strategy as an adversary may attempt to\nexploit the normalization process.\n\nTo remediate this issue, always perform Unicode normalization before any validation of a\nstring.\n\nExample of normalizing a string before validation:\n```\n// User input possibly containing malicious unicode\nString userInput = \"\\uFE64\" + \"tag\" + \"\\uFE65\";\n// Normalize the input\nuserInput = Normalizer.normalize(userInput, Normalizer.Form.NFKC);\n// Compile our regex pattern looking for < or > characters\nPattern pattern = Pattern.compile(\"[<>]\");\n// Create a matcher from the userInput\nMatcher matcher = pattern.matcher(userInput);\n// See if the matcher matches\nif (matcher.find()) {\n    // It did so throw an error\n    throw new Exception(\"found banned characters in input\");\n}\n```",
                "text": "The application was found matching a variable during a regular expression\npattern match, and then calling a Unicode normalize function after validation has occurred.\nThis is usually indicative of a poor input validation strategy as an adversary may attempt to\nexploit the normalization process.\n\nTo remediate this issue, always perform Unicode normalization before any validation of a\nstring.\n\nExample of normalizing a string before validation:\n```\n// User input possibly containing malicious unicode\nString userInput = \"\\uFE64\" + \"tag\" + \"\\uFE65\";\n// Normalize the input\nuserInput = Normalizer.normalize(userInput, Normalizer.Form.NFKC);\n// Compile our regex pattern looking for < or > characters\nPattern pattern = Pattern.compile(\"[<>]\");\n// Create a matcher from the userInput\nMatcher matcher = pattern.matcher(userInput);\n// See if the matcher matches\nif (matcher.find()) {\n    // It did so throw an error\n    throw new Exception(\"found banned characters in input\");\n}\n```"
              },
              "id": "java.security.string-normalize-after-validation",
              "name": "java.security.string-normalize-after-validation",
              "properties": {
                "tags": [
                  "CWE-180"
                ]
              },
              "shortDescription": {
                "text": "String validate before canonicalization"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "'HS256' algorithm can be bruteforced, and thus is considered insecure in a JWT token.",
                "text": "'HS256' algorithm can be bruteforced, and thus is considered insecure in a JWT token."
              },
              "id": "java.security.jjwt-hs256",
              "name": "java.security.jjwt-hs256",
              "properties": {
                "tags": [
                  "CWE-327"
                ]
              },
              "shortDescription": {
                "text": "Risky Cryptographic Algorithm for a JWT token."
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Enabling extensions in Apache XML RPC server or client can lead to deserialization\nvulnerability which would allow an attacker to execute arbitrary code.\n",
                "text": "Enabling extensions in Apache XML RPC server or client can lead to deserialization\nvulnerability which would allow an attacker to execute arbitrary code.\n"
              },
              "id": "java.security.apache-rpc-enabled-extensions",
              "name": "java.security.apache-rpc-enabled-extensions",
              "properties": {
                "tags": [
                  "CWE-502"
                ]
              },
              "shortDescription": {
                "text": "Deserialization of untrusted data with arbitrary code execution"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "The application is disabling Wicket's string escaping functionality by calling `setEscapeModelStrings(false)`.\nThis could lead to Cross Site Scripting (XSS) if used with user-supplied input. XSS is an\nattack which exploits a web application or system to treat user input\nas markup or script code. It is important to encode the data depending on the specific context\nit is used in. There are at least six context types:\n\n- Inside HTML tags `<div>context 1</div>`\n- Inside attributes: `<div class=\"context 2\"></div>`\n- Inside event attributes `<button onclick=\"context 3\">button</button>`\n- Inside script blocks: `<script>var x = \"context 4\"</script>`\n- Unsafe element HTML assignment: `element.innerHTML = \"context 5\"`\n- Inside URLs: `<iframe src=\"context 6\"></iframe><a href=\"context 6\">link</a>`\n\nScript blocks alone have multiple ways they need to be encoded. Extra care must be taken if\nuser input is ever output inside of script tags.\n\nUser input that is displayed within the application must be encoded, sanitized or validated\nto ensure it cannot be treated as HTML or executed as JavaScript code. Care must also be\ntaken to not mix server-side templating with client-side templating, as the server-side templating\nwill not encode things like {{ 7*7 }} which may execute client-side templating features.\n\nIt is _NOT_ advised to encode user input prior to inserting into a data store. The data will\nneed to be encoded depending on context of where it is output. It is much safer to force the displaying\nsystem to handle the encoding and not attempt to guess how it should be encoded.\n\nUse Wicket's built in escaping feature by calling `Component.setEscapeModelStrings(true);`",
                "text": "The application is disabling Wicket's string escaping functionality by calling `setEscapeModelStrings(false)`.\nThis could lead to Cross Site Scripting (XSS) if used with user-supplied input. XSS is an\nattack which exploits a web application or system to treat user input\nas markup or script code. It is important to encode the data depending on the specific context\nit is used in. There are at least six context types:\n\n- Inside HTML tags `<div>context 1</div>`\n- Inside attributes: `<div class=\"context 2\"></div>`\n- Inside event attributes `<button onclick=\"context 3\">button</button>`\n- Inside script blocks: `<script>var x = \"context 4\"</script>`\n- Unsafe element HTML assignment: `element.innerHTML = \"context 5\"`\n- Inside URLs: `<iframe src=\"context 6\"></iframe><a href=\"context 6\">link</a>`\n\nScript blocks alone have multiple ways they need to be encoded. Extra care must be taken if\nuser input is ever output inside of script tags.\n\nUser input that is displayed within the application must be encoded, sanitized or validated\nto ensure it cannot be treated as HTML or executed as JavaScript code. Care must also be\ntaken to not mix server-side templating with client-side templating, as the server-side templating\nwill not encode things like {{ 7*7 }} which may execute client-side templating features.\n\nIt is _NOT_ advised to encode user input prior to inserting into a data store. The data will\nneed to be encoded depending on context of where it is output. It is much safer to force the displaying\nsystem to handle the encoding and not attempt to guess how it should be encoded.\n\nUse Wicket's built in escaping feature by calling `Component.setEscapeModelStrings(true);`"
              },
              "id": "java.security.wicket-xss",
              "name": "java.security.wicket-xss",
              "properties": {
                "tags": [
                  "CWE-79"
                ]
              },
              "shortDescription": {
                "text": "Disabling Wicket's string escaping can lead to Cross Site Scripting (XSS)"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "A potential hard-coded password was identified in a hard-coded string.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation",
                "text": "A potential hard-coded password was identified in a hard-coded string.\nPasswords should not be stored directly in code\nbut loaded from secure locations such as a Key Management System (KMS).\n\nThe purpose of using a Key Management System is so access can be audited and keys easily\nrotated\nin the event of a breach. By hardcoding passwords, it will be extremely difficult to determine\nwhen or if, a key is compromised.\n\nThe recommendation on which KMS to use depends on the environment the application is running\nin:\n\n- For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)\n- For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)\n- For on premise or other alternatives to cloud providers, consider [Hashicorp's\nVault](https://www.vaultproject.io/)\n- For other cloud providers, please see their documentation"
              },
              "id": "java.security.hardcoded-password",
              "name": "java.security.hardcoded-password",
              "properties": {
                "tags": [
                  "CWE-259"
                ]
              },
              "shortDescription": {
                "text": "Use of hard-coded password"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Triple DES (3DES or DESede) is considered deprecated. AES is the recommended cipher. Upgrade to use AES.",
                "text": "Triple DES (3DES or DESede) is considered deprecated. AES is the recommended cipher. Upgrade to use AES."
              },
              "id": "java.security.desede-is-deprecated",
              "name": "java.security.desede-is-deprecated",
              "properties": {
                "tags": [
                  "CWE-326"
                ]
              },
              "shortDescription": {
                "text": "Triple DES (3DES or DESede) is considered deprecated"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "SAML parses attestations as an XML document. By processing XML comments, comment\nfields can end up modifying the interpretation of input fields. This could allow\nan adversary to insert an XML comment to break up the attestation's username\nor other fields, allowing an attacker to bypass authorization or authentication checks.\n\nTo remediate this issue, when using `org.opensaml.xml.parse.BasicParserPool` ensure\n`setIgnoreComments(false)` is not called.\n\nThe default value of `ignoreComments` is true, which is safe.",
                "text": "SAML parses attestations as an XML document. By processing XML comments, comment\nfields can end up modifying the interpretation of input fields. This could allow\nan adversary to insert an XML comment to break up the attestation's username\nor other fields, allowing an attacker to bypass authorization or authentication checks.\n\nTo remediate this issue, when using `org.opensaml.xml.parse.BasicParserPool` ensure\n`setIgnoreComments(false)` is not called.\n\nThe default value of `ignoreComments` is true, which is safe."
              },
              "id": "java.security.java-saml-ignore-comments",
              "name": "java.security.java-saml-ignore-comments",
              "properties": {
                "tags": [
                  "CWE-1390"
                ]
              },
              "shortDescription": {
                "text": "Weak authentication"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "LDAP entry poisoning in Java JNDI occurs when an application trusts LDAP entries to be converted\ndirectly into Java objects. When `SearchControls.setReturningObjFlag(true)` is called,\nthe JNDI/LDAP provider will attempt to reconstruct Java objects (or follow remote references)\nfrom the data stored in LDAP attributes. If an attacker can control the LDAP server or the data in the\ndirectory, they can supply malicious object data or references that the client will instantiate/deserialise,\npotentially leading to remote code execution or other compromise.\n\n```java\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.directory.*;\n\nimport java.util.Hashtable;\n\npublic class VulnerableLdapLookup {\n\n    public Object lookupUserObject(String url, String baseDn, String filter) throws Exception {\n        Hashtable<String, String> env = new Hashtable<>();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(Context.PROVIDER_URL, url);\n\n        DirContext ctx = new InitialDirContext(env);\n\n        SearchControls sc = new SearchControls();\n        sc.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        // VULNERABLE: enables automatic reconstruction of Java objects from LDAP entries\n        sc.setReturningObjFlag(true);\n\n        NamingEnumeration<SearchResult> results = ctx.search(baseDn, filter, sc);\n        if (results.hasMore()) {\n            SearchResult sr = results.next();\n\n            // This will trigger object factories / deserialisation or remote class loading\n            // based on data controlled by the LDAP server / directory contents\n            Object obj = sr.getObject();\n\n            return obj; // The returned object may be attacker-controlled\n        }\n        return null;\n    }\n}\n```\n\nTo remediate this issue, avoid using `setReturningObjFlag(true)` with any LDAP data that is not\nfully trusted, and treat LDAP as a text/attribute store rather than a source of Java objects.\nRetrieve and parse attributes explicitly, and ensure remote codebases and object factories are not used for untrusted data:\n\n```java\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.directory.*;\n\nimport java.util.Hashtable;\n\npublic class SafeLdapLookup {\n\n    public String lookupUserEmail(String url, String baseDn, String filter) throws Exception {\n        Hashtable<String, String> env = new Hashtable<>();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(Context.PROVIDER_URL, url);\n\n        // Defensive settings (on modern JDKs these are typically default,\n        // but it's safer to set them explicitly when possible)\n        System.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"false\");\n        System.setProperty(\"java.rmi.server.useCodebaseOnly\", \"true\");\n\n        DirContext ctx = new InitialDirContext(env);\n\n        SearchControls sc = new SearchControls();\n        sc.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        // SAFE: do not request Java objects, only raw attributes\n        sc.setReturningObjFlag(false);\n        sc.setReturningAttributes(new String[] { \"mail\" });\n\n        NamingEnumeration<SearchResult> results = ctx.search(baseDn, filter, sc);\n        if (results.hasMore()) {\n            SearchResult sr = results.next();\n            Attributes attrs = sr.getAttributes();\n\n            Attribute mailAttr = attrs.get(\"mail\");\n            if (mailAttr != null) {\n                return (String) mailAttr.get();\n            }\n        }\n        return null;\n    }\n}\n```\n\nAdditional hardening recommendations:\n\n- Never deserialize or instantiate objects coming from LDAP unless they are from a fully trusted source under your control.\n- Prefer simple data types (strings, numbers) in directory entries; avoid storing serialized Java objects.\n- Restrict LDAP endpoints to trusted servers and networks; validate and pin configuration rather than accepting user-supplied LDAP URLs.\n- Keep your JDK and JNDI provider up to date to benefit from safer defaults.",
                "text": "LDAP entry poisoning in Java JNDI occurs when an application trusts LDAP entries to be converted\ndirectly into Java objects. When `SearchControls.setReturningObjFlag(true)` is called,\nthe JNDI/LDAP provider will attempt to reconstruct Java objects (or follow remote references)\nfrom the data stored in LDAP attributes. If an attacker can control the LDAP server or the data in the\ndirectory, they can supply malicious object data or references that the client will instantiate/deserialise,\npotentially leading to remote code execution or other compromise.\n\n```java\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.directory.*;\n\nimport java.util.Hashtable;\n\npublic class VulnerableLdapLookup {\n\n    public Object lookupUserObject(String url, String baseDn, String filter) throws Exception {\n        Hashtable<String, String> env = new Hashtable<>();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(Context.PROVIDER_URL, url);\n\n        DirContext ctx = new InitialDirContext(env);\n\n        SearchControls sc = new SearchControls();\n        sc.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        // VULNERABLE: enables automatic reconstruction of Java objects from LDAP entries\n        sc.setReturningObjFlag(true);\n\n        NamingEnumeration<SearchResult> results = ctx.search(baseDn, filter, sc);\n        if (results.hasMore()) {\n            SearchResult sr = results.next();\n\n            // This will trigger object factories / deserialisation or remote class loading\n            // based on data controlled by the LDAP server / directory contents\n            Object obj = sr.getObject();\n\n            return obj; // The returned object may be attacker-controlled\n        }\n        return null;\n    }\n}\n```\n\nTo remediate this issue, avoid using `setReturningObjFlag(true)` with any LDAP data that is not\nfully trusted, and treat LDAP as a text/attribute store rather than a source of Java objects.\nRetrieve and parse attributes explicitly, and ensure remote codebases and object factories are not used for untrusted data:\n\n```java\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.directory.*;\n\nimport java.util.Hashtable;\n\npublic class SafeLdapLookup {\n\n    public String lookupUserEmail(String url, String baseDn, String filter) throws Exception {\n        Hashtable<String, String> env = new Hashtable<>();\n        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        env.put(Context.PROVIDER_URL, url);\n\n        // Defensive settings (on modern JDKs these are typically default,\n        // but it's safer to set them explicitly when possible)\n        System.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"false\");\n        System.setProperty(\"java.rmi.server.useCodebaseOnly\", \"true\");\n\n        DirContext ctx = new InitialDirContext(env);\n\n        SearchControls sc = new SearchControls();\n        sc.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        // SAFE: do not request Java objects, only raw attributes\n        sc.setReturningObjFlag(false);\n        sc.setReturningAttributes(new String[] { \"mail\" });\n\n        NamingEnumeration<SearchResult> results = ctx.search(baseDn, filter, sc);\n        if (results.hasMore()) {\n            SearchResult sr = results.next();\n            Attributes attrs = sr.getAttributes();\n\n            Attribute mailAttr = attrs.get(\"mail\");\n            if (mailAttr != null) {\n                return (String) mailAttr.get();\n            }\n        }\n        return null;\n    }\n}\n```\n\nAdditional hardening recommendations:\n\n- Never deserialize or instantiate objects coming from LDAP unless they are from a fully trusted source under your control.\n- Prefer simple data types (strings, numbers) in directory entries; avoid storing serialized Java objects.\n- Restrict LDAP endpoints to trusted servers and networks; validate and pin configuration rather than accepting user-supplied LDAP URLs.\n- Keep your JDK and JNDI provider up to date to benefit from safer defaults."
              },
              "id": "java.security.ldap-entry-poisoning",
              "name": "java.security.ldap-entry-poisoning",
              "properties": {
                "tags": [
                  "CWE-90"
                ]
              },
              "shortDescription": {
                "text": "An object-returning LDAP search will allow attackers to control the LDAP response"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "NullCipher was detected. This will not encrypt anything; the cipher text will be the same as the plain text. Use a valid, secure cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\").",
                "text": "NullCipher was detected. This will not encrypt anything; the cipher text will be the same as the plain text. Use a valid, secure cipher: Cipher.getInstance(\"AES/CBC/PKCS7PADDING\")."
              },
              "id": "java.security.no-null-cipher",
              "name": "java.security.no-null-cipher",
              "properties": {
                "tags": [
                  "CWE-327"
                ]
              },
              "shortDescription": {
                "text": "NullCipher was detected, this will not encrypt anything"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "A cookie was detected without setting the 'HttpOnly' flag. The 'HttpOnly' flag for cookies instructs the browser to forbid client-side scripts from reading the cookie. Set the 'HttpOnly' flag by calling 'cookie.setHttpOnly(true);'",
                "text": "A cookie was detected without setting the 'HttpOnly' flag. The 'HttpOnly' flag for cookies instructs the browser to forbid client-side scripts from reading the cookie. Set the 'HttpOnly' flag by calling 'cookie.setHttpOnly(true);'"
              },
              "id": "java.security.cookie-missing-httponly",
              "name": "java.security.cookie-missing-httponly",
              "properties": {
                "tags": [
                  "CWE-1004"
                ]
              },
              "shortDescription": {
                "text": "Sensitive cookie without 'HttpOnly' flag"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Using CBC with PKCS5Padding is susceptible to padding oracle attacks. A malicious actor could discern the difference between plaintext with valid or invalid padding. Further, CBC mode does not include any integrity checks. Use 'AES/GCM/NoPadding' instead.",
                "text": "Using CBC with PKCS5Padding is susceptible to padding oracle attacks. A malicious actor could discern the difference between plaintext with valid or invalid padding. Further, CBC mode does not include any integrity checks. Use 'AES/GCM/NoPadding' instead."
              },
              "id": "java.security.cbc-padding-oracle",
              "name": "java.security.cbc-padding-oracle",
              "properties": {
                "tags": [
                  "CWE-327"
                ]
              },
              "shortDescription": {
                "text": "Using CBC with PKCS5Padding is susceptible to padding oracle attacks"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "DES is considered deprecated. AES is the recommended cipher. Upgrade to use AES.",
                "text": "DES is considered deprecated. AES is the recommended cipher. Upgrade to use AES."
              },
              "id": "java.security.des-is-deprecated",
              "name": "java.security.des-is-deprecated",
              "properties": {
                "tags": [
                  "CWE-326"
                ]
              },
              "shortDescription": {
                "text": "DES is considered deprecated"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "The application was found printing stack information to the default system output. As stack trace data may contain sensitive information, it is recommended that the output be logged using a secure logging framework. Log files should also be protected with proper operating system permission levels.",
                "text": "The application was found printing stack information to the default system output. As stack trace data may contain sensitive information, it is recommended that the output be logged using a secure logging framework. Log files should also be protected with proper operating system permission levels."
              },
              "id": "java.security.stacktrace-printing-in-error-message",
              "name": "java.security.stacktrace-printing-in-error-message",
              "properties": {
                "tags": [
                  "CWE-209"
                ]
              },
              "shortDescription": {
                "text": "Information exposure through an error message"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Detected use of the 'none' algorithm in a JWT token. The 'none' algorithm assumes the integrity of the token has already been verified. This would allow a malicious actor to forge a JWT token that will automatically be verified. Do not explicitly use the 'none' algorithm. Instead, use an algorithm such as 'HS256'.",
                "text": "Detected use of the 'none' algorithm in a JWT token. The 'none' algorithm assumes the integrity of the token has already been verified. This would allow a malicious actor to forge a JWT token that will automatically be verified. Do not explicitly use the 'none' algorithm. Instead, use an algorithm such as 'HS256'."
              },
              "id": "java.security.jwt-none-alg",
              "name": "java.security.jwt-none-alg",
              "properties": {
                "tags": [
                  "CWE-327"
                ]
              },
              "shortDescription": {
                "text": "Do not explicitly use the 'none' JWT algorithm, as assumes the integrity of the token has already been verified"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Hardcoded encryption key makes AES symmetric encryption useless. An attacker can easily reverse engineer the application and recover the keys.",
                "text": "Hardcoded encryption key makes AES symmetric encryption useless. An attacker can easily reverse engineer the application and recover the keys."
              },
              "id": "java.security.aes-hardcoded-key",
              "name": "java.security.aes-hardcoded-key",
              "properties": {
                "tags": [
                  "CWE-321"
                ]
              },
              "shortDescription": {
                "text": "Hardcoded encryption key makes AES symmetric encryption useless"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "A permissive Cross-Origin Resource Sharing (CORS) configuration (for example, sending `Access-Control-Allow-Origin: *`)\nallows any website to make cross-origin requests to your application from a user's browser.\nIf the API exposes sensitive data and/or accepts browser credentials (cookies, HTTP authentication,\nbearer tokens from JavaScript), this can let an attacker's site read data or perform actions as the logged-in user.\nCORS is not an authentication or authorization mechanism; treating it as one or configuring it too\nbroadly is a common misconfiguration that breaks the browser's same-origin policy and enables data exfiltration\nfrom protected endpoints.\n\n> Note: Modern browsers do not allow `Access-Control-Allow-Credentials: true`\ntogether with the literal wildcard `*`, but developers often implement the logical\nequivalent by reflecting the `Origin` header for any origin. Both cases are “permissive CORS” and vulnerable.\n\n\n### Vulnerable code sample\n\nExample using a Java Servlet `Filter` that unconditionally allows any origin:\n\n```java\nimport jakarta.servlet.*;\nimport jakarta.servlet.annotation.WebFilter;\nimport jakarta.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@WebFilter(\"/*\")\npublic class CorsFilter implements Filter {\n\n    @Override\n    public void doFilter(ServletRequest request,\n                        ServletResponse response,\n                        FilterChain chain)\n            throws IOException, ServletException {\n\n        HttpServletResponse httpResp = (HttpServletResponse) response;\n\n        // VULNERABLE: allows any origin to read responses\n        httpResp.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        httpResp.setHeader(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\");\n        httpResp.setHeader(\"Access-Control-Allow-Headers\", \"Origin, Content-Type, Accept, Authorization\");\n        httpResp.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); // also unsafe pattern\n\n        chain.doFilter(request, response);\n    }\n}\n```\n\nImpact:\n\n- Any website can issue cross-origin AJAX/fetch requests to these endpoints.\n- If the application relies on cookies or other automatic credentials, and CORS is\n  configured permissively (for example, with `Allow-Credentials: true` and origin reflection),\n  the attacker's site can read sensitive responses as the victim user (e.g., profile data,\n  account details, CSRF-protected actions' results).\n- Even without credentials, responses that were intended only for your own frontend become\n  readable to arbitrary third-party sites (e.g., internal APIs, metadata, rate-limit info, etc.).\n\n\n### To remediate this issue\n\nConfigure CORS to allow **only known, trusted origins** and avoid wildcards for endpoints that return anything non-public.\nDo not reflect arbitrary `Origin` values, and avoid combining broad origin rules with `Access-Control-Allow-Credentials: true`.\n\nExample safer Servlet `Filter` using an explicit allowlist:\n\n```java\nimport jakarta.servlet.*;\nimport jakarta.servlet.annotation.WebFilter;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Set;\n\n@WebFilter(\"/*\")\npublic class CorsFilter implements Filter {\n\n    // Explicitly allowed front-end origins\n    private static final Set<String> ALLOWED_ORIGINS = Set.of(\n        \"https://app.example.com\",\n        \"https://admin.example.com\"\n    );\n\n    @Override\n    public void doFilter(ServletRequest request,\n                        ServletResponse response,\n                        FilterChain chain)\n            throws IOException, ServletException {\n\n        HttpServletRequest httpReq = (HttpServletRequest) request;\n        HttpServletResponse httpResp = (HttpServletResponse) response;\n\n        String origin = httpReq.getHeader(\"Origin\");\n        if (origin != null && ALLOWED_ORIGINS.contains(origin)) {\n            httpResp.setHeader(\"Access-Control-Allow-Origin\", origin);\n            httpResp.setHeader(\"Vary\", \"Origin\"); // ensure caches differentiate by Origin\n            httpResp.setHeader(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\");\n            httpResp.setHeader(\"Access-Control-Allow-Headers\", \"Origin, Content-Type, Accept, Authorization\");\n            httpResp.setHeader(\"Access-Control-Allow-Credentials\", \"true\");\n        }\n\n        // Optionally handle preflight (OPTIONS) requests here if needed\n\n        chain.doFilter(request, response);\n    }\n}\n```\n\nKey remediation points:\n\n- Replace `Access-Control-Allow-Origin: *` with a strict allowlist of trusted origins.\n- Only enable `Access-Control-Allow-Credentials: true` when strictly necessary and **never** for arbitrary/unvalidated origins.\n- Treat all endpoints exposed via CORS as if they are accessible to any code running in those allowed origins' contexts; do not rely on CORS for access control.\n- For APIs intended to be truly public, using `*` is acceptable only if you are certain that:\n  - No cookies or other automatic browser credentials are involved, and\n  - All returned data is safe to be read by any third-party website.",
                "text": "A permissive Cross-Origin Resource Sharing (CORS) configuration (for example, sending `Access-Control-Allow-Origin: *`)\nallows any website to make cross-origin requests to your application from a user's browser.\nIf the API exposes sensitive data and/or accepts browser credentials (cookies, HTTP authentication,\nbearer tokens from JavaScript), this can let an attacker's site read data or perform actions as the logged-in user.\nCORS is not an authentication or authorization mechanism; treating it as one or configuring it too\nbroadly is a common misconfiguration that breaks the browser's same-origin policy and enables data exfiltration\nfrom protected endpoints.\n\n> Note: Modern browsers do not allow `Access-Control-Allow-Credentials: true`\ntogether with the literal wildcard `*`, but developers often implement the logical\nequivalent by reflecting the `Origin` header for any origin. Both cases are “permissive CORS” and vulnerable.\n\n\n### Vulnerable code sample\n\nExample using a Java Servlet `Filter` that unconditionally allows any origin:\n\n```java\nimport jakarta.servlet.*;\nimport jakarta.servlet.annotation.WebFilter;\nimport jakarta.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@WebFilter(\"/*\")\npublic class CorsFilter implements Filter {\n\n    @Override\n    public void doFilter(ServletRequest request,\n                        ServletResponse response,\n                        FilterChain chain)\n            throws IOException, ServletException {\n\n        HttpServletResponse httpResp = (HttpServletResponse) response;\n\n        // VULNERABLE: allows any origin to read responses\n        httpResp.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n        httpResp.setHeader(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\");\n        httpResp.setHeader(\"Access-Control-Allow-Headers\", \"Origin, Content-Type, Accept, Authorization\");\n        httpResp.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); // also unsafe pattern\n\n        chain.doFilter(request, response);\n    }\n}\n```\n\nImpact:\n\n- Any website can issue cross-origin AJAX/fetch requests to these endpoints.\n- If the application relies on cookies or other automatic credentials, and CORS is\n  configured permissively (for example, with `Allow-Credentials: true` and origin reflection),\n  the attacker's site can read sensitive responses as the victim user (e.g., profile data,\n  account details, CSRF-protected actions' results).\n- Even without credentials, responses that were intended only for your own frontend become\n  readable to arbitrary third-party sites (e.g., internal APIs, metadata, rate-limit info, etc.).\n\n\n### To remediate this issue\n\nConfigure CORS to allow **only known, trusted origins** and avoid wildcards for endpoints that return anything non-public.\nDo not reflect arbitrary `Origin` values, and avoid combining broad origin rules with `Access-Control-Allow-Credentials: true`.\n\nExample safer Servlet `Filter` using an explicit allowlist:\n\n```java\nimport jakarta.servlet.*;\nimport jakarta.servlet.annotation.WebFilter;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Set;\n\n@WebFilter(\"/*\")\npublic class CorsFilter implements Filter {\n\n    // Explicitly allowed front-end origins\n    private static final Set<String> ALLOWED_ORIGINS = Set.of(\n        \"https://app.example.com\",\n        \"https://admin.example.com\"\n    );\n\n    @Override\n    public void doFilter(ServletRequest request,\n                        ServletResponse response,\n                        FilterChain chain)\n            throws IOException, ServletException {\n\n        HttpServletRequest httpReq = (HttpServletRequest) request;\n        HttpServletResponse httpResp = (HttpServletResponse) response;\n\n        String origin = httpReq.getHeader(\"Origin\");\n        if (origin != null && ALLOWED_ORIGINS.contains(origin)) {\n            httpResp.setHeader(\"Access-Control-Allow-Origin\", origin);\n            httpResp.setHeader(\"Vary\", \"Origin\"); // ensure caches differentiate by Origin\n            httpResp.setHeader(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\");\n            httpResp.setHeader(\"Access-Control-Allow-Headers\", \"Origin, Content-Type, Accept, Authorization\");\n            httpResp.setHeader(\"Access-Control-Allow-Credentials\", \"true\");\n        }\n\n        // Optionally handle preflight (OPTIONS) requests here if needed\n\n        chain.doFilter(request, response);\n    }\n}\n```\n\nKey remediation points:\n\n- Replace `Access-Control-Allow-Origin: *` with a strict allowlist of trusted origins.\n- Only enable `Access-Control-Allow-Credentials: true` when strictly necessary and **never** for arbitrary/unvalidated origins.\n- Treat all endpoints exposed via CORS as if they are accessible to any code running in those allowed origins' contexts; do not rely on CORS for access control.\n- For APIs intended to be truly public, using `*` is acceptable only if you are certain that:\n  - No cookies or other automatic browser credentials are involved, and\n  - All returned data is safe to be read by any third-party website."
              },
              "id": "java.security.permissive-cors",
              "name": "java.security.permissive-cors",
              "properties": {
                "tags": [
                  "CWE-183"
                ]
              },
              "shortDescription": {
                "text": "Permissive CORS policy causes security risks"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Cryptographic implementations with insufficient key length is susceptible to bruteforce attacks.",
                "text": "Cryptographic implementations with insufficient key length is susceptible to bruteforce attacks."
              },
              "id": "java.security.weak-ec-key-size",
              "name": "java.security.weak-ec-key-size",
              "properties": {
                "tags": [
                  "CWE-326"
                ]
              },
              "shortDescription": {
                "text": "Cryptographic implementations with insufficient key length is susceptible to bruteforce attacks"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Using RSA without OAEP mode weakens the encryption.",
                "text": "Using RSA without OAEP mode weakens the encryption."
              },
              "id": "java.security.rsa-no-padding",
              "name": "java.security.rsa-no-padding",
              "properties": {
                "tags": [
                  "CWE-326"
                ]
              },
              "shortDescription": {
                "text": "Using RSA without OAEP mode weakens the encryption"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Default session middleware settings: `setSecure` not set to true. This ensures that the cookie is sent only over HTTPS to prevent cross-site scripting attacks.",
                "text": "Default session middleware settings: `setSecure` not set to true. This ensures that the cookie is sent only over HTTPS to prevent cross-site scripting attacks."
              },
              "id": "java.security.cookie-issecure-false",
              "name": "java.security.cookie-issecure-false",
              "properties": {
                "tags": []
              },
              "shortDescription": {
                "text": "Cleartext transmission of sensitive cookie value"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Found MongoDB client with SSL hostname verification disabled",
                "text": "Found MongoDB client with SSL hostname verification disabled"
              },
              "id": "java.security.mongo-hostname-verification-disabled",
              "name": "java.security.mongo-hostname-verification-disabled",
              "properties": {
                "tags": [
                  "CWE-295"
                ]
              },
              "shortDescription": {
                "text": "MongoDB client with SSL hostname verification disabled"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "DefaultHttpClient is deprecated. Further, it does not support connections using TLS1.2, which makes using DefaultHttpClient a security hazard. Use HttpClientBuilder instead.",
                "text": "DefaultHttpClient is deprecated. Further, it does not support connections using TLS1.2, which makes using DefaultHttpClient a security hazard. Use HttpClientBuilder instead."
              },
              "id": "java.security.defaulthttpclient-is-deprecated",
              "name": "java.security.defaulthttpclient-is-deprecated",
              "properties": {
                "tags": [
                  "CWE-326"
                ]
              },
              "shortDescription": {
                "text": "DefaultHttpClient is deprecated, its usage is not recommended for security reasons"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "When a Spring MVC handler is mapped with `@RequestMapping(...)` **without specifying the HTTP method**\n(e.g. `@RequestMapping(\"/transfer\")` instead of `@PostMapping(\"/transfer\")` or\n`@RequestMapping(value=\"/transfer\", method = RequestMethod.POST)`),\nSpring will by default allow that endpoint to be called with **any HTTP method**, including `GET`.\n\nIf Spring Security CSRF protection is enabled, it typically **only enforces CSRF tokens\non “unsafe” methods** (POST, PUT, PATCH, DELETE). If your state‑changing logic is unintentionally callable via `GET`,\nthat request path will generally **not require a CSRF token**, allowing attackers to trigger\nsensitive actions with a simple cross-site `GET` request (e.g. an `<img>` tag or auto-submitting form).\n\nThe consequences can include:\n\n- **Unauthorized state changes** — money transfers, order submissions, account updates, or other\n  business actions performed as the logged-in user, simply by visiting a malicious page.\n- **Data integrity issues** — records can be modified or deleted, workflows approved, or\n  configurations changed via a GET request the developer thought was “POST‑only.”\n- **Broader compromise when combined with other flaws** — missing HTTP method constraints can become\n  a pivot for account takeover or privilege escalation if admin or highly sensitive actions are exposed.\n- **Regulatory and business impact** — fraudulent transactions, corrupted data, and loss of user trust,\n  with potential compliance violations (e.g., for financial or personal data).",
                "text": "When a Spring MVC handler is mapped with `@RequestMapping(...)` **without specifying the HTTP method**\n(e.g. `@RequestMapping(\"/transfer\")` instead of `@PostMapping(\"/transfer\")` or\n`@RequestMapping(value=\"/transfer\", method = RequestMethod.POST)`),\nSpring will by default allow that endpoint to be called with **any HTTP method**, including `GET`.\n\nIf Spring Security CSRF protection is enabled, it typically **only enforces CSRF tokens\non “unsafe” methods** (POST, PUT, PATCH, DELETE). If your state‑changing logic is unintentionally callable via `GET`,\nthat request path will generally **not require a CSRF token**, allowing attackers to trigger\nsensitive actions with a simple cross-site `GET` request (e.g. an `<img>` tag or auto-submitting form).\n\nThe consequences can include:\n\n- **Unauthorized state changes** — money transfers, order submissions, account updates, or other\n  business actions performed as the logged-in user, simply by visiting a malicious page.\n- **Data integrity issues** — records can be modified or deleted, workflows approved, or\n  configurations changed via a GET request the developer thought was “POST‑only.”\n- **Broader compromise when combined with other flaws** — missing HTTP method constraints can become\n  a pivot for account takeover or privilege escalation if admin or highly sensitive actions are exposed.\n- **Regulatory and business impact** — fraudulent transactions, corrupted data, and loss of user trust,\n  with potential compliance violations (e.g., for financial or personal data)."
              },
              "id": "java.security.unrestricted-request-mapping",
              "name": "java.security.unrestricted-request-mapping",
              "properties": {
                "tags": [
                  "CWE-352"
                ]
              },
              "shortDescription": {
                "text": "RequestMapping that does not specify the HTTP method might cause vulnerability to CSRF attacks"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Cipher in ECB mode is detected. ECB mode produces the same output for the same input each time which allows an attacker to intercept and replay the data. Further, ECB mode does not provide any integrity checking.",
                "text": "Cipher in ECB mode is detected. ECB mode produces the same output for the same input each time which allows an attacker to intercept and replay the data. Further, ECB mode does not provide any integrity checking."
              },
              "id": "java.security.ecb-cipher",
              "name": "java.security.ecb-cipher",
              "properties": {
                "tags": [
                  "CWE-327"
                ]
              },
              "shortDescription": {
                "text": "Cipher in ECB mode is detected, which is considered to be insecure."
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "The network communications for Hazelcast is configured to use a deprecated symmetric cipher. Consider using TLS/SSL when establishing communications across the Hazelcast cluster.",
                "text": "The network communications for Hazelcast is configured to use a deprecated symmetric cipher. Consider using TLS/SSL when establishing communications across the Hazelcast cluster."
              },
              "id": "java.security.hazelcast-symmetric-encryption",
              "name": "java.security.hazelcast-symmetric-encryption",
              "properties": {
                "tags": [
                  "CWE-326"
                ]
              },
              "shortDescription": {
                "text": "Inadequate encryption strength"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Hardcoding a JSON Web Token (JWT) signing secret in Java source code is a critical security vulnerability. If the code (or compiled artifacts, logs, backups, or configuration snapshots) is ever exposed, an attacker can recover the secret and forge valid JWTs. This allows them to impersonate users, escalate privileges, bypass authentication and authorization checks, and maintain long‑term access because hardcoded secrets are difficult to rotate and are often reused across environments (development, staging, production), increasing overall impact.\n\n```java\n// Vulnerable code sample (Java with JJWT)\n\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class AuthController {\n\n    // Hardcoded JWT secret — vulnerable\n    private static final String JWT_SECRET = \"my-super-secret-key-123\"; // Do NOT hardcode secrets\n\n    public void login(String username, HttpServletResponse response) throws IOException {\n        // Normally you would validate the username/password first\n\n        String token = Jwts.builder()\n                .setSubject(username)\n                .signWith(SignatureAlgorithm.HS256, JWT_SECRET) // Anyone with JWT_SECRET can forge tokens\n                .compact();\n\n        response.getWriter().write(token);\n    }\n}\n```\n\nTo remediate this issue, never embed JWT signing keys directly in Java source code, configuration files committed to version control, or client-side code. Instead:\n\n- Store the JWT secret in a secure secret-management solution (e.g., cloud KMS, HashiCorp Vault, AWS Secrets Manager, GCP Secret Manager) or at minimum inject it as an environment variable managed by your deployment platform.\n- Use different secrets per environment (dev/test/prod) and define a rotation process.\n- Enforce minimum strength (length/entropy) for the secret and short token lifetimes to reduce impact of compromise.\n- Fail fast at startup if the secret is missing or invalid.\n\nExample using an environment variable and basic validation:\n\n```java\n// Safer code sample (Java with JJWT)\n\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\nimport io.jsonwebtoken.security.Keys;\n\nimport javax.crypto.SecretKey;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\npublic class SecureAuthController {\n\n    // Load secret from environment or secret manager (injected at deploy time)\n    private static final String RAW_SECRET = System.getenv(\"JWT_SECRET\");\n\n    // Initialize a strong key from the secret\n    private static final SecretKey JWT_KEY = initKey();\n\n    private static SecretKey initKey() {\n        if (RAW_SECRET == null || RAW_SECRET.length() < 32) {\n            // Fail fast: configuration error\n            throw new IllegalStateException(\"JWT_SECRET is not set or is too weak\");\n        }\n        // For HS256, use at least 256 bits (32+ chars of high entropy)\n        return Keys.hmacShaKeyFor(RAW_SECRET.getBytes(StandardCharsets.UTF_8));\n    }\n\n    public void login(String username, HttpServletResponse response) throws IOException {\n        String token = Jwts.builder()\n                .setSubject(username)\n                .signWith(JWT_KEY, SignatureAlgorithm.HS256)\n                .compact();\n\n        response.getWriter().write(token);\n    }\n}\n```",
                "text": "Hardcoding a JSON Web Token (JWT) signing secret in Java source code is a critical security vulnerability. If the code (or compiled artifacts, logs, backups, or configuration snapshots) is ever exposed, an attacker can recover the secret and forge valid JWTs. This allows them to impersonate users, escalate privileges, bypass authentication and authorization checks, and maintain long‑term access because hardcoded secrets are difficult to rotate and are often reused across environments (development, staging, production), increasing overall impact.\n\n```java\n// Vulnerable code sample (Java with JJWT)\n\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class AuthController {\n\n    // Hardcoded JWT secret — vulnerable\n    private static final String JWT_SECRET = \"my-super-secret-key-123\"; // Do NOT hardcode secrets\n\n    public void login(String username, HttpServletResponse response) throws IOException {\n        // Normally you would validate the username/password first\n\n        String token = Jwts.builder()\n                .setSubject(username)\n                .signWith(SignatureAlgorithm.HS256, JWT_SECRET) // Anyone with JWT_SECRET can forge tokens\n                .compact();\n\n        response.getWriter().write(token);\n    }\n}\n```\n\nTo remediate this issue, never embed JWT signing keys directly in Java source code, configuration files committed to version control, or client-side code. Instead:\n\n- Store the JWT secret in a secure secret-management solution (e.g., cloud KMS, HashiCorp Vault, AWS Secrets Manager, GCP Secret Manager) or at minimum inject it as an environment variable managed by your deployment platform.\n- Use different secrets per environment (dev/test/prod) and define a rotation process.\n- Enforce minimum strength (length/entropy) for the secret and short token lifetimes to reduce impact of compromise.\n- Fail fast at startup if the secret is missing or invalid.\n\nExample using an environment variable and basic validation:\n\n```java\n// Safer code sample (Java with JJWT)\n\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\nimport io.jsonwebtoken.security.Keys;\n\nimport javax.crypto.SecretKey;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\npublic class SecureAuthController {\n\n    // Load secret from environment or secret manager (injected at deploy time)\n    private static final String RAW_SECRET = System.getenv(\"JWT_SECRET\");\n\n    // Initialize a strong key from the secret\n    private static final SecretKey JWT_KEY = initKey();\n\n    private static SecretKey initKey() {\n        if (RAW_SECRET == null || RAW_SECRET.length() < 32) {\n            // Fail fast: configuration error\n            throw new IllegalStateException(\"JWT_SECRET is not set or is too weak\");\n        }\n        // For HS256, use at least 256 bits (32+ chars of high entropy)\n        return Keys.hmacShaKeyFor(RAW_SECRET.getBytes(StandardCharsets.UTF_8));\n    }\n\n    public void login(String username, HttpServletResponse response) throws IOException {\n        String token = Jwts.builder()\n                .setSubject(username)\n                .signWith(JWT_KEY, SignatureAlgorithm.HS256)\n                .compact();\n\n        response.getWriter().write(token);\n    }\n}\n```"
              },
              "id": "java.security.jwt-hardcoded-secret",
              "name": "java.security.jwt-hardcoded-secret",
              "properties": {
                "tags": [
                  "CWE-798"
                ]
              },
              "shortDescription": {
                "text": "Use of Hard-coded Credentials"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "When a Restful webservice endpoint isn't configured with a @Consumes annotation, an attacker could abuse the SerializableProvider by sending a HTTP Request with a Content-Type of application/x-java-serialized-object. The body of that request would be processed by the SerializationProvider and could contain a malicious payload, which may lead to arbitrary code execution. Instead, add a @Consumes annotation to the function or class.",
                "text": "When a Restful webservice endpoint isn't configured with a @Consumes annotation, an attacker could abuse the SerializableProvider by sending a HTTP Request with a Content-Type of application/x-java-serialized-object. The body of that request would be processed by the SerializationProvider and could contain a malicious payload, which may lead to arbitrary code execution. Instead, add a @Consumes annotation to the function or class."
              },
              "id": "java.security.default-resteasy-provider-abuse",
              "name": "java.security.default-resteasy-provider-abuse",
              "properties": {
                "tags": [
                  "CWE-502"
                ]
              },
              "shortDescription": {
                "text": "Insecure deserialization of request"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Unsafe reflection in Java occurs when user-controlled input is used to determine which classes or methods\nare loaded or invoked via the reflection API (e.g., `Class.forName`, `Method.invoke`).\nIf an attacker can influence the class name passed to `Class.forName`, they may be able to load arbitrary\napplication or library classes, trigger dangerous static initializers or constructors,\nor chain into further vulnerabilities, leading to code execution, privilege escalation, or denial of service.\n\nVulnerable code sample\n\n```java\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class DynamicLoaderServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        // User-controlled data from request parameter\n        String className = request.getParameter(\"className\");\n\n        try {\n            // UNSAFE: user input directly controls Class.forName\n            Class<?> clazz = Class.forName(className);\n            Object instance = clazz.getDeclaredConstructor().newInstance();\n\n            // Do something with the instance...\n            response.getWriter().println(\"Loaded class: \" + clazz.getName());\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }\n}\n```\n\nTo remediate this issue, never pass raw user input directly into `Class.forName` (or other reflection APIs). Instead:\n\n- Use an allowlist (fixed set) of permitted classes or a mapping from user input to known-safe classes.\n- Validate input strictly (e.g., only allow known identifiers, not full class names from the client).\n- Prefer explicit logic (e.g., `if/else`, `switch`, enums, or a configuration map) over arbitrary reflective loading.\n\nSafe example using a whitelist mapping:\n\n```java\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SafeDynamicLoaderServlet extends HttpServlet {\n\n    // Allowlist of logical names to actual classes\n    private static final Map<String, Class<?>> ALLOWED_CLASSES = new HashMap<>();\n    static {\n        ALLOWED_CLASSES.put(\"basicReport\", com.example.reports.BasicReport.class);\n        ALLOWED_CLASSES.put(\"summaryReport\", com.example.reports.SummaryReport.class);\n        // Add more allowed classes here\n    }\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String type = request.getParameter(\"reportType\");\n\n        Class<?> clazz = ALLOWED_CLASSES.get(type);\n        if (clazz == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid report type\");\n            return;\n        }\n\n        try {\n            Object instance = clazz.getDeclaredConstructor().newInstance();\n            // Safe: only instances of known, vetted classes are created\n            response.getWriter().println(\"Generated report of type: \" + type);\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }\n}\n```",
                "text": "Unsafe reflection in Java occurs when user-controlled input is used to determine which classes or methods\nare loaded or invoked via the reflection API (e.g., `Class.forName`, `Method.invoke`).\nIf an attacker can influence the class name passed to `Class.forName`, they may be able to load arbitrary\napplication or library classes, trigger dangerous static initializers or constructors,\nor chain into further vulnerabilities, leading to code execution, privilege escalation, or denial of service.\n\nVulnerable code sample\n\n```java\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class DynamicLoaderServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        // User-controlled data from request parameter\n        String className = request.getParameter(\"className\");\n\n        try {\n            // UNSAFE: user input directly controls Class.forName\n            Class<?> clazz = Class.forName(className);\n            Object instance = clazz.getDeclaredConstructor().newInstance();\n\n            // Do something with the instance...\n            response.getWriter().println(\"Loaded class: \" + clazz.getName());\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }\n}\n```\n\nTo remediate this issue, never pass raw user input directly into `Class.forName` (or other reflection APIs). Instead:\n\n- Use an allowlist (fixed set) of permitted classes or a mapping from user input to known-safe classes.\n- Validate input strictly (e.g., only allow known identifiers, not full class names from the client).\n- Prefer explicit logic (e.g., `if/else`, `switch`, enums, or a configuration map) over arbitrary reflective loading.\n\nSafe example using a whitelist mapping:\n\n```java\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SafeDynamicLoaderServlet extends HttpServlet {\n\n    // Allowlist of logical names to actual classes\n    private static final Map<String, Class<?>> ALLOWED_CLASSES = new HashMap<>();\n    static {\n        ALLOWED_CLASSES.put(\"basicReport\", com.example.reports.BasicReport.class);\n        ALLOWED_CLASSES.put(\"summaryReport\", com.example.reports.SummaryReport.class);\n        // Add more allowed classes here\n    }\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String type = request.getParameter(\"reportType\");\n\n        Class<?> clazz = ALLOWED_CLASSES.get(type);\n        if (clazz == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid report type\");\n            return;\n        }\n\n        try {\n            Object instance = clazz.getDeclaredConstructor().newInstance();\n            // Safe: only instances of known, vetted classes are created\n            response.getWriter().println(\"Generated report of type: \" + type);\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }\n}\n```"
              },
              "id": "java.security.unsafe-reflection-in-servlet-app",
              "name": "java.security.unsafe-reflection-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-470"
                ]
              },
              "shortDescription": {
                "text": "Allowing user input to control which classes or methods are used can let attackers manipulate program flow"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "The application allows user input to control format string parameters. By passing invalid format\nstring specifiers an adversary could cause the application to throw exceptions or possibly leak\ninternal information depending on application logic.\n\nNever allow user-supplied input to be used to create a format string. Replace all format string\narguments with hardcoded format strings containing the necessary specifiers.\n\nExample of using `String.format` safely:\n```\n// Get untrusted user input\nString userInput = request.getParameter(\"someInput\");\n// Ensure that user input is not included in the first argument to String.format\nString.format(\"Hardcoded string expecting a string: %s\", userInput);\n// ...\n```",
                "text": "The application allows user input to control format string parameters. By passing invalid format\nstring specifiers an adversary could cause the application to throw exceptions or possibly leak\ninternal information depending on application logic.\n\nNever allow user-supplied input to be used to create a format string. Replace all format string\narguments with hardcoded format strings containing the necessary specifiers.\n\nExample of using `String.format` safely:\n```\n// Get untrusted user input\nString userInput = request.getParameter(\"someInput\");\n// Ensure that user input is not included in the first argument to String.format\nString.format(\"Hardcoded string expecting a string: %s\", userInput);\n// ...\n```"
              },
              "id": "java.security.format-string-external-manipulation-in-spring-app",
              "name": "java.security.format-string-external-manipulation-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-134"
                ]
              },
              "shortDescription": {
                "text": "Use of externally-controlled format string"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "HTTP request/response splitting is a class of HTTP header injection vulnerabilities that occurs when untrusted input is inserted into HTTP headers without proper validation or encoding. An attacker can inject carriage return (`\\r`) and line feed (`\\n`) characters (CRLF) into header values, prematurely terminating one HTTP request/response and starting another. In Java web applications (Servlets, JSP, Spring MVC, etc.), this typically happens when user-controlled data is written directly into HTTP headers (including `Location` for redirects) without sanitization, enabling cache poisoning, cross-site scripting, and request smuggling/splitting attacks.\n\n```java\n// Vulnerable code sample\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\n\npublic class ProfileServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request,\n                        HttpServletResponse response)\n            throws ServletException, IOException {\n\n        // Attacker controls the 'user' parameter, e.g.:\n        // ?user=alice%0D%0ASet-Cookie:%20session=attacker\n        String user = request.getParameter(\"user\");\n\n        // VULNERABLE: unvalidated user input goes directly into an HTTP header\n        response.setHeader(\"X-User\", user);\n\n        // Another common pattern: unsafe redirect parameter\n        // e.g. ?next=%0D%0ASet-Cookie:%20session=attacker\n        String next = request.getParameter(\"next\");\n        response.sendRedirect(\"/home?next=\" + next);\n\n        // If 'user' or 'next' contain CRLF sequences, the attacker can\n        // inject additional headers or even a second HTTP response.\n    }\n}\n```\n\nTo remediate this issue, never write untrusted input directly into HTTP header fields (including `Location` for redirects) without strict validation and encoding:\n\n1. **Reject CR (`\\r`) and LF (`\\n`) characters in any value that may end up in a header.**\n2. **Validate header-related input with a whitelist (allow-list) of safe characters and/or specific patterns.** For example, language codes, tokens, or IDs should match a narrow regex.\n3. **For URLs and query parameters, use proper URL encoding** (`URLEncoder`) instead of concatenation.\n4. **Prefer framework helpers that enforce invariants**, such as `HttpServletResponse.encodeRedirectURL(...)`, and avoid exposing raw header manipulation to untrusted values.\n5. **Upgrade and configure your servlet container / app server** (Tomcat, Jetty, etc.) to ensure it rejects illegal CRLF in headers, but do not rely on this as the only defense.\n\nSafe example with validation and encoding:\n\n```java\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\n\npublic class SafeProfileServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request,\n                        HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String user = request.getParameter(\"user\");\n        if (user == null) {\n            user = \"anonymous\";\n        }\n\n        // 1. Reject CR/LF explicitly\n        if (user.contains(\"\\r\") || user.contains(\"\\n\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid user\");\n            return;\n        }\n\n        // 2. Optionally enforce a strict pattern for header-safe data\n        if (!user.matches(\"^[A-Za-z0-9_-]{1,32}$\")) {\n            user = \"anonymous\"; // or reject the request\n        }\n\n        // SAFE: header value is validated and free of CRLF\n        response.setHeader(\"X-User\", user);\n\n        // 3. When building URLs, encode untrusted input as a query parameter\n        String next = request.getParameter(\"next\");\n        if (next == null) {\n            next = \"/\";\n        }\n\n        // Reject CR/LF and other dangerous patterns if you later interpret 'next'\n        if (next.contains(\"\\r\") || next.contains(\"\\n\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid next parameter\");\n            return;\n        }\n\n        String encodedNext = URLEncoder.encode(next, StandardCharsets.UTF_8);\n        String redirectUrl = response.encodeRedirectURL(\"/home?next=\" + encodedNext);\n        response.sendRedirect(redirectUrl);\n    }\n}\n```",
                "text": "HTTP request/response splitting is a class of HTTP header injection vulnerabilities that occurs when untrusted input is inserted into HTTP headers without proper validation or encoding. An attacker can inject carriage return (`\\r`) and line feed (`\\n`) characters (CRLF) into header values, prematurely terminating one HTTP request/response and starting another. In Java web applications (Servlets, JSP, Spring MVC, etc.), this typically happens when user-controlled data is written directly into HTTP headers (including `Location` for redirects) without sanitization, enabling cache poisoning, cross-site scripting, and request smuggling/splitting attacks.\n\n```java\n// Vulnerable code sample\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\n\npublic class ProfileServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request,\n                        HttpServletResponse response)\n            throws ServletException, IOException {\n\n        // Attacker controls the 'user' parameter, e.g.:\n        // ?user=alice%0D%0ASet-Cookie:%20session=attacker\n        String user = request.getParameter(\"user\");\n\n        // VULNERABLE: unvalidated user input goes directly into an HTTP header\n        response.setHeader(\"X-User\", user);\n\n        // Another common pattern: unsafe redirect parameter\n        // e.g. ?next=%0D%0ASet-Cookie:%20session=attacker\n        String next = request.getParameter(\"next\");\n        response.sendRedirect(\"/home?next=\" + next);\n\n        // If 'user' or 'next' contain CRLF sequences, the attacker can\n        // inject additional headers or even a second HTTP response.\n    }\n}\n```\n\nTo remediate this issue, never write untrusted input directly into HTTP header fields (including `Location` for redirects) without strict validation and encoding:\n\n1. **Reject CR (`\\r`) and LF (`\\n`) characters in any value that may end up in a header.**\n2. **Validate header-related input with a whitelist (allow-list) of safe characters and/or specific patterns.** For example, language codes, tokens, or IDs should match a narrow regex.\n3. **For URLs and query parameters, use proper URL encoding** (`URLEncoder`) instead of concatenation.\n4. **Prefer framework helpers that enforce invariants**, such as `HttpServletResponse.encodeRedirectURL(...)`, and avoid exposing raw header manipulation to untrusted values.\n5. **Upgrade and configure your servlet container / app server** (Tomcat, Jetty, etc.) to ensure it rejects illegal CRLF in headers, but do not rely on this as the only defense.\n\nSafe example with validation and encoding:\n\n```java\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\n\npublic class SafeProfileServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request,\n                        HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String user = request.getParameter(\"user\");\n        if (user == null) {\n            user = \"anonymous\";\n        }\n\n        // 1. Reject CR/LF explicitly\n        if (user.contains(\"\\r\") || user.contains(\"\\n\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid user\");\n            return;\n        }\n\n        // 2. Optionally enforce a strict pattern for header-safe data\n        if (!user.matches(\"^[A-Za-z0-9_-]{1,32}$\")) {\n            user = \"anonymous\"; // or reject the request\n        }\n\n        // SAFE: header value is validated and free of CRLF\n        response.setHeader(\"X-User\", user);\n\n        // 3. When building URLs, encode untrusted input as a query parameter\n        String next = request.getParameter(\"next\");\n        if (next == null) {\n            next = \"/\";\n        }\n\n        // Reject CR/LF and other dangerous patterns if you later interpret 'next'\n        if (next.contains(\"\\r\") || next.contains(\"\\n\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid next parameter\");\n            return;\n        }\n\n        String encodedNext = URLEncoder.encode(next, StandardCharsets.UTF_8);\n        String redirectUrl = response.encodeRedirectURL(\"/home?next=\" + encodedNext);\n        response.sendRedirect(redirectUrl);\n    }\n}\n```"
              },
              "id": "java.security.http-response-splitting-in-servlet-app",
              "name": "java.security.http-response-splitting-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-113"
                ]
              },
              "shortDescription": {
                "text": "HTTP response splitting"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Template engine injection (server-side template injection, SSTI) in Spring MVC/Spring Boot applications\noccurs when user-controlled data is interpreted as template or expression code by the view layer or by Spring Expression Language (SpEL).\nIn typical Spring apps this happens when untrusted input is used as a template body, fragment, or expression,\nor when SpEL is evaluated on data that comes from the request. Successful exploitation can lead to arbitrary\nserver-side code execution, data exfiltration, or full compromise of the application.\n\n```java\n// Vulnerable Spring MVC + Thymeleaf example (SSTI via StringTemplateResolver)\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.*;\nimport org.thymeleaf.context.Context;\nimport org.thymeleaf.spring5.SpringTemplateEngine;\n\n@Controller\n@RequestMapping(\"/messages\")\npublic class MessageController {\n\n    private final SpringTemplateEngine templateEngine;\n\n    public MessageController(SpringTemplateEngine templateEngine) {\n        this.templateEngine = templateEngine;\n    }\n\n    @PostMapping(\"/preview\")\n    @ResponseBody\n    public String preview(@RequestParam(\"template\") String template,\n                          @RequestParam(\"username\") String username) {\n\n        // Attacker fully controls \"template\" request parameter.\n        // With a StringTemplateResolver configured, this is treated as a full Thymeleaf template.\n\n        Context ctx = new Context();\n        ctx.setVariable(\"username\", username);\n\n        // VULNERABLE: user input is parsed and executed as a Thymeleaf/SpringEL template\n        return templateEngine.process(template, ctx);\n    }\n}\n\n// Example of insecure configuration somewhere in @Configuration:\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.thymeleaf.templateresolver.StringTemplateResolver;\nimport org.thymeleaf.templatemode.TemplateMode;\n\n@Configuration\npublic class ThymeleafConfig {\n\n    @Bean\n    public SpringTemplateEngine templateEngine() {\n        SpringTemplateEngine engine = new SpringTemplateEngine();\n        engine.addTemplateResolver(stringTemplateResolver()); // processes raw strings as templates\n        return engine;\n    }\n\n    @Bean\n    public StringTemplateResolver stringTemplateResolver() {\n        StringTemplateResolver resolver = new StringTemplateResolver();\n        resolver.setTemplateMode(TemplateMode.HTML);\n        resolver.setCacheable(false);\n        return resolver;\n    }\n}\n```\n\nIn this example, an attacker can send a payload such as:\n\n```text\n[[${T(java.lang.Runtime).getRuntime().exec('id')}]]\n```\n\nwhich, depending on the exact Spring/Thymeleaf/SpEL version and configuration,\nmay allow arbitrary command or method execution on the server.\n\nTo remediate this issue, never evaluate or compile templates or expressions directly\nfrom untrusted input in Spring. Use only server-controlled template names with standard `ViewResolver`s,\nand treat user data strictly as data passed to the model, not as template instructions.\n\nSafer Spring MVC + Thymeleaf example:\n\n```java\n// Safe-ish version: static templates only, user input is data\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.*;\n\n@Controller\n@RequestMapping(\"/messages\")\npublic class MessageController {\n\n    @PostMapping(\"/preview\")\n    public String preview(@RequestParam(\"username\") String username,\n                          @RequestParam(\"messageText\") String messageText,\n                          Model model) {\n\n        // Use a fixed, server-side template name only\n        String templateName = \"messagePreview\";  // e.g. src/main/resources/templates/messagePreview.html\n\n        // User input is added as plain data to the model\n        model.addAttribute(\"username\", username);\n        model.addAttribute(\"messageText\", messageText);\n\n        // The view resolver will select the template based on this fixed name\n        return templateName;\n    }\n}\n```\n\nKey hardening steps in Spring-based applications:\n\n- Do **not** use `StringTemplateResolver`, `FreeMarkerTemplateUtils.processTemplateIntoString`,\n  or similar APIs on untrusted strings. Only process templates that reside on the server and are under your control.\n- Do **not** evaluate SpEL on user input (e.g., via `SpelExpressionParser.parseExpression(userInput)`\n  or any dynamic expression features wired to request parameters).\n- Always use fixed or strictly whitelisted view names in controllers (`return \"fixedView\"`),\n  never build view names or fragment expressions from request data.\n- Configure template engines in “safe” modes where possible: restrict method invocation,\n  access to arbitrary classes, and reflection in SpEL/OGNL.\n- Escape user-supplied text appropriately in templates (e.g., `th:text` instead of `th:utext` in Thymeleaf)\n  to prevent it from being interpreted as HTML/JavaScript.\n- Keep Spring, Thymeleaf, and other template engine libraries up-to-date to benefit from security fixes and safer defaults.",
                "text": "Template engine injection (server-side template injection, SSTI) in Spring MVC/Spring Boot applications\noccurs when user-controlled data is interpreted as template or expression code by the view layer or by Spring Expression Language (SpEL).\nIn typical Spring apps this happens when untrusted input is used as a template body, fragment, or expression,\nor when SpEL is evaluated on data that comes from the request. Successful exploitation can lead to arbitrary\nserver-side code execution, data exfiltration, or full compromise of the application.\n\n```java\n// Vulnerable Spring MVC + Thymeleaf example (SSTI via StringTemplateResolver)\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.*;\nimport org.thymeleaf.context.Context;\nimport org.thymeleaf.spring5.SpringTemplateEngine;\n\n@Controller\n@RequestMapping(\"/messages\")\npublic class MessageController {\n\n    private final SpringTemplateEngine templateEngine;\n\n    public MessageController(SpringTemplateEngine templateEngine) {\n        this.templateEngine = templateEngine;\n    }\n\n    @PostMapping(\"/preview\")\n    @ResponseBody\n    public String preview(@RequestParam(\"template\") String template,\n                          @RequestParam(\"username\") String username) {\n\n        // Attacker fully controls \"template\" request parameter.\n        // With a StringTemplateResolver configured, this is treated as a full Thymeleaf template.\n\n        Context ctx = new Context();\n        ctx.setVariable(\"username\", username);\n\n        // VULNERABLE: user input is parsed and executed as a Thymeleaf/SpringEL template\n        return templateEngine.process(template, ctx);\n    }\n}\n\n// Example of insecure configuration somewhere in @Configuration:\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.thymeleaf.templateresolver.StringTemplateResolver;\nimport org.thymeleaf.templatemode.TemplateMode;\n\n@Configuration\npublic class ThymeleafConfig {\n\n    @Bean\n    public SpringTemplateEngine templateEngine() {\n        SpringTemplateEngine engine = new SpringTemplateEngine();\n        engine.addTemplateResolver(stringTemplateResolver()); // processes raw strings as templates\n        return engine;\n    }\n\n    @Bean\n    public StringTemplateResolver stringTemplateResolver() {\n        StringTemplateResolver resolver = new StringTemplateResolver();\n        resolver.setTemplateMode(TemplateMode.HTML);\n        resolver.setCacheable(false);\n        return resolver;\n    }\n}\n```\n\nIn this example, an attacker can send a payload such as:\n\n```text\n[[${T(java.lang.Runtime).getRuntime().exec('id')}]]\n```\n\nwhich, depending on the exact Spring/Thymeleaf/SpEL version and configuration,\nmay allow arbitrary command or method execution on the server.\n\nTo remediate this issue, never evaluate or compile templates or expressions directly\nfrom untrusted input in Spring. Use only server-controlled template names with standard `ViewResolver`s,\nand treat user data strictly as data passed to the model, not as template instructions.\n\nSafer Spring MVC + Thymeleaf example:\n\n```java\n// Safe-ish version: static templates only, user input is data\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.*;\n\n@Controller\n@RequestMapping(\"/messages\")\npublic class MessageController {\n\n    @PostMapping(\"/preview\")\n    public String preview(@RequestParam(\"username\") String username,\n                          @RequestParam(\"messageText\") String messageText,\n                          Model model) {\n\n        // Use a fixed, server-side template name only\n        String templateName = \"messagePreview\";  // e.g. src/main/resources/templates/messagePreview.html\n\n        // User input is added as plain data to the model\n        model.addAttribute(\"username\", username);\n        model.addAttribute(\"messageText\", messageText);\n\n        // The view resolver will select the template based on this fixed name\n        return templateName;\n    }\n}\n```\n\nKey hardening steps in Spring-based applications:\n\n- Do **not** use `StringTemplateResolver`, `FreeMarkerTemplateUtils.processTemplateIntoString`,\n  or similar APIs on untrusted strings. Only process templates that reside on the server and are under your control.\n- Do **not** evaluate SpEL on user input (e.g., via `SpelExpressionParser.parseExpression(userInput)`\n  or any dynamic expression features wired to request parameters).\n- Always use fixed or strictly whitelisted view names in controllers (`return \"fixedView\"`),\n  never build view names or fragment expressions from request data.\n- Configure template engines in “safe” modes where possible: restrict method invocation,\n  access to arbitrary classes, and reflection in SpEL/OGNL.\n- Escape user-supplied text appropriately in templates (e.g., `th:text` instead of `th:utext` in Thymeleaf)\n  to prevent it from being interpreted as HTML/JavaScript.\n- Keep Spring, Thymeleaf, and other template engine libraries up-to-date to benefit from security fixes and safer defaults."
              },
              "id": "java.security.ssti-in-spring-app",
              "name": "java.security.ssti-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-94",
                  "CWE-1336"
                ]
              },
              "shortDescription": {
                "text": "Unvalidated user data flows into template engine"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "When untrusted data is passed directly into `org.apache.commons.beanutils.BeanUtilsBean.populate(...)`,\nan attacker can control which bean properties are set and to what values.\nBecause BeanUtils uses reflection and supports nested property paths,\nthis can lead to a *mass assignment* (over-posting) vulnerability:\nusers can modify fields that should be server-controlled (e.g., roles, flags, internal configuration),\nand, in some environments and older BeanUtils versions, even reach sensitive objects via special properties like `class`\n(e.g., `class.classLoader...`) and chain this into more severe attacks.\n\n```java\nimport org.apache.commons.beanutils.BeanUtilsBean;\n\npublic class UserDto {\n    private String username;\n    private String email;\n    private boolean admin;      // should never be settable by the client\n\n    // getters and setters omitted for brevity\n}\n\n// Somewhere in a controller/servlet:\nUserDto user = new UserDto();\n\n// UNSAFE: request parameters are used directly to populate the bean\n// e.g. attacker sends: username=hacker&admin=true\nBeanUtilsBean beanUtils = BeanUtilsBean.getInstance();\nbeanUtils.populate(user, request.getParameterMap());\n\n// user.getAdmin() may now be true, even though that was supposed to be server‑controlled\n```\n\nTo remediate this issue, never pass raw, unvalidated, or unfiltered external input directly to `BeanUtilsBean.populate`. Use one or more of the following strategies:\n\n1. **Whitelist properties before populating** (recommended pattern)\n\n  Only allow a fixed set of safe property names to be set from user input.\n\n  ```java\n  import org.apache.commons.beanutils.BeanUtilsBean;\n\n  private static final Set<String> ALLOWED_PROPERTIES = Set.of(\"username\", \"email\");\n\n  public void bindUser(HttpServletRequest request, UserDto user) throws Exception {\n      Map<String, String[]> rawParams = request.getParameterMap();\n      Map<String, Object> safeParams = new HashMap<>();\n\n      for (String name : ALLOWED_PROPERTIES) {\n          if (rawParams.containsKey(name)) {\n              String[] values = rawParams.get(name);\n              if (values != null && values.length > 0) {\n                  // Add any additional validation/sanitization here\n                  safeParams.put(name, values[0]);\n              }\n          }\n      }\n\n      BeanUtilsBean.getInstance().populate(user, safeParams);\n  }\n  ```\n\n2. **Avoid generic `populate` for security‑sensitive objects**\n\n  For beans holding permissions, roles, internal configuration, or framework/container objects, set fields explicitly:\n\n  ```java\n  UserDto user = new UserDto();\n  user.setUsername(request.getParameter(\"username\"));\n  user.setEmail(request.getParameter(\"email\"));\n  // never bind admin or other sensitive fields from the request\n  ```\n\n3. **Upgrade and configure BeanUtils to suppress dangerous properties**\n\n  If you must use `populate` broadly:\n\n  - Use a recent version of Apache Commons BeanUtils that supports `BeanIntrospector`.\n  - Suppress access to the `class` property (and any others you deem sensitive), so property paths like `class.classLoader` cannot be resolved.\n\n  Conceptually (exact APIs may vary by version):\n\n  ```java\n  import org.apache.commons.beanutils.BeanUtilsBean;\n  import org.apache.commons.beanutils.PropertyUtilsBean;\n  import org.apache.commons.beanutils.BeanIntrospector;\n  import org.apache.commons.beanutils.DefaultBeanIntrospector;\n  import org.apache.commons.beanutils.SuppressPropertiesBeanIntrospector;\n\n  PropertyUtilsBean propertyUtils = new PropertyUtilsBean();\n\n  // Remove default and add a version that suppresses the \"class\" property\n  propertyUtils.removeBeanIntrospector(DefaultBeanIntrospector.INSTANCE);\n  propertyUtils.addBeanIntrospector(DefaultBeanIntrospector.INSTANCE);\n  propertyUtils.addBeanIntrospector(SuppressPropertiesBeanIntrospector.SUPPRESS_CLASS);\n\n  BeanUtilsBean safeBeanUtils = new BeanUtilsBean(null, propertyUtils);\n\n  // Then use safeBeanUtils.populate(...) with already-filtered input\n  ```\n\n  Even with this configuration, **you still need a whitelist** of allowed business properties;\n  suppressing `class` only helps against certain reflection-based exploit chains,\n  not against business-logic abuse (e.g., setting `admin=true`).",
                "text": "When untrusted data is passed directly into `org.apache.commons.beanutils.BeanUtilsBean.populate(...)`,\nan attacker can control which bean properties are set and to what values.\nBecause BeanUtils uses reflection and supports nested property paths,\nthis can lead to a *mass assignment* (over-posting) vulnerability:\nusers can modify fields that should be server-controlled (e.g., roles, flags, internal configuration),\nand, in some environments and older BeanUtils versions, even reach sensitive objects via special properties like `class`\n(e.g., `class.classLoader...`) and chain this into more severe attacks.\n\n```java\nimport org.apache.commons.beanutils.BeanUtilsBean;\n\npublic class UserDto {\n    private String username;\n    private String email;\n    private boolean admin;      // should never be settable by the client\n\n    // getters and setters omitted for brevity\n}\n\n// Somewhere in a controller/servlet:\nUserDto user = new UserDto();\n\n// UNSAFE: request parameters are used directly to populate the bean\n// e.g. attacker sends: username=hacker&admin=true\nBeanUtilsBean beanUtils = BeanUtilsBean.getInstance();\nbeanUtils.populate(user, request.getParameterMap());\n\n// user.getAdmin() may now be true, even though that was supposed to be server‑controlled\n```\n\nTo remediate this issue, never pass raw, unvalidated, or unfiltered external input directly to `BeanUtilsBean.populate`. Use one or more of the following strategies:\n\n1. **Whitelist properties before populating** (recommended pattern)\n\n  Only allow a fixed set of safe property names to be set from user input.\n\n  ```java\n  import org.apache.commons.beanutils.BeanUtilsBean;\n\n  private static final Set<String> ALLOWED_PROPERTIES = Set.of(\"username\", \"email\");\n\n  public void bindUser(HttpServletRequest request, UserDto user) throws Exception {\n      Map<String, String[]> rawParams = request.getParameterMap();\n      Map<String, Object> safeParams = new HashMap<>();\n\n      for (String name : ALLOWED_PROPERTIES) {\n          if (rawParams.containsKey(name)) {\n              String[] values = rawParams.get(name);\n              if (values != null && values.length > 0) {\n                  // Add any additional validation/sanitization here\n                  safeParams.put(name, values[0]);\n              }\n          }\n      }\n\n      BeanUtilsBean.getInstance().populate(user, safeParams);\n  }\n  ```\n\n2. **Avoid generic `populate` for security‑sensitive objects**\n\n  For beans holding permissions, roles, internal configuration, or framework/container objects, set fields explicitly:\n\n  ```java\n  UserDto user = new UserDto();\n  user.setUsername(request.getParameter(\"username\"));\n  user.setEmail(request.getParameter(\"email\"));\n  // never bind admin or other sensitive fields from the request\n  ```\n\n3. **Upgrade and configure BeanUtils to suppress dangerous properties**\n\n  If you must use `populate` broadly:\n\n  - Use a recent version of Apache Commons BeanUtils that supports `BeanIntrospector`.\n  - Suppress access to the `class` property (and any others you deem sensitive), so property paths like `class.classLoader` cannot be resolved.\n\n  Conceptually (exact APIs may vary by version):\n\n  ```java\n  import org.apache.commons.beanutils.BeanUtilsBean;\n  import org.apache.commons.beanutils.PropertyUtilsBean;\n  import org.apache.commons.beanutils.BeanIntrospector;\n  import org.apache.commons.beanutils.DefaultBeanIntrospector;\n  import org.apache.commons.beanutils.SuppressPropertiesBeanIntrospector;\n\n  PropertyUtilsBean propertyUtils = new PropertyUtilsBean();\n\n  // Remove default and add a version that suppresses the \"class\" property\n  propertyUtils.removeBeanIntrospector(DefaultBeanIntrospector.INSTANCE);\n  propertyUtils.addBeanIntrospector(DefaultBeanIntrospector.INSTANCE);\n  propertyUtils.addBeanIntrospector(SuppressPropertiesBeanIntrospector.SUPPRESS_CLASS);\n\n  BeanUtilsBean safeBeanUtils = new BeanUtilsBean(null, propertyUtils);\n\n  // Then use safeBeanUtils.populate(...) with already-filtered input\n  ```\n\n  Even with this configuration, **you still need a whitelist** of allowed business properties;\n  suppressing `class` only helps against certain reflection-based exploit chains,\n  not against business-logic abuse (e.g., setting `admin=true`)."
              },
              "id": "java.security.bean-injection",
              "name": "java.security.bean-injection",
              "properties": {
                "tags": [
                  "CWE-15"
                ]
              },
              "shortDescription": {
                "text": "An attacker can set arbitrary bean properties"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Groovy injection is a code-injection vulnerability that arises when untrusted input\nis used to build and execute Groovy code at runtime\n(for example via GroovyShell.evaluate, Eval.me, or a Groovy ScriptEngine).\nIf an attacker can control any part of the Groovy script string, they may execute\narbitrary Groovy/Java code with the application's privileges, leading to full server compromise,\ndata exfiltration, or lateral movement.\n\nExample (vulnerable):\n```\nString script = request.getParameter(\"script\"); // user-controlled\nGroovyShell shell = new GroovyShell();\nObject result = shell.evaluate(script);         // RCE: attacker controls code\n```\n\nTo remediate this issue, avoid evaluating dynamically constructed Groovy code whenever possible;\nprefer static scripts, fixed command mappings, or other non-code-based configuration.\nIf dynamic evaluation is truly required, strictly validate and constrain input\n(for example, by whitelisting a very limited grammar), avoid concatenating raw user data into scripts,\nand use Groovy sandboxing mechanisms such as SecureASTCustomizer plus a hardened SecurityManager.",
                "text": "Groovy injection is a code-injection vulnerability that arises when untrusted input\nis used to build and execute Groovy code at runtime\n(for example via GroovyShell.evaluate, Eval.me, or a Groovy ScriptEngine).\nIf an attacker can control any part of the Groovy script string, they may execute\narbitrary Groovy/Java code with the application's privileges, leading to full server compromise,\ndata exfiltration, or lateral movement.\n\nExample (vulnerable):\n```\nString script = request.getParameter(\"script\"); // user-controlled\nGroovyShell shell = new GroovyShell();\nObject result = shell.evaluate(script);         // RCE: attacker controls code\n```\n\nTo remediate this issue, avoid evaluating dynamically constructed Groovy code whenever possible;\nprefer static scripts, fixed command mappings, or other non-code-based configuration.\nIf dynamic evaluation is truly required, strictly validate and constrain input\n(for example, by whitelisting a very limited grammar), avoid concatenating raw user data into scripts,\nand use Groovy sandboxing mechanisms such as SecureASTCustomizer plus a hardened SecurityManager."
              },
              "id": "java.security.groovy-injection-in-servlet-app",
              "name": "java.security.groovy-injection-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-94"
                ]
              },
              "shortDescription": {
                "text": "Found Groovy invocation with user-controlled input"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Spring Expression Language (SpEL) injection is an expression-language injection vulnerability in Spring-based applications. It occurs when untrusted input is directly embedded into, or used as, a SpEL expression and then evaluated. Because SpEL can access bean methods, system properties, and other internal objects, a successful injection can allow an attacker to read or modify sensitive data, bypass security checks, or, in severe cases, execute arbitrary code within the application's context.\n\nVulnerable code sample\n\n```java\n@RestController\npublic class SearchController {\n  private final ExpressionParser parser = new SpelExpressionParser();\n  private final SearchService searchService = new SearchService();\n\n  @GetMapping(\"/search\")\n  public String search(@RequestParam(\"expr\") String exprParam) {\n    // VULNERABLE: directly interpreting user input as a SpEL expression\n    EvaluationContext context = new StandardEvaluationContext(searchService);\n    Expression expression = parser.parseExpression(exprParam);\n    Object result = expression.getValue(context);\n    return result == null ? \"\" : result.toString();\n  }\n}\n\nclass SearchService {\n  public String searchByKeyword(String keyword) {\n    // perform a search\n    return \"Results for: \" + keyword;\n  }\n\n  public String internalAdminMethod() {\n      // not meant to be publicly exposed\n      return \"Sensitive admin info\";\n  }\n}\n```\n\nIn this example, an attacker controls `exprParam` (e.g., via `GET /search?expr=...`) and can craft a SpEL expression that calls methods on `SearchService`, reads internal data, or interacts with other beans accessible through the context.\n\nTo remediate this issue, avoid evaluating user input as SpEL code and strictly separate data from expressions. Never build SpEL expressions by concatenating or directly passing untrusted values to `parseExpression`. Instead:\n\n1. **Use fixed expressions and bind user input as data (variables or parameters)**\n     The expression string should be constant and not influenced by user input; only variable values should come from outside.\n\n```java\n@RestController\npublic class SafeSearchController {\n  private final SearchService searchService = new SearchService();\n\n  @GetMapping(\"/search\")\n  public String search(@RequestParam(\"q\") String query) {\n    // SAFE: treat query as plain text input, not as SpEL\n    return searchService.searchByKeyword(query);\n  }\n}\n```\n\nIf you truly need SpEL for dynamic evaluation, keep the expression static and inject untrusted values only as variables:\n\n```java\nExpressionParser parser = new SpelExpressionParser();\nExpression expression = parser.parseExpression(\"searchByKeyword(#q)\");\n\nEvaluationContext context = new StandardEvaluationContext(searchService);\ncontext.setVariable(\"q\", userSuppliedQuery); // value, not code\n\nObject result = expression.getValue(context); // userSuppliedQuery is data only\n```\n\n2. **Use restricted evaluation contexts where possible**\n  - Prefer `SimpleEvaluationContext` for read‑only, data-binding scenarios; it disables many powerful SpEL features (like arbitrary method invocation) that increase risk.\n  - Limit accessible root objects and properties in the evaluation context to the bare minimum required.\n\n3. **Avoid dynamic security annotations based on user input**\n  For annotations like `@PreAuthorize` or `@PostAuthorize`, use constant expressions and avoid string concatenation with user input:\n\n```java\n// Safe usage (constant expression)\n@PreAuthorize(\"hasRole('ADMIN')\")\npublic void adminOnlyAction() { ... }\n\n// Do NOT do this (dynamic SpEL built from user data)\n// @PreAuthorize(\"@permissionService.hasPermission(authentication, '\" + userControlled + \"')\")\n```\n\n4. **Validate and constrain input**\nWhere you must accept structured expressions from users (e.g., filters, search languages), define a custom, limited grammar or DSL and parse it yourself. Do not reuse SpEL as a general-purpose query language for untrusted input.",
                "text": "Spring Expression Language (SpEL) injection is an expression-language injection vulnerability in Spring-based applications. It occurs when untrusted input is directly embedded into, or used as, a SpEL expression and then evaluated. Because SpEL can access bean methods, system properties, and other internal objects, a successful injection can allow an attacker to read or modify sensitive data, bypass security checks, or, in severe cases, execute arbitrary code within the application's context.\n\nVulnerable code sample\n\n```java\n@RestController\npublic class SearchController {\n  private final ExpressionParser parser = new SpelExpressionParser();\n  private final SearchService searchService = new SearchService();\n\n  @GetMapping(\"/search\")\n  public String search(@RequestParam(\"expr\") String exprParam) {\n    // VULNERABLE: directly interpreting user input as a SpEL expression\n    EvaluationContext context = new StandardEvaluationContext(searchService);\n    Expression expression = parser.parseExpression(exprParam);\n    Object result = expression.getValue(context);\n    return result == null ? \"\" : result.toString();\n  }\n}\n\nclass SearchService {\n  public String searchByKeyword(String keyword) {\n    // perform a search\n    return \"Results for: \" + keyword;\n  }\n\n  public String internalAdminMethod() {\n      // not meant to be publicly exposed\n      return \"Sensitive admin info\";\n  }\n}\n```\n\nIn this example, an attacker controls `exprParam` (e.g., via `GET /search?expr=...`) and can craft a SpEL expression that calls methods on `SearchService`, reads internal data, or interacts with other beans accessible through the context.\n\nTo remediate this issue, avoid evaluating user input as SpEL code and strictly separate data from expressions. Never build SpEL expressions by concatenating or directly passing untrusted values to `parseExpression`. Instead:\n\n1. **Use fixed expressions and bind user input as data (variables or parameters)**\n     The expression string should be constant and not influenced by user input; only variable values should come from outside.\n\n```java\n@RestController\npublic class SafeSearchController {\n  private final SearchService searchService = new SearchService();\n\n  @GetMapping(\"/search\")\n  public String search(@RequestParam(\"q\") String query) {\n    // SAFE: treat query as plain text input, not as SpEL\n    return searchService.searchByKeyword(query);\n  }\n}\n```\n\nIf you truly need SpEL for dynamic evaluation, keep the expression static and inject untrusted values only as variables:\n\n```java\nExpressionParser parser = new SpelExpressionParser();\nExpression expression = parser.parseExpression(\"searchByKeyword(#q)\");\n\nEvaluationContext context = new StandardEvaluationContext(searchService);\ncontext.setVariable(\"q\", userSuppliedQuery); // value, not code\n\nObject result = expression.getValue(context); // userSuppliedQuery is data only\n```\n\n2. **Use restricted evaluation contexts where possible**\n  - Prefer `SimpleEvaluationContext` for read‑only, data-binding scenarios; it disables many powerful SpEL features (like arbitrary method invocation) that increase risk.\n  - Limit accessible root objects and properties in the evaluation context to the bare minimum required.\n\n3. **Avoid dynamic security annotations based on user input**\n  For annotations like `@PreAuthorize` or `@PostAuthorize`, use constant expressions and avoid string concatenation with user input:\n\n```java\n// Safe usage (constant expression)\n@PreAuthorize(\"hasRole('ADMIN')\")\npublic void adminOnlyAction() { ... }\n\n// Do NOT do this (dynamic SpEL built from user data)\n// @PreAuthorize(\"@permissionService.hasPermission(authentication, '\" + userControlled + \"')\")\n```\n\n4. **Validate and constrain input**\nWhere you must accept structured expressions from users (e.g., filters, search languages), define a custom, limited grammar or DSL and parse it yourself. Do not reuse SpEL as a general-purpose query language for untrusted input."
              },
              "id": "java.security.spring-el-injection",
              "name": "java.security.spring-el-injection",
              "properties": {
                "tags": [
                  "CWE-917"
                ]
              },
              "shortDescription": {
                "text": "Potential expression language injection"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "The `HttpRequest.getRequestDispatcher()`'s `include` and `forward` methods will return\nany file that is resolvable within the web application context. This includes the `web.xml`\nfile, any compiled classes, `jsp` files, and additional JAR or WAR libraries that are\naccessible.\n\nNever pass user-supplied input directly to any of these methods. Use a lookup table or\nhardcode\nwhich views or paths the user should be directed to. Another option is to use a simple HTTP\nredirect by returning an empty response body with a 301 status code and a `Location` redirect\nheader. In Java servlets, this can be done by using the `response.sendRedirect(...)` method.\n\nExample using a redirect instead of a `RequestDispatcher`:\n```\n// Create a look up table or pull from a data source\nHashMap<String, String> lookupTable = new HashMap<>();\nlookupTable.put(\"key1\", \"/Resource1\");\nlookupTable.put(\"key2\", \"/Resource2\");\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Look up resource to redirect to from the user input\nString redirectValue = lookupTable.getOrDefault(userInput, \"/Resource1\");\n// Redirect the user\nresponse.sendRedirect(redirectValue);\n```",
                "text": "The `HttpRequest.getRequestDispatcher()`'s `include` and `forward` methods will return\nany file that is resolvable within the web application context. This includes the `web.xml`\nfile, any compiled classes, `jsp` files, and additional JAR or WAR libraries that are\naccessible.\n\nNever pass user-supplied input directly to any of these methods. Use a lookup table or\nhardcode\nwhich views or paths the user should be directed to. Another option is to use a simple HTTP\nredirect by returning an empty response body with a 301 status code and a `Location` redirect\nheader. In Java servlets, this can be done by using the `response.sendRedirect(...)` method.\n\nExample using a redirect instead of a `RequestDispatcher`:\n```\n// Create a look up table or pull from a data source\nHashMap<String, String> lookupTable = new HashMap<>();\nlookupTable.put(\"key1\", \"/Resource1\");\nlookupTable.put(\"key2\", \"/Resource2\");\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Look up resource to redirect to from the user input\nString redirectValue = lookupTable.getOrDefault(userInput, \"/Resource1\");\n// Redirect the user\nresponse.sendRedirect(redirectValue);\n```"
              },
              "id": "java.security.file-disclosure-request-dispatcher",
              "name": "java.security.file-disclosure-request-dispatcher",
              "properties": {
                "tags": [
                  "CWE-552"
                ]
              },
              "shortDescription": {
                "text": "Files or directories accessible to external parties"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "XPath Injection in Java occurs when untrusted data is concatenated into an XPath expression\nthat is then evaluated on an XML document. An attacker can inject XPath syntax\n(such as additional predicates or logical operators) to change the query's meaning,\nbypass authentication or authorization checks, or access sensitive data.\nIt is conceptually similar to SQL injection, but targets XML data sources and\nXPath processors instead of relational databases.\n\n```java\n// Vulnerable code sample\nimport javax.xml.xpath.*;\nimport org.w3c.dom.Document;\n\npublic class AuthService {\n\n    private final XPath xPath;\n    private final Document usersDoc; // XML like: <users><user><username>...</username>...\n\n    public AuthService(Document usersDoc) {\n        this.usersDoc = usersDoc;\n        this.xPath = XPathFactory.newInstance().newXPath();\n    }\n\n    public boolean authenticate(String username, String password) throws Exception {\n        // VULNERABLE: user input is concatenated directly into the XPath expression\n        String expression = \"/users/user[username='\" + username + \"' and password='\" + password + \"']\";\n\n        // If attacker sets username to: ' or '1'='1\n        // the expression becomes: /users/user[username='' or '1'='1' and password='...']\n        // which can match any user and bypass auth.\n        XPathExpression compiled = xPath.compile(expression);\n        Object result = compiled.evaluate(usersDoc, XPathConstants.NODE);\n        return result != null;\n    }\n}\n```\n\nTo remediate this issue, avoid building XPath expressions via string concatenation with untrusted input,\nvalidate and constrain any user input used in queries, and prefer designs where comparisons are done in code\nrather than in dynamically built XPath. For example, instead of injecting untrusted data into the query,\nselect candidate nodes with a static XPath and compare values in Java:\n\n```java\n// Safer approach: do not concatenate untrusted input into the XPath\nimport javax.xml.xpath.*;\nimport org.w3c.dom.*;\n\npublic class SafeAuthService {\n\n    private final XPath xPath;\n    private final Document usersDoc;\n\n    public SafeAuthService(Document usersDoc) {\n        this.usersDoc = usersDoc;\n        this.xPath = XPathFactory.newInstance().newXPath();\n    }\n\n    public boolean authenticate(String username, String password) throws Exception {\n        // 1. Validate input (length, charset, etc.) — example:\n        if (username == null || password == null\n                || username.length() > 50 || password.length() > 100\n                || !username.matches(\"[A-Za-z0-9._-]+\")) {\n            return false;\n        }\n\n        // 2. Use a static XPath to get all user nodes (no user input inside XPath)\n        XPathExpression compiled = xPath.compile(\"/users/user\");\n        NodeList users = (NodeList) compiled.evaluate(usersDoc, XPathConstants.NODESET);\n\n        // 3. Compare in code instead of in XPath\n        for (int i = 0; i < users.getLength(); i++) {\n            Element user = (Element) users.item(i);\n            String u = user.getElementsByTagName(\"username\").item(0).getTextContent();\n            String p = user.getElementsByTagName(\"password\").item(0).getTextContent();\n            if (username.equals(u) && password.equals(p)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\nIn addition, prefer using standard, hardened authentication and data-storage mechanisms\n(e.g., databases with parameterized queries, hashed passwords) instead of custom XML-based auth;\nif XPath must be used, restrict allowed characters, escape or encode any user-controlled values\nbefore inserting them into expressions, and keep XPath expressions as static as possible.",
                "text": "XPath Injection in Java occurs when untrusted data is concatenated into an XPath expression\nthat is then evaluated on an XML document. An attacker can inject XPath syntax\n(such as additional predicates or logical operators) to change the query's meaning,\nbypass authentication or authorization checks, or access sensitive data.\nIt is conceptually similar to SQL injection, but targets XML data sources and\nXPath processors instead of relational databases.\n\n```java\n// Vulnerable code sample\nimport javax.xml.xpath.*;\nimport org.w3c.dom.Document;\n\npublic class AuthService {\n\n    private final XPath xPath;\n    private final Document usersDoc; // XML like: <users><user><username>...</username>...\n\n    public AuthService(Document usersDoc) {\n        this.usersDoc = usersDoc;\n        this.xPath = XPathFactory.newInstance().newXPath();\n    }\n\n    public boolean authenticate(String username, String password) throws Exception {\n        // VULNERABLE: user input is concatenated directly into the XPath expression\n        String expression = \"/users/user[username='\" + username + \"' and password='\" + password + \"']\";\n\n        // If attacker sets username to: ' or '1'='1\n        // the expression becomes: /users/user[username='' or '1'='1' and password='...']\n        // which can match any user and bypass auth.\n        XPathExpression compiled = xPath.compile(expression);\n        Object result = compiled.evaluate(usersDoc, XPathConstants.NODE);\n        return result != null;\n    }\n}\n```\n\nTo remediate this issue, avoid building XPath expressions via string concatenation with untrusted input,\nvalidate and constrain any user input used in queries, and prefer designs where comparisons are done in code\nrather than in dynamically built XPath. For example, instead of injecting untrusted data into the query,\nselect candidate nodes with a static XPath and compare values in Java:\n\n```java\n// Safer approach: do not concatenate untrusted input into the XPath\nimport javax.xml.xpath.*;\nimport org.w3c.dom.*;\n\npublic class SafeAuthService {\n\n    private final XPath xPath;\n    private final Document usersDoc;\n\n    public SafeAuthService(Document usersDoc) {\n        this.usersDoc = usersDoc;\n        this.xPath = XPathFactory.newInstance().newXPath();\n    }\n\n    public boolean authenticate(String username, String password) throws Exception {\n        // 1. Validate input (length, charset, etc.) — example:\n        if (username == null || password == null\n                || username.length() > 50 || password.length() > 100\n                || !username.matches(\"[A-Za-z0-9._-]+\")) {\n            return false;\n        }\n\n        // 2. Use a static XPath to get all user nodes (no user input inside XPath)\n        XPathExpression compiled = xPath.compile(\"/users/user\");\n        NodeList users = (NodeList) compiled.evaluate(usersDoc, XPathConstants.NODESET);\n\n        // 3. Compare in code instead of in XPath\n        for (int i = 0; i < users.getLength(); i++) {\n            Element user = (Element) users.item(i);\n            String u = user.getElementsByTagName(\"username\").item(0).getTextContent();\n            String p = user.getElementsByTagName(\"password\").item(0).getTextContent();\n            if (username.equals(u) && password.equals(p)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\nIn addition, prefer using standard, hardened authentication and data-storage mechanisms\n(e.g., databases with parameterized queries, hashed passwords) instead of custom XML-based auth;\nif XPath must be used, restrict allowed characters, escape or encode any user-controlled values\nbefore inserting them into expressions, and keep XPath expressions as static as possible."
              },
              "id": "java.security.xpath-injection-in-servlet-app",
              "name": "java.security.xpath-injection-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-643"
                ]
              },
              "shortDescription": {
                "text": "XPath Injection"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Unvalidated redirects (also called “open redirects”) occur when a web application accepts\nuntrusted input that specifies a URL to redirect to, and then performs the redirect without\nsufficient validation. Attackers can exploit this to send users to malicious websites while making\nthe link appear to come from a trusted domain (phishing),\nbypass intermediate access checks, or chain the redirect into broader attacks.\n\nVulnerable code sample\n\n```java\n// A simple Java Servlet example\nprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n        throws ServletException, IOException {\n\n    // \"url\" parameter is taken directly from user input\n    String url = request.getParameter(\"url\");\n\n    if (url != null && !url.isEmpty()) {\n        // VULNERABLE: redirects to any URL provided by the user\n        response.sendRedirect(url);\n    } else {\n        response.sendRedirect(\"home.jsp\");\n    }\n}\n```\n\nTo remediate this issue, avoid redirecting to arbitrary URLs from user-controlled input.\nPrefer server-side mapping of identifiers to known-safe destinations, or strictly validate and\nrestrict redirect targets (e.g., to internal paths or a small whitelist of external domains).\n\nMore secure approach using an internal whitelist of paths:\n\n```java\n// Example of safer redirect handling\nprivate static final Set<String> ALLOWED_TARGETS = Set.of(\n    \"home\",\n    \"profile\",\n    \"orders\"\n);\n\nprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n        throws ServletException, IOException {\n\n    String target = request.getParameter(\"target\");  // e.g., \"home\", \"profile\"\n    String redirectPath = \"/home.jsp\";              // default safe page\n\n    if (target != null && ALLOWED_TARGETS.contains(target)) {\n        switch (target) {\n            case \"home\":\n                redirectPath = \"/home.jsp\";\n                break;\n            case \"profile\":\n                redirectPath = \"/user/profile.jsp\";\n                break;\n            case \"orders\":\n                redirectPath = \"/orders/list.jsp\";\n                break;\n        }\n    }\n\n    // Only redirect to application-internal paths\n    response.sendRedirect(request.getContextPath() + redirectPath);\n}\n```\n\nIf you must support external redirects, validate strictly that the destination is on an approved list of domains and reject all others:\n\n```java\nprivate static final Set<String> ALLOWED_DOMAINS = Set.of(\"example.com\", \"trusted-partner.com\");\n\nprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n        throws ServletException, IOException {\n\n    String url = request.getParameter(\"url\");\n    if (url == null) {\n        response.sendRedirect(request.getContextPath() + \"/home.jsp\");\n        return;\n    }\n\n    try {\n        URI uri = new URI(url);\n\n        // Require an explicit host and approved scheme\n        String host = uri.getHost();\n        String scheme = uri.getScheme();\n\n        if (host != null\n                && ( \"http\".equalsIgnoreCase(scheme) || \"https\".equalsIgnoreCase(scheme) )\n                && ALLOWED_DOMAINS.contains(host.toLowerCase())) {\n\n            response.sendRedirect(uri.toString());\n        } else {\n            // Fallback to a safe internal page\n            response.sendRedirect(request.getContextPath() + \"/home.jsp\");\n        }\n    } catch (URISyntaxException e) {\n        // Invalid URL; redirect to safe internal page\n        response.sendRedirect(request.getContextPath() + \"/home.jsp\");\n    }\n}\n```",
                "text": "Unvalidated redirects (also called “open redirects”) occur when a web application accepts\nuntrusted input that specifies a URL to redirect to, and then performs the redirect without\nsufficient validation. Attackers can exploit this to send users to malicious websites while making\nthe link appear to come from a trusted domain (phishing),\nbypass intermediate access checks, or chain the redirect into broader attacks.\n\nVulnerable code sample\n\n```java\n// A simple Java Servlet example\nprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n        throws ServletException, IOException {\n\n    // \"url\" parameter is taken directly from user input\n    String url = request.getParameter(\"url\");\n\n    if (url != null && !url.isEmpty()) {\n        // VULNERABLE: redirects to any URL provided by the user\n        response.sendRedirect(url);\n    } else {\n        response.sendRedirect(\"home.jsp\");\n    }\n}\n```\n\nTo remediate this issue, avoid redirecting to arbitrary URLs from user-controlled input.\nPrefer server-side mapping of identifiers to known-safe destinations, or strictly validate and\nrestrict redirect targets (e.g., to internal paths or a small whitelist of external domains).\n\nMore secure approach using an internal whitelist of paths:\n\n```java\n// Example of safer redirect handling\nprivate static final Set<String> ALLOWED_TARGETS = Set.of(\n    \"home\",\n    \"profile\",\n    \"orders\"\n);\n\nprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n        throws ServletException, IOException {\n\n    String target = request.getParameter(\"target\");  // e.g., \"home\", \"profile\"\n    String redirectPath = \"/home.jsp\";              // default safe page\n\n    if (target != null && ALLOWED_TARGETS.contains(target)) {\n        switch (target) {\n            case \"home\":\n                redirectPath = \"/home.jsp\";\n                break;\n            case \"profile\":\n                redirectPath = \"/user/profile.jsp\";\n                break;\n            case \"orders\":\n                redirectPath = \"/orders/list.jsp\";\n                break;\n        }\n    }\n\n    // Only redirect to application-internal paths\n    response.sendRedirect(request.getContextPath() + redirectPath);\n}\n```\n\nIf you must support external redirects, validate strictly that the destination is on an approved list of domains and reject all others:\n\n```java\nprivate static final Set<String> ALLOWED_DOMAINS = Set.of(\"example.com\", \"trusted-partner.com\");\n\nprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n        throws ServletException, IOException {\n\n    String url = request.getParameter(\"url\");\n    if (url == null) {\n        response.sendRedirect(request.getContextPath() + \"/home.jsp\");\n        return;\n    }\n\n    try {\n        URI uri = new URI(url);\n\n        // Require an explicit host and approved scheme\n        String host = uri.getHost();\n        String scheme = uri.getScheme();\n\n        if (host != null\n                && ( \"http\".equalsIgnoreCase(scheme) || \"https\".equalsIgnoreCase(scheme) )\n                && ALLOWED_DOMAINS.contains(host.toLowerCase())) {\n\n            response.sendRedirect(uri.toString());\n        } else {\n            // Fallback to a safe internal page\n            response.sendRedirect(request.getContextPath() + \"/home.jsp\");\n        }\n    } catch (URISyntaxException e) {\n        // Invalid URL; redirect to safe internal page\n        response.sendRedirect(request.getContextPath() + \"/home.jsp\");\n    }\n}\n```"
              },
              "id": "java.security.unvalidated-redirect-in-servlet-app",
              "name": "java.security.unvalidated-redirect-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-601"
                ]
              },
              "shortDescription": {
                "text": "Application redirects to user-manipulated URL which can be malicious"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "XML External Entity (XXE) in Spring applications occurs when the application parses XML\nthat comes (directly or indirectly) from users, and the XML parser is allowed to process\nexternal entities or DTDs. An attacker can supply a crafted XML document that causes the parser to:\n\n- Read local files (e.g., configuration, secrets).\n- Make arbitrary HTTP requests from the server (SSRF).\n- Potentially trigger denial of service.\n\nThis often happens in Spring MVC / Spring Boot apps when developers manually use low-level XML APIs\n(e.g., `DocumentBuilderFactory`, `SAXParserFactory`) with unsafe defaults, or when XML marshalling libraries are not hardened.\n\n```java\n// Vulnerable code sample (Spring Boot / Spring MVC)\n\n@RestController\n@RequestMapping(\"/api\")\npublic class XmlController {\n\n    @PostMapping(value = \"/process-xml\", consumes = MediaType.APPLICATION_XML_VALUE)\n    public String processXml(@RequestBody String xml) throws Exception {\n        // Insecure: default configuration may allow DTDs and external entities\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = dbf.newDocumentBuilder();\n\n        Document doc = builder.parse(new InputSource(new StringReader(xml)));\n\n        // Application logic using parsed XML...\n        String value = doc.getElementsByTagName(\"name\").item(0).getTextContent();\n        return \"Received: \" + value;\n    }\n}\n```\n\nTo remediate this issue, configure all XML parsers in the Spring application to reject\nDTDs and external entities, or avoid XML entirely if possible (use JSON, for example).\nWith JAXP/DOM, harden `DocumentBuilderFactory` as follows:\n\n```java\n// Safe XML parsing configuration\n\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n// Completely disallow DOCTYPE declarations (strong protection against XXE)\ndbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\n// Disable external entities\ndbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\ndbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\ndbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n// Extra hardening\ndbf.setXIncludeAware(false);\ndbf.setExpandEntityReferences(false);\n\nDocumentBuilder builder = dbf.newDocumentBuilder();\nDocument doc = builder.parse(new InputSource(new StringReader(xml)));\n```\n\nAdditional Spring-specific guidelines:\n\n- Prefer higher-level, framework-managed XML handling where Spring already applies\n  secure defaults, and verify the underlying parser's XXE settings (JAXP, JAXB, Jackson XML, etc.).\n- Disable DTDs and external entities in any other XML-related factories\n  (`SAXParserFactory`, `XMLInputFactory`, etc.) used in beans or libraries within the Spring context.\n- If your code uses third-party XML libraries, consult their documentation for XXE-safe configuration\n  and ensure those beans are created/configured securely in your Spring configuration.",
                "text": "XML External Entity (XXE) in Spring applications occurs when the application parses XML\nthat comes (directly or indirectly) from users, and the XML parser is allowed to process\nexternal entities or DTDs. An attacker can supply a crafted XML document that causes the parser to:\n\n- Read local files (e.g., configuration, secrets).\n- Make arbitrary HTTP requests from the server (SSRF).\n- Potentially trigger denial of service.\n\nThis often happens in Spring MVC / Spring Boot apps when developers manually use low-level XML APIs\n(e.g., `DocumentBuilderFactory`, `SAXParserFactory`) with unsafe defaults, or when XML marshalling libraries are not hardened.\n\n```java\n// Vulnerable code sample (Spring Boot / Spring MVC)\n\n@RestController\n@RequestMapping(\"/api\")\npublic class XmlController {\n\n    @PostMapping(value = \"/process-xml\", consumes = MediaType.APPLICATION_XML_VALUE)\n    public String processXml(@RequestBody String xml) throws Exception {\n        // Insecure: default configuration may allow DTDs and external entities\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = dbf.newDocumentBuilder();\n\n        Document doc = builder.parse(new InputSource(new StringReader(xml)));\n\n        // Application logic using parsed XML...\n        String value = doc.getElementsByTagName(\"name\").item(0).getTextContent();\n        return \"Received: \" + value;\n    }\n}\n```\n\nTo remediate this issue, configure all XML parsers in the Spring application to reject\nDTDs and external entities, or avoid XML entirely if possible (use JSON, for example).\nWith JAXP/DOM, harden `DocumentBuilderFactory` as follows:\n\n```java\n// Safe XML parsing configuration\n\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n// Completely disallow DOCTYPE declarations (strong protection against XXE)\ndbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\n// Disable external entities\ndbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\ndbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\ndbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n// Extra hardening\ndbf.setXIncludeAware(false);\ndbf.setExpandEntityReferences(false);\n\nDocumentBuilder builder = dbf.newDocumentBuilder();\nDocument doc = builder.parse(new InputSource(new StringReader(xml)));\n```\n\nAdditional Spring-specific guidelines:\n\n- Prefer higher-level, framework-managed XML handling where Spring already applies\n  secure defaults, and verify the underlying parser's XXE settings (JAXP, JAXB, Jackson XML, etc.).\n- Disable DTDs and external entities in any other XML-related factories\n  (`SAXParserFactory`, `XMLInputFactory`, etc.) used in beans or libraries within the Spring context.\n- If your code uses third-party XML libraries, consult their documentation for XXE-safe configuration\n  and ensure those beans are created/configured securely in your Spring configuration."
              },
              "id": "java.security.xxe-in-spring-app",
              "name": "java.security.xxe-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-611"
                ]
              },
              "shortDescription": {
                "text": "XML parsing of an untrusted input"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "XML External Entity (XXE) is a vulnerability that occurs when an application parses untrusted\nXML with a parser that allows external entities or DTDs. An attacker can craft XML that causes\nthe server to read local files, make HTTP requests to internal systems (SSRF), or consume excessive resources (DoS).\nIn Java servlet applications, this often happens when request bodies are parsed as XML with default, insecure parser settings.\n\n```java\n// Vulnerable servlet code: parses XML from the request with default settings\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport org.w3c.dom.Document;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport java.io.IOException;\n\npublic class XmlUploadServlet extends HttpServlet {\n\n    @Override\n    protected void doPost(HttpServletRequest request,\n                          HttpServletResponse response)\n            throws ServletException, IOException {\n\n        try {\n            // DEFAULT configuration — vulnerable to XXE\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n\n            // Attacker-controlled XML from the request body\n            Document doc = builder.parse(request.getInputStream());\n\n            // Process the XML document...\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }\n}\n```\n\nTo remediate this issue, configure XML parsers to disallow DTDs and external entities,\nenable secure processing features, and upgrade to a recent JDK/XML library version that\nsupports these controls. Where possible, avoid XML or use data formats/parsers that do not support external entities.\n\n```java\n// Safe servlet code: XXE protections enabled\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport org.w3c.dom.Document;\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport java.io.IOException;\n\npublic class SafeXmlUploadServlet extends HttpServlet {\n\n    @Override\n    protected void doPost(HttpServletRequest request,\n                          HttpServletResponse response)\n            throws ServletException, IOException {\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\n            // Enable secure processing\n            factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n\n            // Completely disallow DOCTYPE declarations\n            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\n            // Disable external entities\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n            // Additional hardening\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n\n            // For JDKs that support it: block all external access\n            try {\n                factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n                factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n            } catch (IllegalArgumentException ignored) {\n                // Attributes not supported in older JDKs; safe to ignore\n            }\n\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(request.getInputStream());\n\n            // Safely process the XML document...\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }\n}\n```\n\nAdditional recommended steps:\n\n- Validate and constrain inputs (e.g., size limits on request bodies).\n- Prefer libraries or APIs that do not support DTD/entities when possible.\n- Turn off XML features you do not need (schema validation, XInclude, etc.).\n- Consider switching to JSON if XML's advanced features are unnecessary.",
                "text": "XML External Entity (XXE) is a vulnerability that occurs when an application parses untrusted\nXML with a parser that allows external entities or DTDs. An attacker can craft XML that causes\nthe server to read local files, make HTTP requests to internal systems (SSRF), or consume excessive resources (DoS).\nIn Java servlet applications, this often happens when request bodies are parsed as XML with default, insecure parser settings.\n\n```java\n// Vulnerable servlet code: parses XML from the request with default settings\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport org.w3c.dom.Document;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport java.io.IOException;\n\npublic class XmlUploadServlet extends HttpServlet {\n\n    @Override\n    protected void doPost(HttpServletRequest request,\n                          HttpServletResponse response)\n            throws ServletException, IOException {\n\n        try {\n            // DEFAULT configuration — vulnerable to XXE\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n\n            // Attacker-controlled XML from the request body\n            Document doc = builder.parse(request.getInputStream());\n\n            // Process the XML document...\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }\n}\n```\n\nTo remediate this issue, configure XML parsers to disallow DTDs and external entities,\nenable secure processing features, and upgrade to a recent JDK/XML library version that\nsupports these controls. Where possible, avoid XML or use data formats/parsers that do not support external entities.\n\n```java\n// Safe servlet code: XXE protections enabled\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport org.w3c.dom.Document;\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport java.io.IOException;\n\npublic class SafeXmlUploadServlet extends HttpServlet {\n\n    @Override\n    protected void doPost(HttpServletRequest request,\n                          HttpServletResponse response)\n            throws ServletException, IOException {\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\n            // Enable secure processing\n            factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n\n            // Completely disallow DOCTYPE declarations\n            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\n            // Disable external entities\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n            // Additional hardening\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n\n            // For JDKs that support it: block all external access\n            try {\n                factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n                factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n            } catch (IllegalArgumentException ignored) {\n                // Attributes not supported in older JDKs; safe to ignore\n            }\n\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(request.getInputStream());\n\n            // Safely process the XML document...\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }\n}\n```\n\nAdditional recommended steps:\n\n- Validate and constrain inputs (e.g., size limits on request bodies).\n- Prefer libraries or APIs that do not support DTD/entities when possible.\n- Turn off XML features you do not need (schema validation, XInclude, etc.).\n- Consider switching to JSON if XML's advanced features are unnecessary."
              },
              "id": "java.security.xxe-in-servlet-app",
              "name": "java.security.xxe-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-611"
                ]
              },
              "shortDescription": {
                "text": "XML parsing of an untrusted input"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "MongoDB `$where` injection in Java is a form of NoSQL injection that occurs when\nuntrusted user input is concatenated into a `$where` clause (server-side JavaScript)\nand sent to MongoDB. Because `$where` executes JavaScript on the database server,\nan attacker who controls any part of that expression can inject arbitrary JavaScript,\nbypass authentication/authorization checks, read or modify data, or cause denial of service.\n\nVulnerable code sample\n\n```java\nimport com.mongodb.DB;\nimport com.mongodb.DBCollection;\nimport com.mongodb.DBCursor;\nimport com.mongodb.DBObject;\nimport com.mongodb.BasicDBObject;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class LoginService {\n\n    private final DB db;\n\n    public LoginService(DB db) {\n        this.db = db;\n    }\n\n    public boolean login(HttpServletRequest request) {\n        String username = request.getParameter(\"username\");  // untrusted input\n        String password = request.getParameter(\"password\");  // untrusted input\n\n        DBCollection users = db.getCollection(\"users\");\n\n        // VULNERABLE: user input is concatenated into a $where JavaScript expression\n        String whereClause =\n                \"this.username == '\" + username + \"' && this.password == '\" + password + \"'\";\n\n        DBObject query = new BasicDBObject(\"$where\", whereClause);\n\n        DBCursor cursor = users.find(query);\n        return cursor.hasNext();\n    }\n}\n```\n\nIn this example, an attacker can craft `username` or `password` so that the resulting\n`whereClause` becomes malicious JavaScript executed by MongoDB.\n\nTo remediate this issue, avoid using `$where` with string concatenation altogether and always treat\nuser input as data, not code. Use standard field-based queries and parameterization instead of embedding\nuser input into JavaScript expressions. Where possible, disable server‑side JavaScript in MongoDB\nand apply normal secure coding practices (validation, least privilege, hashed passwords, etc.).\n\nA safer version of the same logic using field-based queries:\n\n```java\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.model.Filters;\nimport org.bson.Document;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class SafeLoginService {\n\n    private final MongoDatabase db;\n\n    public SafeLoginService(MongoDatabase db) {\n        this.db = db;\n    }\n\n    public boolean login(HttpServletRequest request) {\n        String username = request.getParameter(\"username\");  // still untrusted\n        String password = request.getParameter(\"password\");  // still untrusted\n\n        MongoCollection<Document> users = db.getCollection(\"users\");\n\n        // SAFE: user input is bound as values, not executed as code\n        Document user = users.find(\n                Filters.and(\n                        Filters.eq(\"username\", username),\n                        Filters.eq(\"password\", password) // in reality, compare password hashes\n                )\n        ).first();\n\n        return user != null;\n    }\n}\n```\n\nKey remediation steps:\n- Do not use `$where` with dynamic strings built from user input.\n- Use field-based queries (`Filters.eq`, `Filters.and`, `new Document(\"field\", value)`, etc.).\n- If you must use `$where`, never concatenate raw user input; use strict whitelisting and controlled templates (but prefer avoiding `$where` completely).\n- Configure MongoDB to restrict or disable server-side JavaScript where feasible.",
                "text": "MongoDB `$where` injection in Java is a form of NoSQL injection that occurs when\nuntrusted user input is concatenated into a `$where` clause (server-side JavaScript)\nand sent to MongoDB. Because `$where` executes JavaScript on the database server,\nan attacker who controls any part of that expression can inject arbitrary JavaScript,\nbypass authentication/authorization checks, read or modify data, or cause denial of service.\n\nVulnerable code sample\n\n```java\nimport com.mongodb.DB;\nimport com.mongodb.DBCollection;\nimport com.mongodb.DBCursor;\nimport com.mongodb.DBObject;\nimport com.mongodb.BasicDBObject;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class LoginService {\n\n    private final DB db;\n\n    public LoginService(DB db) {\n        this.db = db;\n    }\n\n    public boolean login(HttpServletRequest request) {\n        String username = request.getParameter(\"username\");  // untrusted input\n        String password = request.getParameter(\"password\");  // untrusted input\n\n        DBCollection users = db.getCollection(\"users\");\n\n        // VULNERABLE: user input is concatenated into a $where JavaScript expression\n        String whereClause =\n                \"this.username == '\" + username + \"' && this.password == '\" + password + \"'\";\n\n        DBObject query = new BasicDBObject(\"$where\", whereClause);\n\n        DBCursor cursor = users.find(query);\n        return cursor.hasNext();\n    }\n}\n```\n\nIn this example, an attacker can craft `username` or `password` so that the resulting\n`whereClause` becomes malicious JavaScript executed by MongoDB.\n\nTo remediate this issue, avoid using `$where` with string concatenation altogether and always treat\nuser input as data, not code. Use standard field-based queries and parameterization instead of embedding\nuser input into JavaScript expressions. Where possible, disable server‑side JavaScript in MongoDB\nand apply normal secure coding practices (validation, least privilege, hashed passwords, etc.).\n\nA safer version of the same logic using field-based queries:\n\n```java\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.model.Filters;\nimport org.bson.Document;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class SafeLoginService {\n\n    private final MongoDatabase db;\n\n    public SafeLoginService(MongoDatabase db) {\n        this.db = db;\n    }\n\n    public boolean login(HttpServletRequest request) {\n        String username = request.getParameter(\"username\");  // still untrusted\n        String password = request.getParameter(\"password\");  // still untrusted\n\n        MongoCollection<Document> users = db.getCollection(\"users\");\n\n        // SAFE: user input is bound as values, not executed as code\n        Document user = users.find(\n                Filters.and(\n                        Filters.eq(\"username\", username),\n                        Filters.eq(\"password\", password) // in reality, compare password hashes\n                )\n        ).first();\n\n        return user != null;\n    }\n}\n```\n\nKey remediation steps:\n- Do not use `$where` with dynamic strings built from user input.\n- Use field-based queries (`Filters.eq`, `Filters.and`, `new Document(\"field\", value)`, etc.).\n- If you must use `$where`, never concatenate raw user input; use strict whitelisting and controlled templates (but prefer avoiding `$where` completely).\n- Configure MongoDB to restrict or disable server-side JavaScript where feasible."
              },
              "id": "java.security.mongodb-injection-in-spring-app",
              "name": "java.security.mongodb-injection-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-943"
                ]
              },
              "shortDescription": {
                "text": "MongoDB query injection"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Found object deserialization using ObjectInputStream with user-controlled input. Deserialization of entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences.",
                "text": "Found object deserialization using ObjectInputStream with user-controlled input. Deserialization of entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences."
              },
              "id": "java.security.unsafe-object-mapper-in-spring-app",
              "name": "java.security.unsafe-object-mapper-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-502"
                ]
              },
              "shortDescription": {
                "text": "Deserialization of untrusted data with ObjectMapper"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Path traversal (also known as directory traversal) is a vulnerability that occurs when user-controlled input is used to construct filesystem paths without proper validation. An attacker can manipulate the path (for example, using sequences like `../`) to break out of intended directories and access or modify files elsewhere on the server, such as configuration files, source code, or sensitive data.\n\n**Vulnerable code sample**\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.*;\nimport java.io.*;\n\npublic class DownloadServlet extends HttpServlet {\n\n    private static final String BASE_DIR = \"/var/www/uploads/\";\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        // User provides file name via query parameter ?file=...\n        String fileName = request.getParameter(\"file\");\n\n        // VULNERABLE: directly concatenating user input into a file path\n        File file = new File(BASE_DIR + fileName);\n\n        if (!file.exists()) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n\n        try (FileInputStream fis = new FileInputStream(file);\n            OutputStream out = response.getOutputStream()) {\n\n            response.setContentType(\"application/octet-stream\");\n            response.setHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + file.getName() + \"\\\"\");\n\n            byte[] buffer = new byte[4096];\n            int read;\n            while ((read = fis.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n            }\n        }\n    }\n}\n```\n\nAn attacker could supply a value like `../../../../etc/passwd` as `file`, potentially reading sensitive files outside `/var/www/uploads/`.\n\nTo remediate this issue, validate and constrain all file path input and ensure that the resolved path stays within an expected directory. Prefer allowlists (known-safe file names or IDs) and use canonical/normalized paths for checks.\n\n**Safer approach using `java.nio.file.Path` and canonical checks:**\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.nio.file.*;\n\npublic class SafeDownloadServlet extends HttpServlet {\n\n    private static final Path BASE_DIR = Paths.get(\"/var/www/uploads\").toAbsolutePath().normalize();\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String fileName = request.getParameter(\"file\");\n        if (fileName == null || fileName.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing file parameter\");\n            return;\n        }\n\n        // Optional: allowlist or pattern validation\n        // e.g., only letters, numbers, dot, dash, underscore\n        if (!fileName.matches(\"[A-Za-z0-9._-]+\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid file name\");\n            return;\n        }\n\n        // Resolve and normalize the target path\n        Path target = BASE_DIR.resolve(fileName).normalize();\n\n        // Ensure the final path is still under the base directory\n        if (!target.startsWith(BASE_DIR)) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access denied\");\n            return;\n        }\n\n        if (!Files.exists(target) || !Files.isRegularFile(target)) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n\n        response.setContentType(\"application/octet-stream\");\n        response.setHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + target.getFileName().toString() + \"\\\"\");\n\n        try (InputStream in = Files.newInputStream(target);\n            OutputStream out = response.getOutputStream()) {\n\n            byte[] buffer = new byte[4096];\n            int read;\n            while ((read = in.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n            }\n        }\n    }\n}\n```\n\nKey remediation steps:\n- Treat all path components from users as untrusted.\n- Use allowlists for file names or map user inputs to internal IDs instead of raw paths where possible.\n- Normalize/canonicalize paths (`normalize()`, `toRealPath()`) and verify they stay within an intended base directory.\n- Avoid echoing raw paths or detailed errors back to the client.",
                "text": "Path traversal (also known as directory traversal) is a vulnerability that occurs when user-controlled input is used to construct filesystem paths without proper validation. An attacker can manipulate the path (for example, using sequences like `../`) to break out of intended directories and access or modify files elsewhere on the server, such as configuration files, source code, or sensitive data.\n\n**Vulnerable code sample**\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.*;\nimport java.io.*;\n\npublic class DownloadServlet extends HttpServlet {\n\n    private static final String BASE_DIR = \"/var/www/uploads/\";\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        // User provides file name via query parameter ?file=...\n        String fileName = request.getParameter(\"file\");\n\n        // VULNERABLE: directly concatenating user input into a file path\n        File file = new File(BASE_DIR + fileName);\n\n        if (!file.exists()) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n\n        try (FileInputStream fis = new FileInputStream(file);\n            OutputStream out = response.getOutputStream()) {\n\n            response.setContentType(\"application/octet-stream\");\n            response.setHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + file.getName() + \"\\\"\");\n\n            byte[] buffer = new byte[4096];\n            int read;\n            while ((read = fis.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n            }\n        }\n    }\n}\n```\n\nAn attacker could supply a value like `../../../../etc/passwd` as `file`, potentially reading sensitive files outside `/var/www/uploads/`.\n\nTo remediate this issue, validate and constrain all file path input and ensure that the resolved path stays within an expected directory. Prefer allowlists (known-safe file names or IDs) and use canonical/normalized paths for checks.\n\n**Safer approach using `java.nio.file.Path` and canonical checks:**\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.nio.file.*;\n\npublic class SafeDownloadServlet extends HttpServlet {\n\n    private static final Path BASE_DIR = Paths.get(\"/var/www/uploads\").toAbsolutePath().normalize();\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String fileName = request.getParameter(\"file\");\n        if (fileName == null || fileName.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing file parameter\");\n            return;\n        }\n\n        // Optional: allowlist or pattern validation\n        // e.g., only letters, numbers, dot, dash, underscore\n        if (!fileName.matches(\"[A-Za-z0-9._-]+\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid file name\");\n            return;\n        }\n\n        // Resolve and normalize the target path\n        Path target = BASE_DIR.resolve(fileName).normalize();\n\n        // Ensure the final path is still under the base directory\n        if (!target.startsWith(BASE_DIR)) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access denied\");\n            return;\n        }\n\n        if (!Files.exists(target) || !Files.isRegularFile(target)) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n\n        response.setContentType(\"application/octet-stream\");\n        response.setHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + target.getFileName().toString() + \"\\\"\");\n\n        try (InputStream in = Files.newInputStream(target);\n            OutputStream out = response.getOutputStream()) {\n\n            byte[] buffer = new byte[4096];\n            int read;\n            while ((read = in.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n            }\n        }\n    }\n}\n```\n\nKey remediation steps:\n- Treat all path components from users as untrusted.\n- Use allowlists for file names or map user inputs to internal IDs instead of raw paths where possible.\n- Normalize/canonicalize paths (`normalize()`, `toRealPath()`) and verify they stay within an intended base directory.\n- Avoid echoing raw paths or detailed errors back to the client."
              },
              "id": "java.security.path-traversal-in-servlet-app",
              "name": "java.security.path-traversal-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-22"
                ]
              },
              "shortDescription": {
                "text": "Interaction with file system via untrusted path, potential path traversal"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Cross-Site Scripting (XSS) is a class of vulnerabilities that allows an attacker to inject malicious\nclient-side code (usually JavaScript) into web pages viewed by other users.\nIn Spring MVC applications, this typically occurs when untrusted input (e.g., request parameters, form fields, query strings)\nis added to the model and then rendered in a view (JSP, Thymeleaf, etc.) without proper output encoding.\nIf the view engine renders user data as raw HTML, an attacker can inject scripts that execute in the victim's browser\nin the context of your application (stealing cookies, hijacking sessions, modifying content, etc.).\n\n**Vulnerable code sample**\n\nController:\n\n```java\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n@Controller\npublic class GreetingController {\n\n    @GetMapping(\"/greet\")\n    public String greet(@RequestParam(required = false) String name, Model model) {\n        model.addAttribute(\"name\", name);\n        return \"greet\"; // resolve to greet.html (Thymeleaf) or greet.jsp\n    }\n}\n```\n\nThymeleaf view (`greet.html`) — **vulnerable**:\n\n```html\n<!DOCTYPE html>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <title>Greeting</title>\n</head>\n<body>\n    <!-- VULNERABLE: th:utext renders unescaped HTML/JS from user input -->\n    <h1 th:utext=\"'Hello, ' + ${name} + '!'\"></h1>\n</body>\n</html>\n```\n\nIf a user accesses `/greet?name=<script>alert('XSS')</script>`, the script will be inserted into the page and executed by the browser.\n\n(A similar issue occurs with JSP if you render `${param.name}` or `${name}` directly in the page without escaping,\nor if you use scriptlets and concatenate request parameters into HTML.)\n\n\nTo remediate this issue, always treat data from the client as untrusted and ensure **context-appropriate output encoding**\nin your views. In Spring MVC:\n\n- Use the **escaping features of your view technology**:\n  - Thymeleaf: `th:text` or `[[${...}]]` (escaped) instead of `th:utext` or `[(${...})]` (unescaped).\n  - JSP: `<c:out value=\"${name}\"/>` instead of printing `${name}` directly or using scriptlets.\n- Avoid disabling default escaping in template engines unless absolutely necessary, and never do so for raw user input.\n- Combine this with server-side validation that constrains inputs to expected formats.\n\n**Safer Thymeleaf example**\n\nController (same):\n\n```java\n@Controller\npublic class GreetingController {\n\n    @GetMapping(\"/greet\")\n    public String greet(@RequestParam(required = false, defaultValue = \"\") String name, Model model) {\n        model.addAttribute(\"name\", name);\n        return \"greet\";\n    }\n}\n```\n\nThymeleaf view (`greet.html`) — **safe**:\n\n```html\n<!DOCTYPE html>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <title>Greeting</title>\n</head>\n<body>\n    <!-- SAFE: th:text escapes HTML special characters -->\n    <h1 th:text=\"'Hello, ' + ${name} + '!'\"></h1>\n</body>\n</html>\n```\n\nHere, any `<`, `>`, `\"`, `'`, and `&` characters in `name` are encoded as HTML entities (`&lt;`, `&gt;`, etc.),\nso injected script tags are rendered as text instead of executed.\n\nAdditional recommended measures in Spring applications:\n- Use Spring Security and configure HTTP headers like `Content-Security-Policy` (CSP) to limit the impact of any XSS that might slip through.\n- Avoid building HTML/JavaScript via string concatenation in controllers; let the template engine handle rendering and escaping.\n- For JSON APIs (`@RestController`), ensure the front-end framework properly escapes data when inserting it into the DOM.",
                "text": "Cross-Site Scripting (XSS) is a class of vulnerabilities that allows an attacker to inject malicious\nclient-side code (usually JavaScript) into web pages viewed by other users.\nIn Spring MVC applications, this typically occurs when untrusted input (e.g., request parameters, form fields, query strings)\nis added to the model and then rendered in a view (JSP, Thymeleaf, etc.) without proper output encoding.\nIf the view engine renders user data as raw HTML, an attacker can inject scripts that execute in the victim's browser\nin the context of your application (stealing cookies, hijacking sessions, modifying content, etc.).\n\n**Vulnerable code sample**\n\nController:\n\n```java\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n@Controller\npublic class GreetingController {\n\n    @GetMapping(\"/greet\")\n    public String greet(@RequestParam(required = false) String name, Model model) {\n        model.addAttribute(\"name\", name);\n        return \"greet\"; // resolve to greet.html (Thymeleaf) or greet.jsp\n    }\n}\n```\n\nThymeleaf view (`greet.html`) — **vulnerable**:\n\n```html\n<!DOCTYPE html>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <title>Greeting</title>\n</head>\n<body>\n    <!-- VULNERABLE: th:utext renders unescaped HTML/JS from user input -->\n    <h1 th:utext=\"'Hello, ' + ${name} + '!'\"></h1>\n</body>\n</html>\n```\n\nIf a user accesses `/greet?name=<script>alert('XSS')</script>`, the script will be inserted into the page and executed by the browser.\n\n(A similar issue occurs with JSP if you render `${param.name}` or `${name}` directly in the page without escaping,\nor if you use scriptlets and concatenate request parameters into HTML.)\n\n\nTo remediate this issue, always treat data from the client as untrusted and ensure **context-appropriate output encoding**\nin your views. In Spring MVC:\n\n- Use the **escaping features of your view technology**:\n  - Thymeleaf: `th:text` or `[[${...}]]` (escaped) instead of `th:utext` or `[(${...})]` (unescaped).\n  - JSP: `<c:out value=\"${name}\"/>` instead of printing `${name}` directly or using scriptlets.\n- Avoid disabling default escaping in template engines unless absolutely necessary, and never do so for raw user input.\n- Combine this with server-side validation that constrains inputs to expected formats.\n\n**Safer Thymeleaf example**\n\nController (same):\n\n```java\n@Controller\npublic class GreetingController {\n\n    @GetMapping(\"/greet\")\n    public String greet(@RequestParam(required = false, defaultValue = \"\") String name, Model model) {\n        model.addAttribute(\"name\", name);\n        return \"greet\";\n    }\n}\n```\n\nThymeleaf view (`greet.html`) — **safe**:\n\n```html\n<!DOCTYPE html>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <title>Greeting</title>\n</head>\n<body>\n    <!-- SAFE: th:text escapes HTML special characters -->\n    <h1 th:text=\"'Hello, ' + ${name} + '!'\"></h1>\n</body>\n</html>\n```\n\nHere, any `<`, `>`, `\"`, `'`, and `&` characters in `name` are encoded as HTML entities (`&lt;`, `&gt;`, etc.),\nso injected script tags are rendered as text instead of executed.\n\nAdditional recommended measures in Spring applications:\n- Use Spring Security and configure HTTP headers like `Content-Security-Policy` (CSP) to limit the impact of any XSS that might slip through.\n- Avoid building HTML/JavaScript via string concatenation in controllers; let the template engine handle rendering and escaping.\n- For JSON APIs (`@RestController`), ensure the front-end framework properly escapes data when inserting it into the DOM."
              },
              "id": "java.security.xss-in-spring-app",
              "name": "java.security.xss-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-79"
                ]
              },
              "shortDescription": {
                "text": "Potential cross-site scripting (XSS)"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Found Jackson deserialization with user-controlled input.",
                "text": "Found Jackson deserialization with user-controlled input."
              },
              "id": "java.security.unsafe-jackson-deserialization-in-servlet-app",
              "name": "java.security.unsafe-jackson-deserialization-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-502"
                ]
              },
              "shortDescription": {
                "text": "Unsafe Jackson deserialization with user-controlled input"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Operating System (OS) Command Injection is a vulnerability that occurs when an application\nconstructs and executes system-level commands using untrusted input. In Java, this commonly\nappears when user-supplied data is concatenated into a command string passed to `Runtime.exec()`\nor `ProcessBuilder`. If that input is not strictly validated or constrained, an attacker can\nappend additional commands or alter command arguments, leading to arbitrary command execution\nwith the privileges of the running Java process. This can result in data exfiltration,\nserver compromise, lateral movement, or complete takeover of the underlying host.\n\nVulnerable code sample\n```java\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class PingServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        String host = request.getParameter(\"host\"); // e.g. user-controlled input\n\n        // VULNERABLE: direct concatenation of untrusted input into OS command\n        String command = \"ping -c 4 \" + host;\n\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            // ... read output, return to user, etc.\n        } catch (Exception e) {\n            // handle exception\n        }\n    }\n}\n```\n\nIf an attacker sends `host=example.com; rm -rf /` (or platform-specific equivalents),\nand the environment uses a shell to interpret `command`, the injected `rm -rf /` may be executed.\n\nTo remediate this issue, avoid constructing shell commands with untrusted input and prefer safer APIs\nthat do not rely on a shell. If you must invoke external programs, pass arguments as discrete parameters\n(not a single concatenated string), and strictly validate or whitelist allowed values.\n\nSafer approach 1 — use Java APIs instead of shell commands:\n```java\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.net.InetAddress;\n\npublic class PingServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        String host = request.getParameter(\"host\");\n\n        try {\n            // Basic validation (example: allow only hostnames/IPs with limited charset)\n            if (!host.matches(\"^[a-zA-Z0-9._-]{1,255}$\")) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid host\");\n                return;\n            }\n\n            InetAddress address = InetAddress.getByName(host);\n            boolean reachable = address.isReachable(5000); // 5 seconds timeout\n\n            response.getWriter().println(\"Reachable: \" + reachable);\n        } catch (Exception e) {\n            // handle exception\n        }\n    }\n}\n```\n\nSafer approach 2 — if you must call an OS command, avoid a shell and separate arguments:\n```java\nString host = request.getParameter(\"host\");\n\n// Strict validation / whitelisting\nif (!host.matches(\"^[a-zA-Z0-9._-]{1,255}$\")) {\n    response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid host\");\n    return;\n}\n\n// Use ProcessBuilder with arguments array; do not invoke /bin/sh or cmd.exe\nProcessBuilder pb = new ProcessBuilder(\"ping\", \"-c\", \"4\", host);\npb.redirectErrorStream(true);\nProcess process = pb.start();\n// ... safely read output\n```\n\nKey remediation steps:\n- Do not concatenate untrusted input into command strings.\n- Prefer native Java libraries over external commands where possible.\n- If external commands are unavoidable:\n  - Avoid invoking a shell (`/bin/sh -c`, `cmd.exe /c`).\n  - Pass arguments as a list (`new ProcessBuilder(\"cmd\", \"arg1\", \"arg2\")`), not a single string.\n  - Apply strict input validation and whitelisting (fixed set of allowed commands/arguments when feasible).\n- Run the Java process with the least privileges necessary and apply OS-level hardening to reduce impact.",
                "text": "Operating System (OS) Command Injection is a vulnerability that occurs when an application\nconstructs and executes system-level commands using untrusted input. In Java, this commonly\nappears when user-supplied data is concatenated into a command string passed to `Runtime.exec()`\nor `ProcessBuilder`. If that input is not strictly validated or constrained, an attacker can\nappend additional commands or alter command arguments, leading to arbitrary command execution\nwith the privileges of the running Java process. This can result in data exfiltration,\nserver compromise, lateral movement, or complete takeover of the underlying host.\n\nVulnerable code sample\n```java\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class PingServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        String host = request.getParameter(\"host\"); // e.g. user-controlled input\n\n        // VULNERABLE: direct concatenation of untrusted input into OS command\n        String command = \"ping -c 4 \" + host;\n\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            // ... read output, return to user, etc.\n        } catch (Exception e) {\n            // handle exception\n        }\n    }\n}\n```\n\nIf an attacker sends `host=example.com; rm -rf /` (or platform-specific equivalents),\nand the environment uses a shell to interpret `command`, the injected `rm -rf /` may be executed.\n\nTo remediate this issue, avoid constructing shell commands with untrusted input and prefer safer APIs\nthat do not rely on a shell. If you must invoke external programs, pass arguments as discrete parameters\n(not a single concatenated string), and strictly validate or whitelist allowed values.\n\nSafer approach 1 — use Java APIs instead of shell commands:\n```java\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.net.InetAddress;\n\npublic class PingServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        String host = request.getParameter(\"host\");\n\n        try {\n            // Basic validation (example: allow only hostnames/IPs with limited charset)\n            if (!host.matches(\"^[a-zA-Z0-9._-]{1,255}$\")) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid host\");\n                return;\n            }\n\n            InetAddress address = InetAddress.getByName(host);\n            boolean reachable = address.isReachable(5000); // 5 seconds timeout\n\n            response.getWriter().println(\"Reachable: \" + reachable);\n        } catch (Exception e) {\n            // handle exception\n        }\n    }\n}\n```\n\nSafer approach 2 — if you must call an OS command, avoid a shell and separate arguments:\n```java\nString host = request.getParameter(\"host\");\n\n// Strict validation / whitelisting\nif (!host.matches(\"^[a-zA-Z0-9._-]{1,255}$\")) {\n    response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid host\");\n    return;\n}\n\n// Use ProcessBuilder with arguments array; do not invoke /bin/sh or cmd.exe\nProcessBuilder pb = new ProcessBuilder(\"ping\", \"-c\", \"4\", host);\npb.redirectErrorStream(true);\nProcess process = pb.start();\n// ... safely read output\n```\n\nKey remediation steps:\n- Do not concatenate untrusted input into command strings.\n- Prefer native Java libraries over external commands where possible.\n- If external commands are unavoidable:\n  - Avoid invoking a shell (`/bin/sh -c`, `cmd.exe /c`).\n  - Pass arguments as a list (`new ProcessBuilder(\"cmd\", \"arg1\", \"arg2\")`), not a single string.\n  - Apply strict input validation and whitelisting (fixed set of allowed commands/arguments when feasible).\n- Run the Java process with the least privileges necessary and apply OS-level hardening to reduce impact."
              },
              "id": "java.security.os-command-injection-in-servlet-app",
              "name": "java.security.os-command-injection-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-78"
                ]
              },
              "shortDescription": {
                "text": "Command line depends on a user provided value"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "SQL injection is a vulnerability where untrusted input is concatenated into SQL queries and sent to the database without\nproper validation or parameterization. In Java servlet applications, this typically happens when request parameters\nare directly embedded into SQL strings. An attacker can craft input that changes the structure of the SQL query,\nallowing unauthorized data access, data modification, or even full compromise of the database.\n\nVulnerable code sample\n\n```java\npublic class UserProfileServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String userId = request.getParameter(\"userId\"); // untrusted input\n\n        try (Connection conn = dataSource.getConnection();\n            Statement stmt = conn.createStatement()) {\n\n            // Vulnerable: userId is concatenated directly into the SQL string\n            String sql = \"SELECT * FROM users WHERE id = '\" + userId + \"'\";\n            ResultSet rs = stmt.executeQuery(sql);\n\n            // ... process result set ...\n\n        } catch (SQLException e) {\n            throw new ServletException(e);\n        }\n    }\n}\n```\n\nTo remediate this issue, always use parameterized queries (e.g., `PreparedStatement`)\ninstead of string concatenation, and validate input where appropriate.\nThis prevents user input from being interpreted as SQL code.\n\nSafe code sample using `PreparedStatement`:\n\n```java\npublic class UserProfileServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String userId = request.getParameter(\"userId\");\n\n        // Example of simple input validation (optional but recommended)\n        if (userId == null || !userId.matches(\"\\\\d+\")) { // expect numeric ID\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid user id.\");\n            return;\n        }\n\n        try (Connection conn = dataSource.getConnection();\n            PreparedStatement ps = conn.prepareStatement(\n                    \"SELECT * FROM users WHERE id = ?\")) {\n\n            ps.setInt(1, Integer.parseInt(userId));  // bind parameter\n            ResultSet rs = ps.executeQuery();\n\n            // ... process result set safely ...\n\n        } catch (SQLException e) {\n            throw new ServletException(e);\n        }\n    }\n}\n```\n\nAdditional best practices include using least-privilege database accounts, avoiding constructing dynamic SQL where possible,\nand centralizing database access logic to enforce safe patterns throughout the application.",
                "text": "SQL injection is a vulnerability where untrusted input is concatenated into SQL queries and sent to the database without\nproper validation or parameterization. In Java servlet applications, this typically happens when request parameters\nare directly embedded into SQL strings. An attacker can craft input that changes the structure of the SQL query,\nallowing unauthorized data access, data modification, or even full compromise of the database.\n\nVulnerable code sample\n\n```java\npublic class UserProfileServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String userId = request.getParameter(\"userId\"); // untrusted input\n\n        try (Connection conn = dataSource.getConnection();\n            Statement stmt = conn.createStatement()) {\n\n            // Vulnerable: userId is concatenated directly into the SQL string\n            String sql = \"SELECT * FROM users WHERE id = '\" + userId + \"'\";\n            ResultSet rs = stmt.executeQuery(sql);\n\n            // ... process result set ...\n\n        } catch (SQLException e) {\n            throw new ServletException(e);\n        }\n    }\n}\n```\n\nTo remediate this issue, always use parameterized queries (e.g., `PreparedStatement`)\ninstead of string concatenation, and validate input where appropriate.\nThis prevents user input from being interpreted as SQL code.\n\nSafe code sample using `PreparedStatement`:\n\n```java\npublic class UserProfileServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String userId = request.getParameter(\"userId\");\n\n        // Example of simple input validation (optional but recommended)\n        if (userId == null || !userId.matches(\"\\\\d+\")) { // expect numeric ID\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid user id.\");\n            return;\n        }\n\n        try (Connection conn = dataSource.getConnection();\n            PreparedStatement ps = conn.prepareStatement(\n                    \"SELECT * FROM users WHERE id = ?\")) {\n\n            ps.setInt(1, Integer.parseInt(userId));  // bind parameter\n            ResultSet rs = ps.executeQuery();\n\n            // ... process result set safely ...\n\n        } catch (SQLException e) {\n            throw new ServletException(e);\n        }\n    }\n}\n```\n\nAdditional best practices include using least-privilege database accounts, avoiding constructing dynamic SQL where possible,\nand centralizing database access logic to enforce safe patterns throughout the application."
              },
              "id": "java.security.sql-injection-in-servlet-app",
              "name": "java.security.sql-injection-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-89"
                ]
              },
              "shortDescription": {
                "text": "Potential SQL injection"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Found Jackson deserialization with user-controlled input.",
                "text": "Found Jackson deserialization with user-controlled input."
              },
              "id": "java.security.unsafe-jackson-deserialization-in-spring-app",
              "name": "java.security.unsafe-jackson-deserialization-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-502"
                ]
              },
              "shortDescription": {
                "text": "Unsafe Jackson deserialization with user-controlled input"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Unsafe reflection in Java occurs when user-controlled input is used to determine which classes or methods\nare loaded or invoked via the reflection API (e.g., `Class.forName`, `Method.invoke`).\nIf an attacker can influence the class name passed to `Class.forName`, they may be able to load arbitrary\napplication or library classes, trigger dangerous static initializers or constructors,\nor chain into further vulnerabilities, leading to code execution, privilege escalation, or denial of service.\n\nVulnerable code sample\n\n```java\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class DynamicLoaderServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        // User-controlled data from request parameter\n        String className = request.getParameter(\"className\");\n\n        try {\n            // UNSAFE: user input directly controls Class.forName\n            Class<?> clazz = Class.forName(className);\n            Object instance = clazz.getDeclaredConstructor().newInstance();\n\n            // Do something with the instance...\n            response.getWriter().println(\"Loaded class: \" + clazz.getName());\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }\n}\n```\n\nTo remediate this issue, never pass raw user input directly into `Class.forName` (or other reflection APIs). Instead:\n\n- Use an allowlist (fixed set) of permitted classes or a mapping from user input to known-safe classes.\n- Validate input strictly (e.g., only allow known identifiers, not full class names from the client).\n- Prefer explicit logic (e.g., `if/else`, `switch`, enums, or a configuration map) over arbitrary reflective loading.\n\nSafe example using a whitelist mapping:\n\n```java\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SafeDynamicLoaderServlet extends HttpServlet {\n\n    // Allowlist of logical names to actual classes\n    private static final Map<String, Class<?>> ALLOWED_CLASSES = new HashMap<>();\n    static {\n        ALLOWED_CLASSES.put(\"basicReport\", com.example.reports.BasicReport.class);\n        ALLOWED_CLASSES.put(\"summaryReport\", com.example.reports.SummaryReport.class);\n        // Add more allowed classes here\n    }\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String type = request.getParameter(\"reportType\");\n\n        Class<?> clazz = ALLOWED_CLASSES.get(type);\n        if (clazz == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid report type\");\n            return;\n        }\n\n        try {\n            Object instance = clazz.getDeclaredConstructor().newInstance();\n            // Safe: only instances of known, vetted classes are created\n            response.getWriter().println(\"Generated report of type: \" + type);\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }\n}\n```",
                "text": "Unsafe reflection in Java occurs when user-controlled input is used to determine which classes or methods\nare loaded or invoked via the reflection API (e.g., `Class.forName`, `Method.invoke`).\nIf an attacker can influence the class name passed to `Class.forName`, they may be able to load arbitrary\napplication or library classes, trigger dangerous static initializers or constructors,\nor chain into further vulnerabilities, leading to code execution, privilege escalation, or denial of service.\n\nVulnerable code sample\n\n```java\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.IOException;\n\npublic class DynamicLoaderServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        // User-controlled data from request parameter\n        String className = request.getParameter(\"className\");\n\n        try {\n            // UNSAFE: user input directly controls Class.forName\n            Class<?> clazz = Class.forName(className);\n            Object instance = clazz.getDeclaredConstructor().newInstance();\n\n            // Do something with the instance...\n            response.getWriter().println(\"Loaded class: \" + clazz.getName());\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }\n}\n```\n\nTo remediate this issue, never pass raw user input directly into `Class.forName` (or other reflection APIs). Instead:\n\n- Use an allowlist (fixed set) of permitted classes or a mapping from user input to known-safe classes.\n- Validate input strictly (e.g., only allow known identifiers, not full class names from the client).\n- Prefer explicit logic (e.g., `if/else`, `switch`, enums, or a configuration map) over arbitrary reflective loading.\n\nSafe example using a whitelist mapping:\n\n```java\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SafeDynamicLoaderServlet extends HttpServlet {\n\n    // Allowlist of logical names to actual classes\n    private static final Map<String, Class<?>> ALLOWED_CLASSES = new HashMap<>();\n    static {\n        ALLOWED_CLASSES.put(\"basicReport\", com.example.reports.BasicReport.class);\n        ALLOWED_CLASSES.put(\"summaryReport\", com.example.reports.SummaryReport.class);\n        // Add more allowed classes here\n    }\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String type = request.getParameter(\"reportType\");\n\n        Class<?> clazz = ALLOWED_CLASSES.get(type);\n        if (clazz == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid report type\");\n            return;\n        }\n\n        try {\n            Object instance = clazz.getDeclaredConstructor().newInstance();\n            // Safe: only instances of known, vetted classes are created\n            response.getWriter().println(\"Generated report of type: \" + type);\n        } catch (Exception e) {\n            throw new ServletException(e);\n        }\n    }\n}\n```"
              },
              "id": "java.security.unsafe-reflection-in-spring-app",
              "name": "java.security.unsafe-reflection-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-470"
                ]
              },
              "shortDescription": {
                "text": "Allowing user input to control which classes or methods are used can let attackers manipulate program flow"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Expression Language (EL) injection in Java occurs when user-controlled input is evaluated as an expression by\nan EL engine (e.g., Java Expression Language, JSP/JSF EL, Spring Expression Language / SpEL).\nBecause EL can access object properties, call methods, and sometimes invoke static methods,\nan attacker who controls the expression string can often read sensitive data, manipulate the server-side state,\nor even achieve remote code execution (RCE), depending on the framework and configuration.\n\n```java\n// Vulnerable code sample (Java EE / Jakarta EE style EL)\n\nimport jakarta.el.ELContext;\nimport jakarta.el.ExpressionFactory;\nimport jakarta.el.ValueExpression;\nimport jakarta.servlet.http.*;\n\npublic class EvalServlet extends HttpServlet {\n    private final ExpressionFactory factory = ExpressionFactory.newInstance();\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException {\n        String expr = request.getParameter(\"expr\"); // e.g. attacker-controlled: \"${''.getClass().forName('java.lang.Runtime').getRuntime().exec('id')}\"\n        ELContext elContext = getServletContext().getELContext(); // simplified for example\n\n        // VULNERABLE: evaluating raw user input as an EL expression\n        ValueExpression ve = factory.createValueExpression(elContext, expr, Object.class);\n        Object result = ve.getValue(elContext);\n\n        response.getWriter().println(\"Result: \" + result);\n    }\n}\n```\n\nIn this example, the attacker fully controls `expr`. Depending on what the EL implementation allows,\nthey may be able to call arbitrary methods, access beans, read environment variables, or execute system commands.\n\nTo remediate this issue, never evaluate user input as an EL/SpEL expression.\nTreat user input strictly as data, not as code or templates. Use static (developer-defined)\nexpressions and bind user values as variables/parameters, or avoid EL evaluation entirely for untrusted strings.\n\nSafer approach (expression is static, user data is just a variable):\n\n```java\nimport jakarta.el.ELContext;\nimport jakarta.el.ExpressionFactory;\nimport jakarta.el.ValueExpression;\nimport jakarta.servlet.http.*;\n\npublic class SafeServlet extends HttpServlet {\n    private final ExpressionFactory factory = ExpressionFactory.newInstance();\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException {\n        String userName = request.getParameter(\"name\"); // untrusted, but only used as data\n        if (userName == null) userName = \"\";\n\n        ELContext elContext = getServletContext().getELContext();\n        elContext.getELResolver().setValue(elContext, null, \"name\", userName);\n\n        // SAFE: expression is hard-coded, attacker cannot change what gets evaluated\n        String template = \"Hello ${name}\";\n        ValueExpression ve = factory.createValueExpression(elContext, template, String.class);\n        String output = (String) ve.getValue(elContext);\n\n        // Optionally also HTML-encode before output to prevent XSS\n        response.getWriter().println(output);\n    }\n}\n```\n\nAdditional remediation steps:\n\n- **Do not** pass raw user input to `ExpressionFactory.createValueExpression`,\n  `SpelExpressionParser.parseExpression`, or similar “evaluate expression” APIs.\n- If you must support some kind of user-defined mini-language, implement a **strict parser/whitelist**\n  that only allows safe operations (e.g., numeric operations only, no method calls, no property access).\n- In Spring, prefer `SimpleEvaluationContext` or a custom `EvaluationContext` with:\n  - No bean resolver or only a whitelisted bean resolver.\n  - Restricted method/property resolvers (disallow reflection, system-level classes, `Runtime`, etc.).\n- Keep frameworks and EL libraries up to date; many EL engines have configuration options or security\n  patches that disable or restrict dangerous features.",
                "text": "Expression Language (EL) injection in Java occurs when user-controlled input is evaluated as an expression by\nan EL engine (e.g., Java Expression Language, JSP/JSF EL, Spring Expression Language / SpEL).\nBecause EL can access object properties, call methods, and sometimes invoke static methods,\nan attacker who controls the expression string can often read sensitive data, manipulate the server-side state,\nor even achieve remote code execution (RCE), depending on the framework and configuration.\n\n```java\n// Vulnerable code sample (Java EE / Jakarta EE style EL)\n\nimport jakarta.el.ELContext;\nimport jakarta.el.ExpressionFactory;\nimport jakarta.el.ValueExpression;\nimport jakarta.servlet.http.*;\n\npublic class EvalServlet extends HttpServlet {\n    private final ExpressionFactory factory = ExpressionFactory.newInstance();\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException {\n        String expr = request.getParameter(\"expr\"); // e.g. attacker-controlled: \"${''.getClass().forName('java.lang.Runtime').getRuntime().exec('id')}\"\n        ELContext elContext = getServletContext().getELContext(); // simplified for example\n\n        // VULNERABLE: evaluating raw user input as an EL expression\n        ValueExpression ve = factory.createValueExpression(elContext, expr, Object.class);\n        Object result = ve.getValue(elContext);\n\n        response.getWriter().println(\"Result: \" + result);\n    }\n}\n```\n\nIn this example, the attacker fully controls `expr`. Depending on what the EL implementation allows,\nthey may be able to call arbitrary methods, access beans, read environment variables, or execute system commands.\n\nTo remediate this issue, never evaluate user input as an EL/SpEL expression.\nTreat user input strictly as data, not as code or templates. Use static (developer-defined)\nexpressions and bind user values as variables/parameters, or avoid EL evaluation entirely for untrusted strings.\n\nSafer approach (expression is static, user data is just a variable):\n\n```java\nimport jakarta.el.ELContext;\nimport jakarta.el.ExpressionFactory;\nimport jakarta.el.ValueExpression;\nimport jakarta.servlet.http.*;\n\npublic class SafeServlet extends HttpServlet {\n    private final ExpressionFactory factory = ExpressionFactory.newInstance();\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException {\n        String userName = request.getParameter(\"name\"); // untrusted, but only used as data\n        if (userName == null) userName = \"\";\n\n        ELContext elContext = getServletContext().getELContext();\n        elContext.getELResolver().setValue(elContext, null, \"name\", userName);\n\n        // SAFE: expression is hard-coded, attacker cannot change what gets evaluated\n        String template = \"Hello ${name}\";\n        ValueExpression ve = factory.createValueExpression(elContext, template, String.class);\n        String output = (String) ve.getValue(elContext);\n\n        // Optionally also HTML-encode before output to prevent XSS\n        response.getWriter().println(output);\n    }\n}\n```\n\nAdditional remediation steps:\n\n- **Do not** pass raw user input to `ExpressionFactory.createValueExpression`,\n  `SpelExpressionParser.parseExpression`, or similar “evaluate expression” APIs.\n- If you must support some kind of user-defined mini-language, implement a **strict parser/whitelist**\n  that only allows safe operations (e.g., numeric operations only, no method calls, no property access).\n- In Spring, prefer `SimpleEvaluationContext` or a custom `EvaluationContext` with:\n  - No bean resolver or only a whitelisted bean resolver.\n  - Restricted method/property resolvers (disallow reflection, system-level classes, `Runtime`, etc.).\n- Keep frameworks and EL libraries up to date; many EL engines have configuration options or security\n  patches that disable or restrict dangerous features."
              },
              "id": "java.security.el-injection-in-servlet-app",
              "name": "java.security.el-injection-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-917"
                ]
              },
              "shortDescription": {
                "text": "Potential expression language injection"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Insecure deserialization. Used SnakeYAML org.yaml.snakeyaml.Yaml() constructor on user-manipulater yaml data.",
                "text": "Insecure deserialization. Used SnakeYAML org.yaml.snakeyaml.Yaml() constructor on user-manipulater yaml data."
              },
              "id": "java.security.java-servlet-unsafe-snake-yaml-deserialization",
              "name": "java.security.java-servlet-unsafe-snake-yaml-deserialization",
              "properties": {
                "tags": [
                  "CWE-502"
                ]
              },
              "shortDescription": {
                "text": "Insecure deserialization of untrusted YAML data"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "The application allows user input to control format string parameters. By passing invalid format\nstring specifiers an adversary could cause the application to throw exceptions or possibly leak\ninternal information depending on application logic.\n\nNever allow user-supplied input to be used to create a format string. Replace all format string\narguments with hardcoded format strings containing the necessary specifiers.\n\nExample of using `String.format` safely:\n```\n// Get untrusted user input\nString userInput = request.getParameter(\"someInput\");\n// Ensure that user input is not included in the first argument to String.format\nString.format(\"Hardcoded string expecting a string: %s\", userInput);\n// ...\n```",
                "text": "The application allows user input to control format string parameters. By passing invalid format\nstring specifiers an adversary could cause the application to throw exceptions or possibly leak\ninternal information depending on application logic.\n\nNever allow user-supplied input to be used to create a format string. Replace all format string\narguments with hardcoded format strings containing the necessary specifiers.\n\nExample of using `String.format` safely:\n```\n// Get untrusted user input\nString userInput = request.getParameter(\"someInput\");\n// Ensure that user input is not included in the first argument to String.format\nString.format(\"Hardcoded string expecting a string: %s\", userInput);\n// ...\n```"
              },
              "id": "java.security.format-string-external-manipulation-in-servlet-app",
              "name": "java.security.format-string-external-manipulation-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-134"
                ]
              },
              "shortDescription": {
                "text": "Use of externally-controlled format string"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Server-Side Request Forgery (SSRF) in Java servlet applications occurs when the server makes HTTP or other network requests based on user‑supplied input (such as a URL) without proper validation. An attacker can abuse this to make the server connect to internal services (e.g., `http://127.0.0.1:8080/`, cloud metadata services, or other internal hosts) that are not otherwise exposed to the internet, potentially leading to data exfiltration, port scanning, or further compromise.\n\nVulnerable code sample:\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class ProxyServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        // User controls the full URL\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing 'url' parameter\");\n            return;\n        }\n\n        // Dangerous: directly using unvalidated user input as a target URL\n        URL url = new URL(targetUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n\n        response.setStatus(conn.getResponseCode());\n        try (InputStream in = conn.getInputStream();\n            OutputStream out = response.getOutputStream()) {\n            byte[] buffer = new byte[4096];\n            int len;\n            while ((len = in.read(buffer)) != -1) {\n                out.write(buffer, 0, len);\n            }\n        }\n    }\n}\n```\n\nTo remediate this issue, avoid letting clients control arbitrary URLs. Prefer designing APIs so that clients pass identifiers or resource names, not full addresses, and resolve those to known safe locations on the server side. If you truly must fetch external URLs, strictly validate and constrain where the server is allowed to connect (e.g., protocol, host allowlist, and blocking internal IP ranges).\n\nSafer pattern using an allowlist of hosts and restricting the scheme:\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Set;\n\npublic class SafeProxyServlet extends HttpServlet {\n\n    // Only allow requests to these external hosts\n    private static final Set<String> ALLOWED_HOSTS = Set.of(\n            \"api.example.com\",\n            \"services.partner.com\"\n    );\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing 'url' parameter\");\n            return;\n        }\n\n        URI uri;\n        try {\n            uri = new URI(targetUrl);\n        } catch (URISyntaxException e) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid URL\");\n            return;\n        }\n\n        // 1. Restrict scheme\n        String scheme = uri.getScheme();\n        if (scheme == null ||\n                !(scheme.equalsIgnoreCase(\"http\") || scheme.equalsIgnoreCase(\"https\"))) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Unsupported scheme\");\n            return;\n        }\n\n        // 2. Restrict host to an allowlist\n        String host = uri.getHost();\n        if (host == null || !ALLOWED_HOSTS.contains(host.toLowerCase())) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Host not allowed\");\n            return;\n        }\n\n        // 3. Optional: resolve host and reject private/internal IP ranges\n        InetAddress address = InetAddress.getByName(host);\n        if (address.isAnyLocalAddress() ||\n                address.isLoopbackAddress() ||\n                address.isSiteLocalAddress()) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Internal addresses are not allowed\");\n            return;\n        }\n\n        URL url = uri.toURL();\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setConnectTimeout(5000);\n        conn.setReadTimeout(5000);\n        conn.setRequestMethod(\"GET\");\n\n        int status = conn.getResponseCode();\n        response.setStatus(status);\n\n        InputStream in = (status >= 200 && status < 400)\n                ? conn.getInputStream()\n                : conn.getErrorStream();\n\n        if (in != null) {\n            try (in; OutputStream out = response.getOutputStream()) {\n                byte[] buffer = new byte[4096];\n                int len;\n                while ((len = in.read(buffer)) != -1) {\n                    out.write(buffer, 0, len);\n                }\n            }\n        }\n    }\n}\n```\n\nAdditional best practices include:\n\n- Prefer mapping user input to predefined backend endpoints (e.g., `?reportId=123` instead of `?url=http://...`), never giving direct control over full URLs.\n- Enforce network-level controls (firewall rules, security groups) to prevent application servers from reaching sensitive internal services (e.g., cloud metadata endpoints).\n- Disable or tightly restrict any generic “URL fetch” or “proxy” functionality unless it is strictly required.",
                "text": "Server-Side Request Forgery (SSRF) in Java servlet applications occurs when the server makes HTTP or other network requests based on user‑supplied input (such as a URL) without proper validation. An attacker can abuse this to make the server connect to internal services (e.g., `http://127.0.0.1:8080/`, cloud metadata services, or other internal hosts) that are not otherwise exposed to the internet, potentially leading to data exfiltration, port scanning, or further compromise.\n\nVulnerable code sample:\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class ProxyServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        // User controls the full URL\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing 'url' parameter\");\n            return;\n        }\n\n        // Dangerous: directly using unvalidated user input as a target URL\n        URL url = new URL(targetUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n\n        response.setStatus(conn.getResponseCode());\n        try (InputStream in = conn.getInputStream();\n            OutputStream out = response.getOutputStream()) {\n            byte[] buffer = new byte[4096];\n            int len;\n            while ((len = in.read(buffer)) != -1) {\n                out.write(buffer, 0, len);\n            }\n        }\n    }\n}\n```\n\nTo remediate this issue, avoid letting clients control arbitrary URLs. Prefer designing APIs so that clients pass identifiers or resource names, not full addresses, and resolve those to known safe locations on the server side. If you truly must fetch external URLs, strictly validate and constrain where the server is allowed to connect (e.g., protocol, host allowlist, and blocking internal IP ranges).\n\nSafer pattern using an allowlist of hosts and restricting the scheme:\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.*;\nimport java.io.*;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Set;\n\npublic class SafeProxyServlet extends HttpServlet {\n\n    // Only allow requests to these external hosts\n    private static final Set<String> ALLOWED_HOSTS = Set.of(\n            \"api.example.com\",\n            \"services.partner.com\"\n    );\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing 'url' parameter\");\n            return;\n        }\n\n        URI uri;\n        try {\n            uri = new URI(targetUrl);\n        } catch (URISyntaxException e) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid URL\");\n            return;\n        }\n\n        // 1. Restrict scheme\n        String scheme = uri.getScheme();\n        if (scheme == null ||\n                !(scheme.equalsIgnoreCase(\"http\") || scheme.equalsIgnoreCase(\"https\"))) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Unsupported scheme\");\n            return;\n        }\n\n        // 2. Restrict host to an allowlist\n        String host = uri.getHost();\n        if (host == null || !ALLOWED_HOSTS.contains(host.toLowerCase())) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Host not allowed\");\n            return;\n        }\n\n        // 3. Optional: resolve host and reject private/internal IP ranges\n        InetAddress address = InetAddress.getByName(host);\n        if (address.isAnyLocalAddress() ||\n                address.isLoopbackAddress() ||\n                address.isSiteLocalAddress()) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Internal addresses are not allowed\");\n            return;\n        }\n\n        URL url = uri.toURL();\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setConnectTimeout(5000);\n        conn.setReadTimeout(5000);\n        conn.setRequestMethod(\"GET\");\n\n        int status = conn.getResponseCode();\n        response.setStatus(status);\n\n        InputStream in = (status >= 200 && status < 400)\n                ? conn.getInputStream()\n                : conn.getErrorStream();\n\n        if (in != null) {\n            try (in; OutputStream out = response.getOutputStream()) {\n                byte[] buffer = new byte[4096];\n                int len;\n                while ((len = in.read(buffer)) != -1) {\n                    out.write(buffer, 0, len);\n                }\n            }\n        }\n    }\n}\n```\n\nAdditional best practices include:\n\n- Prefer mapping user input to predefined backend endpoints (e.g., `?reportId=123` instead of `?url=http://...`), never giving direct control over full URLs.\n- Enforce network-level controls (firewall rules, security groups) to prevent application servers from reaching sensitive internal services (e.g., cloud metadata endpoints).\n- Disable or tightly restrict any generic “URL fetch” or “proxy” functionality unless it is strictly required."
              },
              "id": "java.security.ssrf-in-servlet-app",
              "name": "java.security.ssrf-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-918"
                ]
              },
              "shortDescription": {
                "text": "Potential server-side request forgery (SSRF)"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "The application was found including unvalidated user input into a URL, which could lead to\nHTTP Parameter Pollution (HPP) or worse, Server Side Request Forgery (SSRF). This could\nallow an adversary to override the value of a URL or a request parameter.  HTTP Parameter\nPollution\n(HPP) attacks consist of injecting encoded query string delimiters into other existing\nparameters. If a web\napplication does not properly sanitize the user input, an adversary may modify the logic of\nthese\nrequests to other applications.\n\nTo remediate this issue, never allow user input directly into creation of a URL or URL\nparameter. Consider\nusing a map to look up user-supplied information and return exact values to be used in the\ngeneration of\nrequests.\n\nExample using a map to look up a key to be used in a HTTP request:\n```\nHashMap<String, String> lookupTable = new HashMap<>();\nlookupTable.put(\"key1\", \"value1\");\nlookupTable.put(\"key2\", \"value2\");\nString userInput = request.getParameter(\"key\");\n\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n    // Lookup the value from our user input from our lookupTable\n    String value = lookupTable.getOrDefault(userInput, \"value1\");\n    // Construct the url, with the hardcoded url and only pass in the value from the\nlookupTable,\n    // not direct user input\n    final HttpGet httpget = new HttpGet(\"https://example.com/getId?key=\"+value);\n    // Execute the request\n    CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n    // Read the response\n    byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n    // Handle the response\n    // ...\n}\n```\n\nIf using a map is not possible, the user-supplied input must be encoded prior to use, and\nnever allow full\nURLs:\n```\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Encode the string using java.net.URLEncoder with the UTF-8 character set\nString encodedString = java.net.URLEncoder.encode(userInput, StandardCharsets.UTF_8);\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n  // Construct the url, with the hardcoded url and only pass in the encoded value, never a\nfull URL\n  final HttpGet httpget = new HttpGet(\"https://example.com/getId?key=\"+encodedString);\n  // Execute the request\n  CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n  // Read the response\n  byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n  // handle the response\n}\n```\n\nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n\nFor more information on HTTP Parameter Pollution see:\nhttps://en.wikipedia.org/wiki/HTTP_parameter_pollution\n",
                "text": "The application was found including unvalidated user input into a URL, which could lead to\nHTTP Parameter Pollution (HPP) or worse, Server Side Request Forgery (SSRF). This could\nallow an adversary to override the value of a URL or a request parameter.  HTTP Parameter\nPollution\n(HPP) attacks consist of injecting encoded query string delimiters into other existing\nparameters. If a web\napplication does not properly sanitize the user input, an adversary may modify the logic of\nthese\nrequests to other applications.\n\nTo remediate this issue, never allow user input directly into creation of a URL or URL\nparameter. Consider\nusing a map to look up user-supplied information and return exact values to be used in the\ngeneration of\nrequests.\n\nExample using a map to look up a key to be used in a HTTP request:\n```\nHashMap<String, String> lookupTable = new HashMap<>();\nlookupTable.put(\"key1\", \"value1\");\nlookupTable.put(\"key2\", \"value2\");\nString userInput = request.getParameter(\"key\");\n\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n    // Lookup the value from our user input from our lookupTable\n    String value = lookupTable.getOrDefault(userInput, \"value1\");\n    // Construct the url, with the hardcoded url and only pass in the value from the\nlookupTable,\n    // not direct user input\n    final HttpGet httpget = new HttpGet(\"https://example.com/getId?key=\"+value);\n    // Execute the request\n    CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n    // Read the response\n    byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n    // Handle the response\n    // ...\n}\n```\n\nIf using a map is not possible, the user-supplied input must be encoded prior to use, and\nnever allow full\nURLs:\n```\n// Get user input\nString userInput = request.getParameter(\"key\");\n// Encode the string using java.net.URLEncoder with the UTF-8 character set\nString encodedString = java.net.URLEncoder.encode(userInput, StandardCharsets.UTF_8);\n// Create a CloseableHttpClient, ideally any requests issued should be done\n// out-of-band from the servlet request itself (such as using a separate thread/scheduler\nsystem)\ntry (final CloseableHttpClient httpClient = HttpClients.createDefault()) {\n  // Construct the url, with the hardcoded url and only pass in the encoded value, never a\nfull URL\n  final HttpGet httpget = new HttpGet(\"https://example.com/getId?key=\"+encodedString);\n  // Execute the request\n  CloseableHttpResponse clientResponse = httpClient.execute(httpget);\n  // Read the response\n  byte[] responseData = clientResponse.getEntity().getContent().readAllBytes();\n  // handle the response\n}\n```\n\nFor more information on SSRF see OWASP:\nhttps://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html\n\nFor more information on HTTP Parameter Pollution see:\nhttps://en.wikipedia.org/wiki/HTTP_parameter_pollution\n"
              },
              "id": "java.security.java-servlet-parameter-pollution",
              "name": "java.security.java-servlet-parameter-pollution",
              "properties": {
                "tags": [
                  "CWE-88"
                ]
              },
              "shortDescription": {
                "text": "Improper neutralization of argument delimiters in a command ('Argument Injection')"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "Unvalidated redirects (also called “open redirects”) occur when a web application accepts untrusted input that specifies a URL to redirect to, and then performs the redirect without sufficient validation. In Spring MVC/Boot applications, this often happens when controllers return a `redirect:` view or `RedirectView` using user-supplied data. Attackers can exploit this to trick users into visiting malicious sites via URLs that appear to be from a trusted domain, or to chain redirects into other attacks.\n\nVulnerable code sample\n\n```java\n@Controller\npublic class RedirectController {\n\n    @GetMapping(\"/redirect\")\n    public String redirect(@RequestParam(\"url\") String url) {\n        // VULNERABLE: unvalidated user-controlled URL\n        return \"redirect:\" + url;\n    }\n}\n```\n\nOr with `RedirectView`:\n\n```java\n@Controller\npublic class RedirectController {\n\n    @GetMapping(\"/redirect\")\n    public RedirectView redirect(@RequestParam(\"url\") String url) {\n        // VULNERABLE: unvalidated user-controlled URL\n        return new RedirectView(url);\n    }\n}\n```\n\nTo remediate this issue, avoid redirecting to arbitrary URLs derived directly from user input. Prefer mapping short, controlled identifiers to known internal routes, or if external redirects are required, strictly validate against a whitelist of allowed hosts and schemes.\n\nExample: safer internal redirects using a target name instead of a full URL:\n\n```java\n@Controller\npublic class SafeRedirectController {\n\n    private static final Map<String, String> ALLOWED_TARGETS = Map.of(\n        \"home\",    \"/home\",\n        \"profile\", \"/user/profile\",\n        \"orders\",  \"/orders/list\"\n    );\n\n    @GetMapping(\"/redirect\")\n    public String redirect(\n            @RequestParam(value = \"target\", required = false) String target) {\n\n        // Default safe page\n        String path = ALLOWED_TARGETS.getOrDefault(target, \"/home\");\n\n        // Only internal paths, no scheme/host\n        return \"redirect:\" + path;\n    }\n}\n```\n\nExample: if you must support external redirects, validate against an allowlist of domains:\n\n```java\n@Controller\npublic class ExternalRedirectController {\n\n    private static final Set<String> ALLOWED_DOMAINS = Set.of(\n        \"example.com\",\n        \"trusted-partner.com\"\n    );\n\n    @GetMapping(\"/external-redirect\")\n    public String externalRedirect(\n            @RequestParam(\"url\") String url,\n            HttpServletRequest request) {\n\n        try {\n            URI uri = new URI(url);\n            String host   = uri.getHost();\n            String scheme = uri.getScheme();\n\n            if (host != null\n                    && (\"http\".equalsIgnoreCase(scheme)\n                        || \"https\".equalsIgnoreCase(scheme))\n                    && ALLOWED_DOMAINS.contains(host.toLowerCase())) {\n\n                // Safe: host and scheme validated against allowlist\n                return \"redirect:\" + uri.toString();\n            }\n        } catch (URISyntaxException e) {\n            // fall through to safe default\n        }\n\n        // Fallback to a safe internal page on any failure or disallowed host\n        return \"redirect:/home\";\n    }\n}\n```",
                "text": "Unvalidated redirects (also called “open redirects”) occur when a web application accepts untrusted input that specifies a URL to redirect to, and then performs the redirect without sufficient validation. In Spring MVC/Boot applications, this often happens when controllers return a `redirect:` view or `RedirectView` using user-supplied data. Attackers can exploit this to trick users into visiting malicious sites via URLs that appear to be from a trusted domain, or to chain redirects into other attacks.\n\nVulnerable code sample\n\n```java\n@Controller\npublic class RedirectController {\n\n    @GetMapping(\"/redirect\")\n    public String redirect(@RequestParam(\"url\") String url) {\n        // VULNERABLE: unvalidated user-controlled URL\n        return \"redirect:\" + url;\n    }\n}\n```\n\nOr with `RedirectView`:\n\n```java\n@Controller\npublic class RedirectController {\n\n    @GetMapping(\"/redirect\")\n    public RedirectView redirect(@RequestParam(\"url\") String url) {\n        // VULNERABLE: unvalidated user-controlled URL\n        return new RedirectView(url);\n    }\n}\n```\n\nTo remediate this issue, avoid redirecting to arbitrary URLs derived directly from user input. Prefer mapping short, controlled identifiers to known internal routes, or if external redirects are required, strictly validate against a whitelist of allowed hosts and schemes.\n\nExample: safer internal redirects using a target name instead of a full URL:\n\n```java\n@Controller\npublic class SafeRedirectController {\n\n    private static final Map<String, String> ALLOWED_TARGETS = Map.of(\n        \"home\",    \"/home\",\n        \"profile\", \"/user/profile\",\n        \"orders\",  \"/orders/list\"\n    );\n\n    @GetMapping(\"/redirect\")\n    public String redirect(\n            @RequestParam(value = \"target\", required = false) String target) {\n\n        // Default safe page\n        String path = ALLOWED_TARGETS.getOrDefault(target, \"/home\");\n\n        // Only internal paths, no scheme/host\n        return \"redirect:\" + path;\n    }\n}\n```\n\nExample: if you must support external redirects, validate against an allowlist of domains:\n\n```java\n@Controller\npublic class ExternalRedirectController {\n\n    private static final Set<String> ALLOWED_DOMAINS = Set.of(\n        \"example.com\",\n        \"trusted-partner.com\"\n    );\n\n    @GetMapping(\"/external-redirect\")\n    public String externalRedirect(\n            @RequestParam(\"url\") String url,\n            HttpServletRequest request) {\n\n        try {\n            URI uri = new URI(url);\n            String host   = uri.getHost();\n            String scheme = uri.getScheme();\n\n            if (host != null\n                    && (\"http\".equalsIgnoreCase(scheme)\n                        || \"https\".equalsIgnoreCase(scheme))\n                    && ALLOWED_DOMAINS.contains(host.toLowerCase())) {\n\n                // Safe: host and scheme validated against allowlist\n                return \"redirect:\" + uri.toString();\n            }\n        } catch (URISyntaxException e) {\n            // fall through to safe default\n        }\n\n        // Fallback to a safe internal page on any failure or disallowed host\n        return \"redirect:/home\";\n    }\n}\n```"
              },
              "id": "java.security.unvalidated-redirect-in-spring-app",
              "name": "java.security.unvalidated-redirect-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-601"
                ]
              },
              "shortDescription": {
                "text": "Application redirects to user-manipulated URL which can be malicious"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "LDAP injection is a security vulnerability that occurs when untrusted input is used to dynamically\nconstruct LDAP queries (filters or distinguished names) without proper validation or encoding.\nIn Java, this often appears in code that uses JNDI (or LDAP libraries) and concatenates user-controlled\ndata into LDAP search filters. An attacker can manipulate the structure of the LDAP query to bypass authentication,\nescalate privileges, or retrieve unauthorized data.\n\n```java\n// Vulnerable code sample (Java + JNDI)\n\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.directory.*;\n\npublic class LdapAuthService {\n\n    private final DirContext ctx;\n    private final String baseDn;\n\n    public LdapAuthService(DirContext ctx, String baseDn) {\n        this.ctx = ctx;\n        this.baseDn = baseDn;\n    }\n\n    public boolean authenticate(String username, String password) throws Exception {\n        // User-controlled input is concatenated directly into the LDAP filter\n        String filter = \"(&(uid=\" + username + \")(userPassword=\" + password + \"))\";\n\n        SearchControls controls = new SearchControls();\n        controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        NamingEnumeration<SearchResult> results =\n                ctx.search(baseDn, filter, controls);\n\n        // If any entry matches, authentication is considered successful\n        return results.hasMore();\n    }\n}\n```\n\nIn this example, if an attacker supplies a crafted `username` such as `*)(|(uid=*))`,\nthe resulting filter changes its logic and may cause the query to match unintended entries,\npotentially bypassing authentication or exposing data.\n\nTo remediate this issue, avoid building LDAP filters or DNs with raw string concatenation of user input.\nInstead, use parameterized LDAP queries / filter argument substitution (which properly encodes special characters),\nand perform strict input validation. For example:\n\n```java\n// Safe code sample (Java + JNDI with filter arguments)\n\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.directory.*;\n\npublic class SafeLdapAuthService {\n\n    private final DirContext ctx;\n    private final String baseDn;\n\n    public SafeLdapAuthService(DirContext ctx, String baseDn) {\n        this.ctx = ctx;\n        this.baseDn = baseDn;\n    }\n\n    public boolean authenticate(String username, String password) throws Exception {\n        // Example of basic input validation (application-specific)\n        if (!username.matches(\"[a-zA-Z0-9._-]{1,32}\")) {\n            return false; // reject unexpected characters / lengths\n        }\n\n        String filter = \"(&(uid={0})(userPassword={1}))\";\n\n        SearchControls controls = new SearchControls();\n        controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        // JNDI will safely encode filter arguments to prevent injection\n        Object[] filterArgs = new Object[] { username, password };\n\n        NamingEnumeration<SearchResult> results =\n                ctx.search(baseDn, filter, filterArgs, controls);\n\n        return results.hasMore();\n    }\n}\n```\n\nKey remediation steps:\n1. **Never concatenate untrusted input into LDAP filters or DNs.**\n2. **Use parameterized LDAP APIs / filter arguments** where available (as shown with `{0}`, `{1}` and `filterArgs`).\n3. **Validate and sanitize inputs** with strict allowlists (e.g., allowed characters, length).\n4. **Use least-privilege LDAP accounts** so that even if a query is abused, impact is limited.\n5. **Centralize LDAP access** through a well-reviewed data access layer or library that handles encoding correctly.",
                "text": "LDAP injection is a security vulnerability that occurs when untrusted input is used to dynamically\nconstruct LDAP queries (filters or distinguished names) without proper validation or encoding.\nIn Java, this often appears in code that uses JNDI (or LDAP libraries) and concatenates user-controlled\ndata into LDAP search filters. An attacker can manipulate the structure of the LDAP query to bypass authentication,\nescalate privileges, or retrieve unauthorized data.\n\n```java\n// Vulnerable code sample (Java + JNDI)\n\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.directory.*;\n\npublic class LdapAuthService {\n\n    private final DirContext ctx;\n    private final String baseDn;\n\n    public LdapAuthService(DirContext ctx, String baseDn) {\n        this.ctx = ctx;\n        this.baseDn = baseDn;\n    }\n\n    public boolean authenticate(String username, String password) throws Exception {\n        // User-controlled input is concatenated directly into the LDAP filter\n        String filter = \"(&(uid=\" + username + \")(userPassword=\" + password + \"))\";\n\n        SearchControls controls = new SearchControls();\n        controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        NamingEnumeration<SearchResult> results =\n                ctx.search(baseDn, filter, controls);\n\n        // If any entry matches, authentication is considered successful\n        return results.hasMore();\n    }\n}\n```\n\nIn this example, if an attacker supplies a crafted `username` such as `*)(|(uid=*))`,\nthe resulting filter changes its logic and may cause the query to match unintended entries,\npotentially bypassing authentication or exposing data.\n\nTo remediate this issue, avoid building LDAP filters or DNs with raw string concatenation of user input.\nInstead, use parameterized LDAP queries / filter argument substitution (which properly encodes special characters),\nand perform strict input validation. For example:\n\n```java\n// Safe code sample (Java + JNDI with filter arguments)\n\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.directory.*;\n\npublic class SafeLdapAuthService {\n\n    private final DirContext ctx;\n    private final String baseDn;\n\n    public SafeLdapAuthService(DirContext ctx, String baseDn) {\n        this.ctx = ctx;\n        this.baseDn = baseDn;\n    }\n\n    public boolean authenticate(String username, String password) throws Exception {\n        // Example of basic input validation (application-specific)\n        if (!username.matches(\"[a-zA-Z0-9._-]{1,32}\")) {\n            return false; // reject unexpected characters / lengths\n        }\n\n        String filter = \"(&(uid={0})(userPassword={1}))\";\n\n        SearchControls controls = new SearchControls();\n        controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        // JNDI will safely encode filter arguments to prevent injection\n        Object[] filterArgs = new Object[] { username, password };\n\n        NamingEnumeration<SearchResult> results =\n                ctx.search(baseDn, filter, filterArgs, controls);\n\n        return results.hasMore();\n    }\n}\n```\n\nKey remediation steps:\n1. **Never concatenate untrusted input into LDAP filters or DNs.**\n2. **Use parameterized LDAP APIs / filter arguments** where available (as shown with `{0}`, `{1}` and `filterArgs`).\n3. **Validate and sanitize inputs** with strict allowlists (e.g., allowed characters, length).\n4. **Use least-privilege LDAP accounts** so that even if a query is abused, impact is limited.\n5. **Centralize LDAP access** through a well-reviewed data access layer or library that handles encoding correctly."
              },
              "id": "java.security.ldap-injection-in-servlet-app",
              "name": "java.security.ldap-injection-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-90"
                ]
              },
              "shortDescription": {
                "text": "Potential LDAP Injection"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "LDAP injection is a security vulnerability that occurs when untrusted input is used to dynamically\nconstruct LDAP queries (filters or distinguished names) without proper validation or encoding.\nIn Java, this often appears in code that uses JNDI (or LDAP libraries) and concatenates user-controlled\ndata into LDAP search filters. An attacker can manipulate the structure of the LDAP query to bypass authentication,\nescalate privileges, or retrieve unauthorized data.\n\n```java\n// Vulnerable code sample (Java + JNDI)\n\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.directory.*;\n\npublic class LdapAuthService {\n\n    private final DirContext ctx;\n    private final String baseDn;\n\n    public LdapAuthService(DirContext ctx, String baseDn) {\n        this.ctx = ctx;\n        this.baseDn = baseDn;\n    }\n\n    public boolean authenticate(String username, String password) throws Exception {\n        // User-controlled input is concatenated directly into the LDAP filter\n        String filter = \"(&(uid=\" + username + \")(userPassword=\" + password + \"))\";\n\n        SearchControls controls = new SearchControls();\n        controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        NamingEnumeration<SearchResult> results =\n                ctx.search(baseDn, filter, controls);\n\n        // If any entry matches, authentication is considered successful\n        return results.hasMore();\n    }\n}\n```\n\nIn this example, if an attacker supplies a crafted `username` such as `*)(|(uid=*))`,\nthe resulting filter changes its logic and may cause the query to match unintended entries,\npotentially bypassing authentication or exposing data.\n\nTo remediate this issue, avoid building LDAP filters or DNs with raw string concatenation of user input.\nInstead, use parameterized LDAP queries / filter argument substitution (which properly encodes special characters),\nand perform strict input validation. For example:\n\n```java\n// Safe code sample (Java + JNDI with filter arguments)\n\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.directory.*;\n\npublic class SafeLdapAuthService {\n\n    private final DirContext ctx;\n    private final String baseDn;\n\n    public SafeLdapAuthService(DirContext ctx, String baseDn) {\n        this.ctx = ctx;\n        this.baseDn = baseDn;\n    }\n\n    public boolean authenticate(String username, String password) throws Exception {\n        // Example of basic input validation (application-specific)\n        if (!username.matches(\"[a-zA-Z0-9._-]{1,32}\")) {\n            return false; // reject unexpected characters / lengths\n        }\n\n        String filter = \"(&(uid={0})(userPassword={1}))\";\n\n        SearchControls controls = new SearchControls();\n        controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        // JNDI will safely encode filter arguments to prevent injection\n        Object[] filterArgs = new Object[] { username, password };\n\n        NamingEnumeration<SearchResult> results =\n                ctx.search(baseDn, filter, filterArgs, controls);\n\n        return results.hasMore();\n    }\n}\n```\n\nKey remediation steps:\n1. **Never concatenate untrusted input into LDAP filters or DNs.**\n2. **Use parameterized LDAP APIs / filter arguments** where available (as shown with `{0}`, `{1}` and `filterArgs`).\n3. **Validate and sanitize inputs** with strict allowlists (e.g., allowed characters, length).\n4. **Use least-privilege LDAP accounts** so that even if a query is abused, impact is limited.\n5. **Centralize LDAP access** through a well-reviewed data access layer or library that handles encoding correctly.",
                "text": "LDAP injection is a security vulnerability that occurs when untrusted input is used to dynamically\nconstruct LDAP queries (filters or distinguished names) without proper validation or encoding.\nIn Java, this often appears in code that uses JNDI (or LDAP libraries) and concatenates user-controlled\ndata into LDAP search filters. An attacker can manipulate the structure of the LDAP query to bypass authentication,\nescalate privileges, or retrieve unauthorized data.\n\n```java\n// Vulnerable code sample (Java + JNDI)\n\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.directory.*;\n\npublic class LdapAuthService {\n\n    private final DirContext ctx;\n    private final String baseDn;\n\n    public LdapAuthService(DirContext ctx, String baseDn) {\n        this.ctx = ctx;\n        this.baseDn = baseDn;\n    }\n\n    public boolean authenticate(String username, String password) throws Exception {\n        // User-controlled input is concatenated directly into the LDAP filter\n        String filter = \"(&(uid=\" + username + \")(userPassword=\" + password + \"))\";\n\n        SearchControls controls = new SearchControls();\n        controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        NamingEnumeration<SearchResult> results =\n                ctx.search(baseDn, filter, controls);\n\n        // If any entry matches, authentication is considered successful\n        return results.hasMore();\n    }\n}\n```\n\nIn this example, if an attacker supplies a crafted `username` such as `*)(|(uid=*))`,\nthe resulting filter changes its logic and may cause the query to match unintended entries,\npotentially bypassing authentication or exposing data.\n\nTo remediate this issue, avoid building LDAP filters or DNs with raw string concatenation of user input.\nInstead, use parameterized LDAP queries / filter argument substitution (which properly encodes special characters),\nand perform strict input validation. For example:\n\n```java\n// Safe code sample (Java + JNDI with filter arguments)\n\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.directory.*;\n\npublic class SafeLdapAuthService {\n\n    private final DirContext ctx;\n    private final String baseDn;\n\n    public SafeLdapAuthService(DirContext ctx, String baseDn) {\n        this.ctx = ctx;\n        this.baseDn = baseDn;\n    }\n\n    public boolean authenticate(String username, String password) throws Exception {\n        // Example of basic input validation (application-specific)\n        if (!username.matches(\"[a-zA-Z0-9._-]{1,32}\")) {\n            return false; // reject unexpected characters / lengths\n        }\n\n        String filter = \"(&(uid={0})(userPassword={1}))\";\n\n        SearchControls controls = new SearchControls();\n        controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n        // JNDI will safely encode filter arguments to prevent injection\n        Object[] filterArgs = new Object[] { username, password };\n\n        NamingEnumeration<SearchResult> results =\n                ctx.search(baseDn, filter, filterArgs, controls);\n\n        return results.hasMore();\n    }\n}\n```\n\nKey remediation steps:\n1. **Never concatenate untrusted input into LDAP filters or DNs.**\n2. **Use parameterized LDAP APIs / filter arguments** where available (as shown with `{0}`, `{1}` and `filterArgs`).\n3. **Validate and sanitize inputs** with strict allowlists (e.g., allowed characters, length).\n4. **Use least-privilege LDAP accounts** so that even if a query is abused, impact is limited.\n5. **Centralize LDAP access** through a well-reviewed data access layer or library that handles encoding correctly."
              },
              "id": "java.security.ldap-injection-in-spring-app",
              "name": "java.security.ldap-injection-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-90"
                ]
              },
              "shortDescription": {
                "text": "Potential LDAP Injection"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "OS Command Injection in a Spring application occurs when a controller or service uses untrusted HTTP input (from query parameters, path variables, request bodies, headers, etc.) to build and execute operating system commands. Because Spring automatically maps request data into method parameters, it's easy to accidentally pass user-controlled strings directly into `Runtime.exec()` or `ProcessBuilder`. If that input is not strictly validated or constrained, an attacker can inject additional commands or modify arguments, leading to arbitrary command execution with the privileges of the running Spring application.\n\nVulnerable code sample\n```java\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n@RestController\npublic class PingController {\n\n    @GetMapping(\"/ping\")\n    public String ping(@RequestParam String host) {\n        // VULNERABLE: direct concatenation of untrusted input into OS command\n        String command = \"ping -c 4 \" + host;\n\n        StringBuilder output = new StringBuilder();\n        try {\n            Process process = Runtime.getRuntime().exec(command); // OS command injection sink\n            try (BufferedReader reader = new BufferedReader(\n                    new InputStreamReader(process.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    output.append(line).append('\\n');\n                }\n            }\n        } catch (Exception e) {\n            return \"Error: \" + e.getMessage();\n        }\n        return output.toString();\n    }\n}\n```\n\nTo remediate this issue, avoid building shell commands from user input and prefer Java APIs or safe process invocation patterns. In Spring specifically, combine safer APIs with strong validation at the controller boundary.\n\nSafer approach — validate input and avoid the shell\n```java\nimport jakarta.validation.constraints.Pattern;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n@RestController\n@Validated\npublic class SafePingController {\n\n    @GetMapping(\"/ping\")\n    public String ping(\n            @RequestParam\n            @Pattern(regexp = \"^[a-zA-Z0-9._-]{1,255}$\", message = \"Invalid host\")\n            String host) {\n\n        // Prefer Java APIs (e.g., InetAddress) where possible.\n        // If you must call an OS command, use ProcessBuilder with separated args.\n        StringBuilder output = new StringBuilder();\n        try {\n            ProcessBuilder pb = new ProcessBuilder(\"ping\", \"-c\", \"4\", host);\n            pb.redirectErrorStream(true);\n            Process process = pb.start();\n\n            try (BufferedReader reader = new BufferedReader(\n                    new InputStreamReader(process.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    output.append(line).append('\\n');\n                }\n            }\n        } catch (Exception e) {\n            return \"Error: \" + e.getMessage();\n        }\n        return output.toString();\n    }\n}\n```\n\nKey points in Spring:\n- Do not concatenate request parameters, path variables, or body values into command strings.\n- Prefer Java libraries (e.g., `InetAddress.isReachable`) instead of calling OS utilities where feasible.\n- If external commands are unavoidable:\n  - Use `ProcessBuilder` with argument lists, not a single shell-processed string.\n  - Do not invoke a shell (`/bin/sh -c`, `cmd.exe /c`).\n  - Apply strong validation/whitelisting at the controller layer (`@Validated`, `@Pattern`, custom validators).\n- Run the Spring application with least-privilege OS accounts and use defense-in-depth (containerization, AppArmor/SELinux, etc.) to minimize impact.",
                "text": "OS Command Injection in a Spring application occurs when a controller or service uses untrusted HTTP input (from query parameters, path variables, request bodies, headers, etc.) to build and execute operating system commands. Because Spring automatically maps request data into method parameters, it's easy to accidentally pass user-controlled strings directly into `Runtime.exec()` or `ProcessBuilder`. If that input is not strictly validated or constrained, an attacker can inject additional commands or modify arguments, leading to arbitrary command execution with the privileges of the running Spring application.\n\nVulnerable code sample\n```java\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n@RestController\npublic class PingController {\n\n    @GetMapping(\"/ping\")\n    public String ping(@RequestParam String host) {\n        // VULNERABLE: direct concatenation of untrusted input into OS command\n        String command = \"ping -c 4 \" + host;\n\n        StringBuilder output = new StringBuilder();\n        try {\n            Process process = Runtime.getRuntime().exec(command); // OS command injection sink\n            try (BufferedReader reader = new BufferedReader(\n                    new InputStreamReader(process.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    output.append(line).append('\\n');\n                }\n            }\n        } catch (Exception e) {\n            return \"Error: \" + e.getMessage();\n        }\n        return output.toString();\n    }\n}\n```\n\nTo remediate this issue, avoid building shell commands from user input and prefer Java APIs or safe process invocation patterns. In Spring specifically, combine safer APIs with strong validation at the controller boundary.\n\nSafer approach — validate input and avoid the shell\n```java\nimport jakarta.validation.constraints.Pattern;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n@RestController\n@Validated\npublic class SafePingController {\n\n    @GetMapping(\"/ping\")\n    public String ping(\n            @RequestParam\n            @Pattern(regexp = \"^[a-zA-Z0-9._-]{1,255}$\", message = \"Invalid host\")\n            String host) {\n\n        // Prefer Java APIs (e.g., InetAddress) where possible.\n        // If you must call an OS command, use ProcessBuilder with separated args.\n        StringBuilder output = new StringBuilder();\n        try {\n            ProcessBuilder pb = new ProcessBuilder(\"ping\", \"-c\", \"4\", host);\n            pb.redirectErrorStream(true);\n            Process process = pb.start();\n\n            try (BufferedReader reader = new BufferedReader(\n                    new InputStreamReader(process.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    output.append(line).append('\\n');\n                }\n            }\n        } catch (Exception e) {\n            return \"Error: \" + e.getMessage();\n        }\n        return output.toString();\n    }\n}\n```\n\nKey points in Spring:\n- Do not concatenate request parameters, path variables, or body values into command strings.\n- Prefer Java libraries (e.g., `InetAddress.isReachable`) instead of calling OS utilities where feasible.\n- If external commands are unavoidable:\n  - Use `ProcessBuilder` with argument lists, not a single shell-processed string.\n  - Do not invoke a shell (`/bin/sh -c`, `cmd.exe /c`).\n  - Apply strong validation/whitelisting at the controller layer (`@Validated`, `@Pattern`, custom validators).\n- Run the Spring application with least-privilege OS accounts and use defense-in-depth (containerization, AppArmor/SELinux, etc.) to minimize impact."
              },
              "id": "java.security.os-command-injection-in-spring-app",
              "name": "java.security.os-command-injection-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-78"
                ]
              },
              "shortDescription": {
                "text": "Command line depends on a user provided value"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Server-Side Request Forgery (SSRF) in Spring-based applications (e.g., Spring MVC / Spring Boot)\noccurs when controllers or services make outbound HTTP (or other network) requests using user-controlled input\n(such as a URL) without strict validation or restriction. Attackers can exploit this to make the application server connect to internal or otherwise protected services (e.g., `http://127.0.0.1:8080/`, cloud metadata services, internal admin panels), leading to data exposure, internal port scanning, or further compromise.\n\nVulnerable code sample:\n\n```java\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.client.RestTemplate;\n\n@RestController\n@RequestMapping(\"/proxy\")\npublic class ProxyController {\n\n    private final RestTemplate restTemplate = new RestTemplate();\n\n    @GetMapping\n    public ResponseEntity<String> proxy(@RequestParam(\"url\") String targetUrl) {\n        // User controls full URL (e.g., https://evil.com?url=http://127.0.0.1:8080/admin)\n        if (targetUrl == null || targetUrl.isBlank()) {\n            return ResponseEntity.badRequest().body(\"Missing 'url' parameter\");\n        }\n\n        // Vulnerable: directly using unvalidated user input as the target\n        String body = restTemplate.getForObject(targetUrl, String.class);\n        return ResponseEntity.ok(body);\n    }\n}\n```\n\nTo remediate this issue, avoid letting clients control arbitrary URLs. Instead, design APIs so that clients pass logical identifiers or resource names, which your server maps to predefined, trusted endpoints. If you must fetch external URLs based on user input, strictly validate and constrain where the server may connect (e.g., use an allowlist of domains, restrict schemes to HTTP/HTTPS, and block internal IP ranges).\n\nSafer code sample using an allowlist and basic IP checks:\n\n```java\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.client.RestTemplate;\n\nimport java.net.*;\nimport java.util.Set;\n\n@RestController\n@RequestMapping(\"/safe-proxy\")\npublic class SafeProxyController {\n\n    private final RestTemplate restTemplate = new RestTemplate();\n\n    // Only allow outbound requests to these hosts\n    private static final Set<String> ALLOWED_HOSTS = Set.of(\n            \"api.example.com\",\n            \"services.partner.com\"\n    );\n\n    @GetMapping\n    public ResponseEntity<String> proxy(@RequestParam(\"url\") String targetUrl) {\n        if (targetUrl == null || targetUrl.isBlank()) {\n            return ResponseEntity.badRequest().body(\"Missing 'url' parameter\");\n        }\n\n        URI uri;\n        try {\n            uri = new URI(targetUrl);\n        } catch (URISyntaxException e) {\n            return ResponseEntity.badRequest().body(\"Invalid URL\");\n        }\n\n        // 1. Restrict scheme\n        String scheme = uri.getScheme();\n        if (scheme == null ||\n                !(scheme.equalsIgnoreCase(\"http\") || scheme.equalsIgnoreCase(\"https\"))) {\n            return ResponseEntity.badRequest().body(\"Unsupported scheme\");\n        }\n\n        // 2. Restrict host to an allowlist\n        String host = uri.getHost();\n        if (host == null || !ALLOWED_HOSTS.contains(host.toLowerCase())) {\n            return ResponseEntity.status(403).body(\"Host not allowed\");\n        }\n\n        // 3. Resolve IP and block internal/loopback addresses\n        try {\n            InetAddress addr = InetAddress.getByName(host);\n            if (addr.isAnyLocalAddress()\n                    || addr.isLoopbackAddress()\n                    || addr.isSiteLocalAddress()) {\n                return ResponseEntity.status(403).body(\"Internal addresses are not allowed\");\n            }\n        } catch (UnknownHostException e) {\n            return ResponseEntity.badRequest().body(\"Unable to resolve host\");\n        }\n\n        // 4. Perform the request to the validated URL\n        String body = restTemplate.getForObject(uri, String.class);\n        return ResponseEntity.ok(body);\n    }\n}\n```\n\nAdditional Spring-focused recommendations:\n\n- Prefer patterns like `GET /reports/{id}` where `{id}` maps to known backend URLs in configuration or code, instead of `GET /proxy?url=...`.\n- Centralize outbound HTTP access (e.g., through a service or a custom `RestTemplate` / `WebClient` bean) and enforce host/URL policies there.\n- Combine application-level protections with network-level controls (firewalls, security groups, service mesh policies) to block access to internal services and metadata endpoints (e.g., `169.254.169.254` on cloud platforms).",
                "text": "Server-Side Request Forgery (SSRF) in Spring-based applications (e.g., Spring MVC / Spring Boot)\noccurs when controllers or services make outbound HTTP (or other network) requests using user-controlled input\n(such as a URL) without strict validation or restriction. Attackers can exploit this to make the application server connect to internal or otherwise protected services (e.g., `http://127.0.0.1:8080/`, cloud metadata services, internal admin panels), leading to data exposure, internal port scanning, or further compromise.\n\nVulnerable code sample:\n\n```java\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.client.RestTemplate;\n\n@RestController\n@RequestMapping(\"/proxy\")\npublic class ProxyController {\n\n    private final RestTemplate restTemplate = new RestTemplate();\n\n    @GetMapping\n    public ResponseEntity<String> proxy(@RequestParam(\"url\") String targetUrl) {\n        // User controls full URL (e.g., https://evil.com?url=http://127.0.0.1:8080/admin)\n        if (targetUrl == null || targetUrl.isBlank()) {\n            return ResponseEntity.badRequest().body(\"Missing 'url' parameter\");\n        }\n\n        // Vulnerable: directly using unvalidated user input as the target\n        String body = restTemplate.getForObject(targetUrl, String.class);\n        return ResponseEntity.ok(body);\n    }\n}\n```\n\nTo remediate this issue, avoid letting clients control arbitrary URLs. Instead, design APIs so that clients pass logical identifiers or resource names, which your server maps to predefined, trusted endpoints. If you must fetch external URLs based on user input, strictly validate and constrain where the server may connect (e.g., use an allowlist of domains, restrict schemes to HTTP/HTTPS, and block internal IP ranges).\n\nSafer code sample using an allowlist and basic IP checks:\n\n```java\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.client.RestTemplate;\n\nimport java.net.*;\nimport java.util.Set;\n\n@RestController\n@RequestMapping(\"/safe-proxy\")\npublic class SafeProxyController {\n\n    private final RestTemplate restTemplate = new RestTemplate();\n\n    // Only allow outbound requests to these hosts\n    private static final Set<String> ALLOWED_HOSTS = Set.of(\n            \"api.example.com\",\n            \"services.partner.com\"\n    );\n\n    @GetMapping\n    public ResponseEntity<String> proxy(@RequestParam(\"url\") String targetUrl) {\n        if (targetUrl == null || targetUrl.isBlank()) {\n            return ResponseEntity.badRequest().body(\"Missing 'url' parameter\");\n        }\n\n        URI uri;\n        try {\n            uri = new URI(targetUrl);\n        } catch (URISyntaxException e) {\n            return ResponseEntity.badRequest().body(\"Invalid URL\");\n        }\n\n        // 1. Restrict scheme\n        String scheme = uri.getScheme();\n        if (scheme == null ||\n                !(scheme.equalsIgnoreCase(\"http\") || scheme.equalsIgnoreCase(\"https\"))) {\n            return ResponseEntity.badRequest().body(\"Unsupported scheme\");\n        }\n\n        // 2. Restrict host to an allowlist\n        String host = uri.getHost();\n        if (host == null || !ALLOWED_HOSTS.contains(host.toLowerCase())) {\n            return ResponseEntity.status(403).body(\"Host not allowed\");\n        }\n\n        // 3. Resolve IP and block internal/loopback addresses\n        try {\n            InetAddress addr = InetAddress.getByName(host);\n            if (addr.isAnyLocalAddress()\n                    || addr.isLoopbackAddress()\n                    || addr.isSiteLocalAddress()) {\n                return ResponseEntity.status(403).body(\"Internal addresses are not allowed\");\n            }\n        } catch (UnknownHostException e) {\n            return ResponseEntity.badRequest().body(\"Unable to resolve host\");\n        }\n\n        // 4. Perform the request to the validated URL\n        String body = restTemplate.getForObject(uri, String.class);\n        return ResponseEntity.ok(body);\n    }\n}\n```\n\nAdditional Spring-focused recommendations:\n\n- Prefer patterns like `GET /reports/{id}` where `{id}` maps to known backend URLs in configuration or code, instead of `GET /proxy?url=...`.\n- Centralize outbound HTTP access (e.g., through a service or a custom `RestTemplate` / `WebClient` bean) and enforce host/URL policies there.\n- Combine application-level protections with network-level controls (firewalls, security groups, service mesh policies) to block access to internal services and metadata endpoints (e.g., `169.254.169.254` on cloud platforms)."
              },
              "id": "java.security.ssrf-in-spring-app",
              "name": "java.security.ssrf-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-918"
                ]
              },
              "shortDescription": {
                "text": "Potential server-side request forgery (SSRF)"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Insecure deserialization. Used SnakeYAML org.yaml.snakeyaml.Yaml() constructor on user-manipulater yaml data.",
                "text": "Insecure deserialization. Used SnakeYAML org.yaml.snakeyaml.Yaml() constructor on user-manipulater yaml data."
              },
              "id": "java.security.spring-unsafe-snake-yaml-deserialization",
              "name": "java.security.spring-unsafe-snake-yaml-deserialization",
              "properties": {
                "tags": [
                  "CWE-502"
                ]
              },
              "shortDescription": {
                "text": "Insecure deserialization of untrusted YAML data"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "XPath Injection in Java occurs when untrusted data is concatenated into an XPath expression that is then evaluated on an XML document.\nAn attacker can inject XPath syntax (such as additional predicates or logical operators) to change the query's meaning,\nbypass authentication or authorization checks, or access sensitive data. It is conceptually similar to SQL injection,\nbut targets XML data sources and XPath processors instead of relational databases.\n\n```java\n// Vulnerable code sample\nimport javax.xml.xpath.*;\nimport org.w3c.dom.Document;\n\npublic class AuthService {\n\n    private final XPath xPath;\n    private final Document usersDoc; // XML like: <users><user><username>...</username>...\n\n    public AuthService(Document usersDoc) {\n        this.usersDoc = usersDoc;\n        this.xPath = XPathFactory.newInstance().newXPath();\n    }\n\n    public boolean authenticate(String username, String password) throws Exception {\n        // VULNERABLE: user input is concatenated directly into the XPath expression\n        String expression = \"/users/user[username='\" + username + \"' and password='\" + password + \"']\";\n\n        // If attacker sets username to: ' or '1'='1\n        // the expression becomes: /users/user[username='' or '1'='1' and password='...']\n        // which can match any user and bypass auth.\n        XPathExpression compiled = xPath.compile(expression);\n        Object result = compiled.evaluate(usersDoc, XPathConstants.NODE);\n        return result != null;\n    }\n}\n```\n\nTo remediate this issue, avoid building XPath expressions via string concatenation with untrusted input,\nvalidate and constrain any user input used in queries, and prefer designs where comparisons are done in code\nrather than in dynamically built XPath. For example, instead of injecting untrusted data into the query,\n select candidate nodes with a static XPath and compare values in Java:\n\n```java\n// Safer approach: do not concatenate untrusted input into the XPath\nimport javax.xml.xpath.*;\nimport org.w3c.dom.*;\n\npublic class SafeAuthService {\n\n    private final XPath xPath;\n    private final Document usersDoc;\n\n    public SafeAuthService(Document usersDoc) {\n        this.usersDoc = usersDoc;\n        this.xPath = XPathFactory.newInstance().newXPath();\n    }\n\n    public boolean authenticate(String username, String password) throws Exception {\n        // 1. Validate input (length, charset, etc.) — example:\n        if (username == null || password == null\n                || username.length() > 50 || password.length() > 100\n                || !username.matches(\"[A-Za-z0-9._-]+\")) {\n            return false;\n        }\n\n        // 2. Use a static XPath to get all user nodes (no user input inside XPath)\n        XPathExpression compiled = xPath.compile(\"/users/user\");\n        NodeList users = (NodeList) compiled.evaluate(usersDoc, XPathConstants.NODESET);\n\n        // 3. Compare in code instead of in XPath\n        for (int i = 0; i < users.getLength(); i++) {\n            Element user = (Element) users.item(i);\n            String u = user.getElementsByTagName(\"username\").item(0).getTextContent();\n            String p = user.getElementsByTagName(\"password\").item(0).getTextContent();\n            if (username.equals(u) && password.equals(p)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\nIn addition, prefer using standard, hardened authentication and data-storage mechanisms\n(e.g., databases with parameterized queries, hashed passwords) instead of custom XML-based auth;\nif XPath must be used, restrict allowed characters, escape or encode any user-controlled values\nbefore inserting them into expressions, and keep XPath expressions as static as possible.",
                "text": "XPath Injection in Java occurs when untrusted data is concatenated into an XPath expression that is then evaluated on an XML document.\nAn attacker can inject XPath syntax (such as additional predicates or logical operators) to change the query's meaning,\nbypass authentication or authorization checks, or access sensitive data. It is conceptually similar to SQL injection,\nbut targets XML data sources and XPath processors instead of relational databases.\n\n```java\n// Vulnerable code sample\nimport javax.xml.xpath.*;\nimport org.w3c.dom.Document;\n\npublic class AuthService {\n\n    private final XPath xPath;\n    private final Document usersDoc; // XML like: <users><user><username>...</username>...\n\n    public AuthService(Document usersDoc) {\n        this.usersDoc = usersDoc;\n        this.xPath = XPathFactory.newInstance().newXPath();\n    }\n\n    public boolean authenticate(String username, String password) throws Exception {\n        // VULNERABLE: user input is concatenated directly into the XPath expression\n        String expression = \"/users/user[username='\" + username + \"' and password='\" + password + \"']\";\n\n        // If attacker sets username to: ' or '1'='1\n        // the expression becomes: /users/user[username='' or '1'='1' and password='...']\n        // which can match any user and bypass auth.\n        XPathExpression compiled = xPath.compile(expression);\n        Object result = compiled.evaluate(usersDoc, XPathConstants.NODE);\n        return result != null;\n    }\n}\n```\n\nTo remediate this issue, avoid building XPath expressions via string concatenation with untrusted input,\nvalidate and constrain any user input used in queries, and prefer designs where comparisons are done in code\nrather than in dynamically built XPath. For example, instead of injecting untrusted data into the query,\n select candidate nodes with a static XPath and compare values in Java:\n\n```java\n// Safer approach: do not concatenate untrusted input into the XPath\nimport javax.xml.xpath.*;\nimport org.w3c.dom.*;\n\npublic class SafeAuthService {\n\n    private final XPath xPath;\n    private final Document usersDoc;\n\n    public SafeAuthService(Document usersDoc) {\n        this.usersDoc = usersDoc;\n        this.xPath = XPathFactory.newInstance().newXPath();\n    }\n\n    public boolean authenticate(String username, String password) throws Exception {\n        // 1. Validate input (length, charset, etc.) — example:\n        if (username == null || password == null\n                || username.length() > 50 || password.length() > 100\n                || !username.matches(\"[A-Za-z0-9._-]+\")) {\n            return false;\n        }\n\n        // 2. Use a static XPath to get all user nodes (no user input inside XPath)\n        XPathExpression compiled = xPath.compile(\"/users/user\");\n        NodeList users = (NodeList) compiled.evaluate(usersDoc, XPathConstants.NODESET);\n\n        // 3. Compare in code instead of in XPath\n        for (int i = 0; i < users.getLength(); i++) {\n            Element user = (Element) users.item(i);\n            String u = user.getElementsByTagName(\"username\").item(0).getTextContent();\n            String p = user.getElementsByTagName(\"password\").item(0).getTextContent();\n            if (username.equals(u) && password.equals(p)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\nIn addition, prefer using standard, hardened authentication and data-storage mechanisms\n(e.g., databases with parameterized queries, hashed passwords) instead of custom XML-based auth;\nif XPath must be used, restrict allowed characters, escape or encode any user-controlled values\nbefore inserting them into expressions, and keep XPath expressions as static as possible."
              },
              "id": "java.security.xpath-injection-in-spring-app",
              "name": "java.security.xpath-injection-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-643"
                ]
              },
              "shortDescription": {
                "text": "XPath Injection"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "The `org.springframework.web.servlet.ModelAndView` class may\npotentially allow access to restricted files if called with user-supplied input.\n\nThe ModelAndView class looks up a view by name to resolve a `.jsp`\nfile. If this view name comes from user-supplied input, it could be abused to attempt\nto return a JSP view that the user should not have access to.\n\nUse a lookup table or hardcode which views or paths the user should be directed to.\n\nExample using a lookup table to resolve a view from a Spring MVC application:\n```\n@RequestMapping(value=\"/mvc\", method=RequestMethod.GET)\npublic ModelAndView mvc(HttpServletRequest request, HttpServletResponse response, Model model)\n{\n  // Create a look up table or pull from a data source\n  HashMap<String, String> lookupTable = new HashMap<>();\n  lookupTable.put(\"key1\", \"view1\");\n  lookupTable.put(\"key2\", \"view2\");\n  // Get user input\n  String userInput = request.getParameter(\"key\");\n  // Look up view from the user input\n  String viewValue = lookupTable.getOrDefault(userInput, \"Resource1\");\n  // return the new model and view\n  return new ModelAndView(viewValue);\n}\n```\n\nExample using a redirect instead of a `RequestDispatcher` in Spring:\n```\n@RequestMapping(value=\"/mvc\", method=RequestMethod.GET)\npublic void mvc(HttpServletRequest request, HttpServletResponse response, Model model)\n{\n  // Create a look up table or pull from a data source\n  HashMap<String, String> lookupTable = new HashMap<>();\n  lookupTable.put(\"key1\", \"view1\");\n  lookupTable.put(\"key2\", \"view2\");\n  // Get user input\n  String userInput = request.getParameter(\"key\");\n  // Look up resource to redirect to from the user input\n  String redirectValue = lookupTable.getOrDefault(userInput, \"/Resource1\");\n  // return the new model and view\n  response.sendRedirect(redirectValue);\n}\n```",
                "text": "The `org.springframework.web.servlet.ModelAndView` class may\npotentially allow access to restricted files if called with user-supplied input.\n\nThe ModelAndView class looks up a view by name to resolve a `.jsp`\nfile. If this view name comes from user-supplied input, it could be abused to attempt\nto return a JSP view that the user should not have access to.\n\nUse a lookup table or hardcode which views or paths the user should be directed to.\n\nExample using a lookup table to resolve a view from a Spring MVC application:\n```\n@RequestMapping(value=\"/mvc\", method=RequestMethod.GET)\npublic ModelAndView mvc(HttpServletRequest request, HttpServletResponse response, Model model)\n{\n  // Create a look up table or pull from a data source\n  HashMap<String, String> lookupTable = new HashMap<>();\n  lookupTable.put(\"key1\", \"view1\");\n  lookupTable.put(\"key2\", \"view2\");\n  // Get user input\n  String userInput = request.getParameter(\"key\");\n  // Look up view from the user input\n  String viewValue = lookupTable.getOrDefault(userInput, \"Resource1\");\n  // return the new model and view\n  return new ModelAndView(viewValue);\n}\n```\n\nExample using a redirect instead of a `RequestDispatcher` in Spring:\n```\n@RequestMapping(value=\"/mvc\", method=RequestMethod.GET)\npublic void mvc(HttpServletRequest request, HttpServletResponse response, Model model)\n{\n  // Create a look up table or pull from a data source\n  HashMap<String, String> lookupTable = new HashMap<>();\n  lookupTable.put(\"key1\", \"view1\");\n  lookupTable.put(\"key2\", \"view2\");\n  // Get user input\n  String userInput = request.getParameter(\"key\");\n  // Look up resource to redirect to from the user input\n  String redirectValue = lookupTable.getOrDefault(userInput, \"/Resource1\");\n  // return the new model and view\n  response.sendRedirect(redirectValue);\n}\n```"
              },
              "id": "java.security.jsp-file-disclosure",
              "name": "java.security.jsp-file-disclosure",
              "properties": {
                "tags": [
                  "CWE-552"
                ]
              },
              "shortDescription": {
                "text": "Files or directories accessible to external parties"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "markdown": "HTTP request/response splitting (often referred to as HTTP response splitting) is an HTTP header injection vulnerability that occurs when untrusted input is placed into HTTP headers without proper validation or encoding. An attacker can inject carriage return (`\\r`) and line feed (`\\n`) characters (CRLF) into header values to terminate the current header section and start a new header or response.\nIn Spring MVC / Spring Boot applications, this typically happens when user-controlled data is used directly in:\n\n- Response headers (via `HttpServletResponse` or `ResponseEntity`)\n- Redirect URLs (e.g. using `\"redirect:\" + userInput`)\n\nallowing an attacker to poison caches, inject responses, or perform XSS via crafted HTTP responses.\n\n```java\n// Vulnerable code sample — Spring MVC / Spring Boot\n\npackage com.example.demo;\n\nimport jakarta.servlet.http.HttpServletResponse;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\n\nimport java.io.IOException;\n\n@Controller\npublic class ProfileController {\n\n    // Example 1: header injection\n    @GetMapping(\"/profile\")\n    public void profile(@RequestParam(name = \"user\", required = false) String user,\n                        HttpServletResponse response) throws IOException {\n\n        // Attacker-supplied: ?user=alice%0D%0ASet-Cookie:%20session=attacker\n        if (user == null) {\n            user = \"anonymous\";\n        }\n\n        // VULNERABLE: unvalidated input used directly as header value\n        response.setHeader(\"X-User\", user);\n\n        response.getWriter().write(\"Profile\");\n    }\n\n    // Example 2: unsafe redirect\n    @GetMapping(\"/go\")\n    public String redirect(@RequestParam(\"next\") String next) {\n\n        // Attacker-supplied:\n        // ?next=%0D%0ASet-Cookie:%20session=attacker\n        // or more complex payloads\n        //\n        // VULNERABLE in designs/versions that don't sanitize CRLF properly:\n        // user input is concatenated into the redirect target, which will be\n        // used as the Location header.\n        return \"redirect:\" + next;\n    }\n}\n```\n\nTo remediate this issue, validate and sanitize all untrusted data before using it in HTTP headers or redirect URLs, and rely on safe builders/encoders instead of string concatenation:\n\n1. **Never place raw user input into headers** (`setHeader`, `addHeader`, `ResponseEntity.header`, or `redirect:` URL fragments).\n2. **Explicitly reject CR (`\\r`) and LF (`\\n`) in all values that might be used in headers or redirect URLs.**\n3. **Use strict allow-lists / regex validation** for header and redirect parameters (e.g. only allow alphanumerics and a small set of safe characters).\n4. **Build URLs using Spring utilities** such as `UriComponentsBuilder`, which properly encodes query parameters rather than concatenating strings.\n5. **Keep Spring Framework and your servlet container up to date** so built‑in CRLF defenses are present, but do not rely on them as the only safeguard.\n\nSafe example:\n\n```java\npackage com.example.demo;\n\nimport jakarta.servlet.http.HttpServletResponse;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\n@Controller\npublic class SafeProfileController {\n\n    @GetMapping(\"/profile\")\n    public void profile(@RequestParam(name = \"user\", required = false) String user,\n                        HttpServletResponse response) throws IOException {\n\n        if (user == null) {\n            user = \"anonymous\";\n        }\n\n        // 1. Reject CR/LF to prevent header injection\n        if (user.contains(\"\\r\") || user.contains(\"\\n\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid user\");\n            return;\n        }\n\n        // 2. Enforce a strict pattern for header-safe values\n        if (!user.matches(\"^[A-Za-z0-9_-]{1,32}$\")) {\n            user = \"anonymous\";  // or reject the request instead\n        }\n\n        // SAFE: header value is validated and free from CRLF\n        response.setHeader(\"X-User\", user);\n\n        response.getWriter().write(\"Profile\");\n    }\n\n    @GetMapping(\"/go\")\n    public String safeRedirect(@RequestParam(name = \"next\", required = false) String next) {\n\n        if (next == null || next.isBlank()) {\n            next = \"/home\";\n        }\n\n        // 3. Reject CR/LF in redirect target\n        if (next.contains(\"\\r\") || next.contains(\"\\n\")) {\n            // In a real app, log and redirect to a safe default\n            next = \"/home\";\n        }\n\n        // 4. Optionally, enforce a stricter rule: only allow local paths\n        if (!next.startsWith(\"/\")) {\n            next = \"/home\";\n        }\n\n        // 5. Build and encode the redirect URL safely\n        String url = UriComponentsBuilder\n                .fromPath(next)\n                // Example of adding an encoded query parameter:\n                // .queryParam(\"ref\", \"someRef\")\n                .build()\n                .encode(StandardCharsets.UTF_8)\n                .toUriString();\n\n        // SAFE: Spring will use the encoded URL as the Location header\n        return \"redirect:\" + url;\n    }\n}\n```",
                "text": "HTTP request/response splitting (often referred to as HTTP response splitting) is an HTTP header injection vulnerability that occurs when untrusted input is placed into HTTP headers without proper validation or encoding. An attacker can inject carriage return (`\\r`) and line feed (`\\n`) characters (CRLF) into header values to terminate the current header section and start a new header or response.\nIn Spring MVC / Spring Boot applications, this typically happens when user-controlled data is used directly in:\n\n- Response headers (via `HttpServletResponse` or `ResponseEntity`)\n- Redirect URLs (e.g. using `\"redirect:\" + userInput`)\n\nallowing an attacker to poison caches, inject responses, or perform XSS via crafted HTTP responses.\n\n```java\n// Vulnerable code sample — Spring MVC / Spring Boot\n\npackage com.example.demo;\n\nimport jakarta.servlet.http.HttpServletResponse;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\n\nimport java.io.IOException;\n\n@Controller\npublic class ProfileController {\n\n    // Example 1: header injection\n    @GetMapping(\"/profile\")\n    public void profile(@RequestParam(name = \"user\", required = false) String user,\n                        HttpServletResponse response) throws IOException {\n\n        // Attacker-supplied: ?user=alice%0D%0ASet-Cookie:%20session=attacker\n        if (user == null) {\n            user = \"anonymous\";\n        }\n\n        // VULNERABLE: unvalidated input used directly as header value\n        response.setHeader(\"X-User\", user);\n\n        response.getWriter().write(\"Profile\");\n    }\n\n    // Example 2: unsafe redirect\n    @GetMapping(\"/go\")\n    public String redirect(@RequestParam(\"next\") String next) {\n\n        // Attacker-supplied:\n        // ?next=%0D%0ASet-Cookie:%20session=attacker\n        // or more complex payloads\n        //\n        // VULNERABLE in designs/versions that don't sanitize CRLF properly:\n        // user input is concatenated into the redirect target, which will be\n        // used as the Location header.\n        return \"redirect:\" + next;\n    }\n}\n```\n\nTo remediate this issue, validate and sanitize all untrusted data before using it in HTTP headers or redirect URLs, and rely on safe builders/encoders instead of string concatenation:\n\n1. **Never place raw user input into headers** (`setHeader`, `addHeader`, `ResponseEntity.header`, or `redirect:` URL fragments).\n2. **Explicitly reject CR (`\\r`) and LF (`\\n`) in all values that might be used in headers or redirect URLs.**\n3. **Use strict allow-lists / regex validation** for header and redirect parameters (e.g. only allow alphanumerics and a small set of safe characters).\n4. **Build URLs using Spring utilities** such as `UriComponentsBuilder`, which properly encodes query parameters rather than concatenating strings.\n5. **Keep Spring Framework and your servlet container up to date** so built‑in CRLF defenses are present, but do not rely on them as the only safeguard.\n\nSafe example:\n\n```java\npackage com.example.demo;\n\nimport jakarta.servlet.http.HttpServletResponse;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\n@Controller\npublic class SafeProfileController {\n\n    @GetMapping(\"/profile\")\n    public void profile(@RequestParam(name = \"user\", required = false) String user,\n                        HttpServletResponse response) throws IOException {\n\n        if (user == null) {\n            user = \"anonymous\";\n        }\n\n        // 1. Reject CR/LF to prevent header injection\n        if (user.contains(\"\\r\") || user.contains(\"\\n\")) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid user\");\n            return;\n        }\n\n        // 2. Enforce a strict pattern for header-safe values\n        if (!user.matches(\"^[A-Za-z0-9_-]{1,32}$\")) {\n            user = \"anonymous\";  // or reject the request instead\n        }\n\n        // SAFE: header value is validated and free from CRLF\n        response.setHeader(\"X-User\", user);\n\n        response.getWriter().write(\"Profile\");\n    }\n\n    @GetMapping(\"/go\")\n    public String safeRedirect(@RequestParam(name = \"next\", required = false) String next) {\n\n        if (next == null || next.isBlank()) {\n            next = \"/home\";\n        }\n\n        // 3. Reject CR/LF in redirect target\n        if (next.contains(\"\\r\") || next.contains(\"\\n\")) {\n            // In a real app, log and redirect to a safe default\n            next = \"/home\";\n        }\n\n        // 4. Optionally, enforce a stricter rule: only allow local paths\n        if (!next.startsWith(\"/\")) {\n            next = \"/home\";\n        }\n\n        // 5. Build and encode the redirect URL safely\n        String url = UriComponentsBuilder\n                .fromPath(next)\n                // Example of adding an encoded query parameter:\n                // .queryParam(\"ref\", \"someRef\")\n                .build()\n                .encode(StandardCharsets.UTF_8)\n                .toUriString();\n\n        // SAFE: Spring will use the encoded URL as the Location header\n        return \"redirect:\" + url;\n    }\n}\n```"
              },
              "id": "java.security.http-response-splitting-in-spring-app",
              "name": "java.security.http-response-splitting-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-113"
                ]
              },
              "shortDescription": {
                "text": "HTTP response splitting"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Template engine injection (often called server-side template injection, SSTI) is a\nvulnerability where untrusted input is interpreted as template code by a server-side template engine\n(e.g., FreeMarker, Velocity, Thymeleaf, JSP EL). In Java servlet applications,\nthis happens when user-controlled data is used to build or select templates,\nor is otherwise passed to the template engine in a way that allows it to be executed\nrather than treated as plain data. Successful exploitation can lead to information disclosure,\narbitrary server-side code execution, or full compromise of the application server.\n\n```java\n// Vulnerable code sample (Java servlet + FreeMarker)\n\nimport freemarker.template.Configuration;\nimport freemarker.template.Template;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.StringReader;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MessageServlet extends HttpServlet {\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            // Attacker controls the entire template content\n            String templateSource = request.getParameter(\"messageTemplate\");\n\n            Configuration cfg = (Configuration) getServletContext().getAttribute(\"freemarkerCfg\");\n\n            // VULNERABLE: compiling a template directly from user input\n            Template t = new Template(\"userTemplate\", new StringReader(templateSource), cfg);\n\n            Map<String, Object> model = new HashMap<>();\n            model.put(\"username\", request.getParameter(\"username\"));\n\n            response.setContentType(\"text/html;charset=UTF-8\");\n            t.process(model, response.getWriter());  // User input is interpreted as template code\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\nTo remediate this issue, never allow untrusted input to be treated as template code.\nUse only static, server-side—controlled templates and ensure user data is inserted strictly as data (variables),\nnot as executable expressions or template fragments. Also, restrict dangerous template features\n(e.g., arbitrary class loading, execution helpers) where possible.\n\nA safer approach:\n\n```java\n// Safer code sample (whitelisted template + data only)\n\nimport freemarker.template.Configuration;\nimport freemarker.template.Template;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MessageServlet extends HttpServlet {\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            Configuration cfg = (Configuration) getServletContext().getAttribute(\"freemarkerCfg\");\n\n            // Use only server-controlled template names (e.g., enum, config, or hard-coded)\n            String templateName = \"message.ftl\";  // static template stored on the server\n            Template t = cfg.getTemplate(templateName);\n\n            // Treat user input as plain data only\n            String username = request.getParameter(\"username\");\n            String messageText = request.getParameter(\"messageText\");\n\n            Map<String, Object> model = new HashMap<>();\n            model.put(\"username\", username);\n            model.put(\"messageText\", messageText);\n\n            response.setContentType(\"text/html;charset=UTF-8\");\n            t.process(model, response.getWriter());\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\nAdditional hardening steps:\n\n- Do not construct templates or template fragments (e.g., `new Template(...)`, `engine.process(userInput, ...)`)\n  from user input, including from HTTP parameters, headers, cookies, or database fields that users can influence.\n- Use strict whitelisting when selecting templates (e.g., map allowed IDs to fixed template filenames).\n- Configure the template engine in a “safe” mode where available (e.g., disable or restrict access to arbitrary\n  classes, reflection, or command execution helpers).\n- Validate and, if necessary, HTML-escape user-provided strings before rendering, so they are displayed as\n  text rather than interpreted as markup or expressions.\n- Avoid using powerful template engines as general-purpose expression evaluators for user input;\n  if evaluation is required, use dedicated, sandboxed expression libraries with strong security guarantees.",
                "text": "Template engine injection (often called server-side template injection, SSTI) is a\nvulnerability where untrusted input is interpreted as template code by a server-side template engine\n(e.g., FreeMarker, Velocity, Thymeleaf, JSP EL). In Java servlet applications,\nthis happens when user-controlled data is used to build or select templates,\nor is otherwise passed to the template engine in a way that allows it to be executed\nrather than treated as plain data. Successful exploitation can lead to information disclosure,\narbitrary server-side code execution, or full compromise of the application server.\n\n```java\n// Vulnerable code sample (Java servlet + FreeMarker)\n\nimport freemarker.template.Configuration;\nimport freemarker.template.Template;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.StringReader;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MessageServlet extends HttpServlet {\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            // Attacker controls the entire template content\n            String templateSource = request.getParameter(\"messageTemplate\");\n\n            Configuration cfg = (Configuration) getServletContext().getAttribute(\"freemarkerCfg\");\n\n            // VULNERABLE: compiling a template directly from user input\n            Template t = new Template(\"userTemplate\", new StringReader(templateSource), cfg);\n\n            Map<String, Object> model = new HashMap<>();\n            model.put(\"username\", request.getParameter(\"username\"));\n\n            response.setContentType(\"text/html;charset=UTF-8\");\n            t.process(model, response.getWriter());  // User input is interpreted as template code\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\nTo remediate this issue, never allow untrusted input to be treated as template code.\nUse only static, server-side—controlled templates and ensure user data is inserted strictly as data (variables),\nnot as executable expressions or template fragments. Also, restrict dangerous template features\n(e.g., arbitrary class loading, execution helpers) where possible.\n\nA safer approach:\n\n```java\n// Safer code sample (whitelisted template + data only)\n\nimport freemarker.template.Configuration;\nimport freemarker.template.Template;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MessageServlet extends HttpServlet {\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            Configuration cfg = (Configuration) getServletContext().getAttribute(\"freemarkerCfg\");\n\n            // Use only server-controlled template names (e.g., enum, config, or hard-coded)\n            String templateName = \"message.ftl\";  // static template stored on the server\n            Template t = cfg.getTemplate(templateName);\n\n            // Treat user input as plain data only\n            String username = request.getParameter(\"username\");\n            String messageText = request.getParameter(\"messageText\");\n\n            Map<String, Object> model = new HashMap<>();\n            model.put(\"username\", username);\n            model.put(\"messageText\", messageText);\n\n            response.setContentType(\"text/html;charset=UTF-8\");\n            t.process(model, response.getWriter());\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\nAdditional hardening steps:\n\n- Do not construct templates or template fragments (e.g., `new Template(...)`, `engine.process(userInput, ...)`)\n  from user input, including from HTTP parameters, headers, cookies, or database fields that users can influence.\n- Use strict whitelisting when selecting templates (e.g., map allowed IDs to fixed template filenames).\n- Configure the template engine in a “safe” mode where available (e.g., disable or restrict access to arbitrary\n  classes, reflection, or command execution helpers).\n- Validate and, if necessary, HTML-escape user-provided strings before rendering, so they are displayed as\n  text rather than interpreted as markup or expressions.\n- Avoid using powerful template engines as general-purpose expression evaluators for user input;\n  if evaluation is required, use dedicated, sandboxed expression libraries with strong security guarantees."
              },
              "id": "java.security.ssti-in-servlet-app",
              "name": "java.security.ssti-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-94",
                  "CWE-1336"
                ]
              },
              "shortDescription": {
                "text": "Unvalidated user data flows into template engine"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "CRLF (Carriage Return + Line Feed, `\\r\\n`) injection into an SMTP `MimeMessage` occurs when untrusted input is placed directly into email headers (e.g., `Subject`, `To`, `From`, custom headers) without properly validating or stripping newline characters.\n\nBecause SMTP and MIME use `\\r\\n` to separate headers and the message body, an attacker who can inject `\\r\\n` into a header field can prematurely terminate that header and start injecting new headers or even alter the body. This can be abused to:\n\n- Add unintended recipients (`Bcc`, `Cc`, additional `To`).\n- Spoof or modify headers (e.g., `From`, `Reply-To`, `X-...`).\n- Manipulate message content or spam/abuse mail infrastructure.\n\nIn Java, this often happens when using `MimeMessage` (e.g., via Jakarta Mail / JavaMail) with user-supplied values for headers without sanitization, or when bypassing built-in validation by using low-level header methods.\n\n---\n\nVulnerable code sample\n\n```java\npublic void sendEmail(HttpServletRequest request) throws MessagingException {\n    String to = request.getParameter(\"to\");\n    String subject = request.getParameter(\"subject\");\n    String body = request.getParameter(\"message\");\n\n    Session session = getMailSession();\n    MimeMessage message = new MimeMessage(session);\n\n    // User-controlled values, no validation\n    message.setFrom(new InternetAddress(\"noreply@example.com\"));\n    message.setRecipient(Message.RecipientType.TO, new InternetAddress(to));\n\n    // Vulnerable: subject comes directly from user input\n    // If subject contains \"\\r\\nBcc: victim@example.com\", that may create a new header line\n    message.setHeader(\"Subject\", subject); // bad: manual header setting\n\n    // Also dangerous when using generic headers\n    String trackingId = request.getParameter(\"trackingId\");\n    message.setHeader(\"X-Tracking-Id\", trackingId); // unvalidated header value\n\n    message.setText(body);\n\n    Transport.send(message);\n}\n```\n\nIf an attacker supplies a value like:\n\n```text\nsubject = \"Hello\\r\\nBcc: attacker@example.com\"\n```\n\nand the underlying library does not strip or reject CR/LF characters for that header-setting method, the generated email may contain an injected `Bcc` header, silently copying all messages to the attacker.\n\n---\n\nTo remediate this issue, ensure that any user-controlled input used in email headers is strictly validated and cannot contain CR (`\\r`) or LF (`\\n`) characters, and avoid low-level header methods where safer, higher-level APIs exist.\n\nKey steps:\n\n1. **Disallow CR and LF in header fields**\n  Strip or reject any input that contains `\\r` or `\\n` if it will be used in a header (e.g., `Subject`, `From`, `To`, `Reply-To`, custom `X-*` headers).\n\n2. **Use high-level `MimeMessage` APIs**\n  Prefer methods like `setSubject`, `setFrom`, `setRecipients`, which usually perform syntax checks, instead of `setHeader` / `addHeader` with raw values. Do not manually craft header lines.\n\n3. **Apply strict validation**\n  - For email addresses: validate against a reasonable email regex and/or let `InternetAddress` parse and validate addresses, and reject invalid ones.\n  - For subjects / custom header values: define allowed character sets or patterns (e.g., letters, numbers, spaces, basic punctuation) and reject anything else.\n\n4. **Keep your mail library up to date**\n  Use the latest Jakarta Mail / JavaMail version, as many unsafe behaviors (including header validation) have been tightened over time. But even with updated libraries, you should still validate input.\n\nSafe code sample:\n\n```java\npublic void sendEmail(HttpServletRequest request) throws MessagingException {\n    String toParam = request.getParameter(\"to\");\n    String subjectParam = request.getParameter(\"subject\");\n    String bodyParam = request.getParameter(\"message\");\n    String trackingIdParam = request.getParameter(\"trackingId\");\n\n    // Basic null checks omitted for brevity\n\n    // 1. Validate and sanitize inputs\n\n    // Reject CR and LF in any header-bound fields\n    if (containsCRLF(subjectParam) || containsCRLF(trackingIdParam) || containsCRLF(toParam)) {\n        throw new IllegalArgumentException(\"Invalid input\");\n    }\n\n    // Validate email address format via InternetAddress\n    InternetAddress toAddress;\n    try {\n        toAddress = new InternetAddress(toParam, true); // 'true' for strict validation\n    } catch (AddressException ex) {\n        throw new IllegalArgumentException(\"Invalid recipient address\", ex);\n    }\n\n    // Optionally, normalize subject to a safe subset of characters\n    String safeSubject = subjectParam.replaceAll(\"[\\r\\n]\", \"\").trim();\n\n    // Optionally, validate custom header (e.g., alphanumeric + dash only)\n    String safeTrackingId = trackingIdParam.replaceAll(\"[^A-Za-z0-9\\\\-]\", \"\");\n\n    // 2. Use higher-level MimeMessage APIs\n\n    Session session = getMailSession();\n    MimeMessage message = new MimeMessage(session);\n\n    message.setFrom(new InternetAddress(\"noreply@example.com\"));\n    message.setRecipient(Message.RecipientType.TO, toAddress);\n\n    // Use setSubject, which encodes and validates header correctly\n    message.setSubject(safeSubject, \"UTF-8\");\n\n    // Custom headers: still only after sanitization\n    if (!safeTrackingId.isEmpty()) {\n        message.setHeader(\"X-Tracking-Id\", safeTrackingId);\n    }\n\n    message.setText(bodyParam, \"UTF-8\");\n\n    Transport.send(message);\n}\n\nprivate boolean containsCRLF(String value) {\n    return value != null && (value.indexOf('\\r') >= 0 || value.indexOf('\\n') >= 0);\n}\n```\n\nIn this remediated version:\n\n- All header-bound values are checked for `\\r` and `\\n`.\n- Email address is validated via `InternetAddress`.\n- `setSubject` is used instead of `setHeader(\"Subject\", …)`.\n- Custom header is sanitized to a safe character set before being used.",
                "text": "CRLF (Carriage Return + Line Feed, `\\r\\n`) injection into an SMTP `MimeMessage` occurs when untrusted input is placed directly into email headers (e.g., `Subject`, `To`, `From`, custom headers) without properly validating or stripping newline characters.\n\nBecause SMTP and MIME use `\\r\\n` to separate headers and the message body, an attacker who can inject `\\r\\n` into a header field can prematurely terminate that header and start injecting new headers or even alter the body. This can be abused to:\n\n- Add unintended recipients (`Bcc`, `Cc`, additional `To`).\n- Spoof or modify headers (e.g., `From`, `Reply-To`, `X-...`).\n- Manipulate message content or spam/abuse mail infrastructure.\n\nIn Java, this often happens when using `MimeMessage` (e.g., via Jakarta Mail / JavaMail) with user-supplied values for headers without sanitization, or when bypassing built-in validation by using low-level header methods.\n\n---\n\nVulnerable code sample\n\n```java\npublic void sendEmail(HttpServletRequest request) throws MessagingException {\n    String to = request.getParameter(\"to\");\n    String subject = request.getParameter(\"subject\");\n    String body = request.getParameter(\"message\");\n\n    Session session = getMailSession();\n    MimeMessage message = new MimeMessage(session);\n\n    // User-controlled values, no validation\n    message.setFrom(new InternetAddress(\"noreply@example.com\"));\n    message.setRecipient(Message.RecipientType.TO, new InternetAddress(to));\n\n    // Vulnerable: subject comes directly from user input\n    // If subject contains \"\\r\\nBcc: victim@example.com\", that may create a new header line\n    message.setHeader(\"Subject\", subject); // bad: manual header setting\n\n    // Also dangerous when using generic headers\n    String trackingId = request.getParameter(\"trackingId\");\n    message.setHeader(\"X-Tracking-Id\", trackingId); // unvalidated header value\n\n    message.setText(body);\n\n    Transport.send(message);\n}\n```\n\nIf an attacker supplies a value like:\n\n```text\nsubject = \"Hello\\r\\nBcc: attacker@example.com\"\n```\n\nand the underlying library does not strip or reject CR/LF characters for that header-setting method, the generated email may contain an injected `Bcc` header, silently copying all messages to the attacker.\n\n---\n\nTo remediate this issue, ensure that any user-controlled input used in email headers is strictly validated and cannot contain CR (`\\r`) or LF (`\\n`) characters, and avoid low-level header methods where safer, higher-level APIs exist.\n\nKey steps:\n\n1. **Disallow CR and LF in header fields**\n  Strip or reject any input that contains `\\r` or `\\n` if it will be used in a header (e.g., `Subject`, `From`, `To`, `Reply-To`, custom `X-*` headers).\n\n2. **Use high-level `MimeMessage` APIs**\n  Prefer methods like `setSubject`, `setFrom`, `setRecipients`, which usually perform syntax checks, instead of `setHeader` / `addHeader` with raw values. Do not manually craft header lines.\n\n3. **Apply strict validation**\n  - For email addresses: validate against a reasonable email regex and/or let `InternetAddress` parse and validate addresses, and reject invalid ones.\n  - For subjects / custom header values: define allowed character sets or patterns (e.g., letters, numbers, spaces, basic punctuation) and reject anything else.\n\n4. **Keep your mail library up to date**\n  Use the latest Jakarta Mail / JavaMail version, as many unsafe behaviors (including header validation) have been tightened over time. But even with updated libraries, you should still validate input.\n\nSafe code sample:\n\n```java\npublic void sendEmail(HttpServletRequest request) throws MessagingException {\n    String toParam = request.getParameter(\"to\");\n    String subjectParam = request.getParameter(\"subject\");\n    String bodyParam = request.getParameter(\"message\");\n    String trackingIdParam = request.getParameter(\"trackingId\");\n\n    // Basic null checks omitted for brevity\n\n    // 1. Validate and sanitize inputs\n\n    // Reject CR and LF in any header-bound fields\n    if (containsCRLF(subjectParam) || containsCRLF(trackingIdParam) || containsCRLF(toParam)) {\n        throw new IllegalArgumentException(\"Invalid input\");\n    }\n\n    // Validate email address format via InternetAddress\n    InternetAddress toAddress;\n    try {\n        toAddress = new InternetAddress(toParam, true); // 'true' for strict validation\n    } catch (AddressException ex) {\n        throw new IllegalArgumentException(\"Invalid recipient address\", ex);\n    }\n\n    // Optionally, normalize subject to a safe subset of characters\n    String safeSubject = subjectParam.replaceAll(\"[\\r\\n]\", \"\").trim();\n\n    // Optionally, validate custom header (e.g., alphanumeric + dash only)\n    String safeTrackingId = trackingIdParam.replaceAll(\"[^A-Za-z0-9\\\\-]\", \"\");\n\n    // 2. Use higher-level MimeMessage APIs\n\n    Session session = getMailSession();\n    MimeMessage message = new MimeMessage(session);\n\n    message.setFrom(new InternetAddress(\"noreply@example.com\"));\n    message.setRecipient(Message.RecipientType.TO, toAddress);\n\n    // Use setSubject, which encodes and validates header correctly\n    message.setSubject(safeSubject, \"UTF-8\");\n\n    // Custom headers: still only after sanitization\n    if (!safeTrackingId.isEmpty()) {\n        message.setHeader(\"X-Tracking-Id\", safeTrackingId);\n    }\n\n    message.setText(bodyParam, \"UTF-8\");\n\n    Transport.send(message);\n}\n\nprivate boolean containsCRLF(String value) {\n    return value != null && (value.indexOf('\\r') >= 0 || value.indexOf('\\n') >= 0);\n}\n```\n\nIn this remediated version:\n\n- All header-bound values are checked for `\\r` and `\\n`.\n- Email address is validated via `InternetAddress`.\n- `setSubject` is used instead of `setHeader(\"Subject\", …)`.\n- Custom header is sanitized to a safe character set before being used."
              },
              "id": "java.security.java-servlet-smtp-crlf-injection",
              "name": "java.security.java-servlet-smtp-crlf-injection",
              "properties": {
                "tags": [
                  "CWE-77"
                ]
              },
              "shortDescription": {
                "text": "CRLF injection into SMTP message"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "When untrusted data is passed into `java.sql.Connection.setCatalog(String)`, an attacker can control which database/catalog the application is using. This is similar in effect to letting the user choose the SQL `USE <database>` statement. In multi-tenant or multi-schema setups, this can break isolation between tenants, bypass authorization logic, and expose or corrupt data held in other catalogs that the database account can access. This is generally categorized as *external control of system or configuration settings* and is closely related to injection-style vulnerabilities.\nVulnerable code sample\n```java public void doGet(HttpServletRequest request, HttpServletResponse response)\n        throws SQLException, IOException {\n\n    // User-controlled input (e.g., from query string: ?catalog=other_tenant_db)\n    String catalog = request.getParameter(\"catalog\");\n\n    Connection conn = dataSource.getConnection();\n\n    // VULNERABLE: external control of the active database/catalog\n    conn.setCatalog(catalog);\n\n    try (PreparedStatement ps = conn.prepareStatement(\n            \"SELECT id, email FROM users WHERE id = ?\")) {\n        ps.setInt(1, Integer.parseInt(request.getParameter(\"id\")));\n        ResultSet rs = ps.executeQuery();\n        // ...\n    }\n} ```\nIf the underlying database user has access to multiple catalogs (for example, one per tenant), an attacker can supply another tenant's catalog name (or guess other internal catalogs) and read or modify data that should not be available to them.\nTo remediate this issue, ensure that the catalog is never directly controlled by untrusted input. Instead:\n1. **Do not accept arbitrary catalog names from clients.**\n  Determine the catalog on the server side based on:\n  - The authenticated user/tenant, and/or\n  - Static configuration (e.g., per-environment settings), not request parameters.\n\n2. **Use a strict whitelist or mapping.**\n  If you must vary the catalog, map safe, server-side identifiers to catalog names. Never pass raw client-provided strings to `setCatalog`.\n\n3. **Enforce least privilege at the database level.**\n  The DB account used by the application should only have access to the specific catalog(s) it legitimately needs; avoid a single highly privileged account that can access every catalog.\n\nSafer code example (server-side mapping & validation)\n```java // Preconfigured, server-side mapping from tenant ID to allowed catalog private static final Map<String, String> TENANT_CATALOGS = Map.of(\n    \"tenantA\", \"tenant_a_db\",\n    \"tenantB\", \"tenant_b_db\"\n);\npublic void doGet(HttpServletRequest request, HttpServletResponse response)\n        throws SQLException, IOException {\n\n    String tenantId = getAuthenticatedTenantId(request);  // e.g., from session/JWT\n\n    String catalog = TENANT_CATALOGS.get(tenantId);\n    if (catalog == null) {\n        // Unknown or unauthorized tenant; do not proceed\n        response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Unauthorized tenant\");\n        return;\n    }\n\n    try (Connection conn = dataSource.getConnection()) {\n        // Safe: catalog comes from trusted server-side configuration\n        conn.setCatalog(catalog);\n\n        try (PreparedStatement ps = conn.prepareStatement(\n                \"SELECT id, email FROM users WHERE id = ?\")) {\n            ps.setInt(1, Integer.parseInt(request.getParameter(\"id\")));\n            ResultSet rs = ps.executeQuery();\n            // ...\n        }\n    }\n}\nprivate String getAuthenticatedTenantId(HttpServletRequest request) {\n    // Implementation-specific: derive from authentication/authorization context\n    return (String) request.getAttribute(\"tenantId\");\n} ```",
                "text": "When untrusted data is passed into `java.sql.Connection.setCatalog(String)`, an attacker can control which database/catalog the application is using. This is similar in effect to letting the user choose the SQL `USE <database>` statement. In multi-tenant or multi-schema setups, this can break isolation between tenants, bypass authorization logic, and expose or corrupt data held in other catalogs that the database account can access. This is generally categorized as *external control of system or configuration settings* and is closely related to injection-style vulnerabilities.\nVulnerable code sample\n```java public void doGet(HttpServletRequest request, HttpServletResponse response)\n        throws SQLException, IOException {\n\n    // User-controlled input (e.g., from query string: ?catalog=other_tenant_db)\n    String catalog = request.getParameter(\"catalog\");\n\n    Connection conn = dataSource.getConnection();\n\n    // VULNERABLE: external control of the active database/catalog\n    conn.setCatalog(catalog);\n\n    try (PreparedStatement ps = conn.prepareStatement(\n            \"SELECT id, email FROM users WHERE id = ?\")) {\n        ps.setInt(1, Integer.parseInt(request.getParameter(\"id\")));\n        ResultSet rs = ps.executeQuery();\n        // ...\n    }\n} ```\nIf the underlying database user has access to multiple catalogs (for example, one per tenant), an attacker can supply another tenant's catalog name (or guess other internal catalogs) and read or modify data that should not be available to them.\nTo remediate this issue, ensure that the catalog is never directly controlled by untrusted input. Instead:\n1. **Do not accept arbitrary catalog names from clients.**\n  Determine the catalog on the server side based on:\n  - The authenticated user/tenant, and/or\n  - Static configuration (e.g., per-environment settings), not request parameters.\n\n2. **Use a strict whitelist or mapping.**\n  If you must vary the catalog, map safe, server-side identifiers to catalog names. Never pass raw client-provided strings to `setCatalog`.\n\n3. **Enforce least privilege at the database level.**\n  The DB account used by the application should only have access to the specific catalog(s) it legitimately needs; avoid a single highly privileged account that can access every catalog.\n\nSafer code example (server-side mapping & validation)\n```java // Preconfigured, server-side mapping from tenant ID to allowed catalog private static final Map<String, String> TENANT_CATALOGS = Map.of(\n    \"tenantA\", \"tenant_a_db\",\n    \"tenantB\", \"tenant_b_db\"\n);\npublic void doGet(HttpServletRequest request, HttpServletResponse response)\n        throws SQLException, IOException {\n\n    String tenantId = getAuthenticatedTenantId(request);  // e.g., from session/JWT\n\n    String catalog = TENANT_CATALOGS.get(tenantId);\n    if (catalog == null) {\n        // Unknown or unauthorized tenant; do not proceed\n        response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Unauthorized tenant\");\n        return;\n    }\n\n    try (Connection conn = dataSource.getConnection()) {\n        // Safe: catalog comes from trusted server-side configuration\n        conn.setCatalog(catalog);\n\n        try (PreparedStatement ps = conn.prepareStatement(\n                \"SELECT id, email FROM users WHERE id = ?\")) {\n            ps.setInt(1, Integer.parseInt(request.getParameter(\"id\")));\n            ResultSet rs = ps.executeQuery();\n            // ...\n        }\n    }\n}\nprivate String getAuthenticatedTenantId(HttpServletRequest request) {\n    // Implementation-specific: derive from authentication/authorization context\n    return (String) request.getAttribute(\"tenantId\");\n} ```"
              },
              "id": "java.security.sql-catalog-external-manipulation-in-servlet-app",
              "name": "java.security.sql-catalog-external-manipulation-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-15"
                ]
              },
              "shortDescription": {
                "text": "External control of SQL catalog selection"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "MongoDB `$where` injection in Java is a form of NoSQL injection that occurs when\nuntrusted user input is concatenated into a `$where` clause (server-side JavaScript)\nand sent to MongoDB. Because `$where` executes JavaScript on the database server,\nan attacker who controls any part of that expression can inject arbitrary JavaScript,\nbypass authentication/authorization checks, read or modify data, or cause denial of service.\n\nVulnerable code sample\n\n```java\nimport com.mongodb.DB;\nimport com.mongodb.DBCollection;\nimport com.mongodb.DBCursor;\nimport com.mongodb.DBObject;\nimport com.mongodb.BasicDBObject;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class LoginService {\n\n    private final DB db;\n\n    public LoginService(DB db) {\n        this.db = db;\n    }\n\n    public boolean login(HttpServletRequest request) {\n        String username = request.getParameter(\"username\");  // untrusted input\n        String password = request.getParameter(\"password\");  // untrusted input\n\n        DBCollection users = db.getCollection(\"users\");\n\n        // VULNERABLE: user input is concatenated into a $where JavaScript expression\n        String whereClause =\n                \"this.username == '\" + username + \"' && this.password == '\" + password + \"'\";\n\n        DBObject query = new BasicDBObject(\"$where\", whereClause);\n\n        DBCursor cursor = users.find(query);\n        return cursor.hasNext();\n    }\n}\n```\n\nIn this example, an attacker can craft `username` or `password` so that the resulting\n`whereClause` becomes malicious JavaScript executed by MongoDB.\n\nTo remediate this issue, avoid using `$where` with string concatenation altogether and always treat\nuser input as data, not code. Use standard field-based queries and parameterization instead of embedding\nuser input into JavaScript expressions. Where possible, disable server‑side JavaScript in MongoDB\nand apply normal secure coding practices (validation, least privilege, hashed passwords, etc.).\n\nA safer version of the same logic using field-based queries:\n\n```java\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.model.Filters;\nimport org.bson.Document;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class SafeLoginService {\n\n    private final MongoDatabase db;\n\n    public SafeLoginService(MongoDatabase db) {\n        this.db = db;\n    }\n\n    public boolean login(HttpServletRequest request) {\n        String username = request.getParameter(\"username\");  // still untrusted\n        String password = request.getParameter(\"password\");  // still untrusted\n\n        MongoCollection<Document> users = db.getCollection(\"users\");\n\n        // SAFE: user input is bound as values, not executed as code\n        Document user = users.find(\n                Filters.and(\n                        Filters.eq(\"username\", username),\n                        Filters.eq(\"password\", password) // in reality, compare password hashes\n                )\n        ).first();\n\n        return user != null;\n    }\n}\n```\n\nKey remediation steps:\n- Do not use `$where` with dynamic strings built from user input.\n- Use field-based queries (`Filters.eq`, `Filters.and`, `new Document(\"field\", value)`, etc.).\n- If you must use `$where`, never concatenate raw user input; use strict whitelisting and controlled templates (but prefer avoiding `$where` completely).\n- Configure MongoDB to restrict or disable server-side JavaScript where feasible.",
                "text": "MongoDB `$where` injection in Java is a form of NoSQL injection that occurs when\nuntrusted user input is concatenated into a `$where` clause (server-side JavaScript)\nand sent to MongoDB. Because `$where` executes JavaScript on the database server,\nan attacker who controls any part of that expression can inject arbitrary JavaScript,\nbypass authentication/authorization checks, read or modify data, or cause denial of service.\n\nVulnerable code sample\n\n```java\nimport com.mongodb.DB;\nimport com.mongodb.DBCollection;\nimport com.mongodb.DBCursor;\nimport com.mongodb.DBObject;\nimport com.mongodb.BasicDBObject;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class LoginService {\n\n    private final DB db;\n\n    public LoginService(DB db) {\n        this.db = db;\n    }\n\n    public boolean login(HttpServletRequest request) {\n        String username = request.getParameter(\"username\");  // untrusted input\n        String password = request.getParameter(\"password\");  // untrusted input\n\n        DBCollection users = db.getCollection(\"users\");\n\n        // VULNERABLE: user input is concatenated into a $where JavaScript expression\n        String whereClause =\n                \"this.username == '\" + username + \"' && this.password == '\" + password + \"'\";\n\n        DBObject query = new BasicDBObject(\"$where\", whereClause);\n\n        DBCursor cursor = users.find(query);\n        return cursor.hasNext();\n    }\n}\n```\n\nIn this example, an attacker can craft `username` or `password` so that the resulting\n`whereClause` becomes malicious JavaScript executed by MongoDB.\n\nTo remediate this issue, avoid using `$where` with string concatenation altogether and always treat\nuser input as data, not code. Use standard field-based queries and parameterization instead of embedding\nuser input into JavaScript expressions. Where possible, disable server‑side JavaScript in MongoDB\nand apply normal secure coding practices (validation, least privilege, hashed passwords, etc.).\n\nA safer version of the same logic using field-based queries:\n\n```java\nimport com.mongodb.client.MongoCollection;\nimport com.mongodb.client.MongoDatabase;\nimport com.mongodb.client.model.Filters;\nimport org.bson.Document;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class SafeLoginService {\n\n    private final MongoDatabase db;\n\n    public SafeLoginService(MongoDatabase db) {\n        this.db = db;\n    }\n\n    public boolean login(HttpServletRequest request) {\n        String username = request.getParameter(\"username\");  // still untrusted\n        String password = request.getParameter(\"password\");  // still untrusted\n\n        MongoCollection<Document> users = db.getCollection(\"users\");\n\n        // SAFE: user input is bound as values, not executed as code\n        Document user = users.find(\n                Filters.and(\n                        Filters.eq(\"username\", username),\n                        Filters.eq(\"password\", password) // in reality, compare password hashes\n                )\n        ).first();\n\n        return user != null;\n    }\n}\n```\n\nKey remediation steps:\n- Do not use `$where` with dynamic strings built from user input.\n- Use field-based queries (`Filters.eq`, `Filters.and`, `new Document(\"field\", value)`, etc.).\n- If you must use `$where`, never concatenate raw user input; use strict whitelisting and controlled templates (but prefer avoiding `$where` completely).\n- Configure MongoDB to restrict or disable server-side JavaScript where feasible."
              },
              "id": "java.security.mongodb-injection-in-servlet-app",
              "name": "java.security.mongodb-injection-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-943"
                ]
              },
              "shortDescription": {
                "text": "MongoDB query injection"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "When untrusted data is passed into `java.sql.Connection.setCatalog(String)` in a Spring application (e.g., from a controller parameter), an attacker can influence which database/catalog the application uses for subsequent queries. In multi-tenant or multi-schema Spring setups, this may allow a user to switch to another tenant's catalog, bypass tenant isolation and authorization checks, and read or modify data belonging to other tenants. This is a form of *external control of system or configuration settings* and is closely related to injection-style vulnerabilities.\nVulnerable code sample\n```java @RestController @RequestMapping(\"/users\") public class UserController {\n\n    private final DataSource dataSource;\n\n    public UserController(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    // Example request: GET /users?catalog=other_tenant_db&id=1\n    @GetMapping\n    public List<User> getUsers(\n            @RequestParam String catalog,\n            @RequestParam int id) throws SQLException {\n\n        Connection conn = DataSourceUtils.getConnection(dataSource);\n        try {\n            // VULNERABLE: user controls the active catalog\n            conn.setCatalog(catalog);\n\n            try (PreparedStatement ps = conn.prepareStatement(\n                    \"SELECT id, email FROM users WHERE id = ?\")) {\n                ps.setInt(1, id);\n                try (ResultSet rs = ps.executeQuery()) {\n                    List<User> result = new ArrayList<>();\n                    while (rs.next()) {\n                        User u = new User();\n                        u.setId(rs.getInt(\"id\"));\n                        u.setEmail(rs.getString(\"email\"));\n                        result.add(u);\n                    }\n                    return result;\n                }\n            }\n        } finally {\n            DataSourceUtils.releaseConnection(conn, dataSource);\n        }\n    }\n} ```\nIf the Spring application's database account has access to multiple catalogs, a malicious client can pass another catalog name via `catalog` and access or modify data in other tenants' databases.\nTo remediate this issue, ensure the catalog is determined exclusively by trusted, server-side logic, not directly from HTTP parameters, headers, or other untrusted input. In Spring applications:\n1. **Do not bind catalog/schema directly from request parameters.**\n  The controller should not have a `@RequestParam catalog` (or equivalent) that is passed into `setCatalog`.\n\n2. **Derive tenant/catalog from authentication context.**\n  Use Spring Security to determine the authenticated user/tenant (`Principal`, `@AuthenticationPrincipal`,\n  or a custom `TenantContext`) and map that to an allowed catalog using server-side configuration.\n\n3. **Use a strict whitelist/mapping.**\n  Maintain a fixed mapping on the server between tenant IDs and catalog names; do not use user-supplied strings as catalog names.\n\n4. **Enforce least privilege at the DB level.**\n  Configure the DataSource to connect with a DB user that only has access to the catalogs required for that tenant/application.\n\nSafer code example (Spring MVC with tenant → catalog mapping)\n```java @Component public class TenantCatalogResolver {\n\n    // Server-side, trusted mapping\n    private static final Map<String, String> TENANT_TO_CATALOG = Map.of(\n        \"tenantA\", \"tenant_a_db\",\n        \"tenantB\", \"tenant_b_db\"\n    );\n\n    public String resolveCatalogForTenant(String tenantId) {\n        String catalog = TENANT_TO_CATALOG.get(tenantId);\n        if (catalog == null) {\n            throw new IllegalArgumentException(\"Unknown tenant: \" + tenantId);\n        }\n        return catalog;\n    }\n}\n@RestController @RequestMapping(\"/users\") public class SafeUserController {\n\n    private final DataSource dataSource;\n    private final TenantCatalogResolver tenantCatalogResolver;\n\n    public SafeUserController(DataSource dataSource,\n                              TenantCatalogResolver tenantCatalogResolver) {\n        this.dataSource = dataSource;\n        this.tenantCatalogResolver = tenantCatalogResolver;\n    }\n\n    @GetMapping\n    public List<User> getUsers(\n            @RequestParam int id,\n            @AuthenticationPrincipal CustomUserDetails userDetails) throws SQLException {\n\n        String tenantId = userDetails.getTenantId(); // from Spring Security\n        String catalog = tenantCatalogResolver.resolveCatalogForTenant(tenantId);\n\n        Connection conn = DataSourceUtils.getConnection(dataSource);\n        try {\n            // Safe: catalog comes from trusted, server-side mapping\n            conn.setCatalog(catalog);\n\n            try (PreparedStatement ps = conn.prepareStatement(\n                    \"SELECT id, email FROM users WHERE id = ?\")) {\n                ps.setInt(1, id);\n                try (ResultSet rs = ps.executeQuery()) {\n                    List<User> result = new ArrayList<>();\n                    while (rs.next()) {\n                        User u = new User();\n                        u.setId(rs.getInt(\"id\"));\n                        u.setEmail(rs.getString(\"email\"));\n                        result.add(u);\n                    }\n                    return result;\n                }\n            }\n        } finally {\n            DataSourceUtils.releaseConnection(conn, dataSource);\n        }\n    }\n} ```\nIn more advanced Spring setups, you can also implement multi-tenancy by using `AbstractRoutingDataSource` or a similar mechanism, where routing is based on a trusted `TenantContext` and **not** on raw HTTP input.",
                "text": "When untrusted data is passed into `java.sql.Connection.setCatalog(String)` in a Spring application (e.g., from a controller parameter), an attacker can influence which database/catalog the application uses for subsequent queries. In multi-tenant or multi-schema Spring setups, this may allow a user to switch to another tenant's catalog, bypass tenant isolation and authorization checks, and read or modify data belonging to other tenants. This is a form of *external control of system or configuration settings* and is closely related to injection-style vulnerabilities.\nVulnerable code sample\n```java @RestController @RequestMapping(\"/users\") public class UserController {\n\n    private final DataSource dataSource;\n\n    public UserController(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    // Example request: GET /users?catalog=other_tenant_db&id=1\n    @GetMapping\n    public List<User> getUsers(\n            @RequestParam String catalog,\n            @RequestParam int id) throws SQLException {\n\n        Connection conn = DataSourceUtils.getConnection(dataSource);\n        try {\n            // VULNERABLE: user controls the active catalog\n            conn.setCatalog(catalog);\n\n            try (PreparedStatement ps = conn.prepareStatement(\n                    \"SELECT id, email FROM users WHERE id = ?\")) {\n                ps.setInt(1, id);\n                try (ResultSet rs = ps.executeQuery()) {\n                    List<User> result = new ArrayList<>();\n                    while (rs.next()) {\n                        User u = new User();\n                        u.setId(rs.getInt(\"id\"));\n                        u.setEmail(rs.getString(\"email\"));\n                        result.add(u);\n                    }\n                    return result;\n                }\n            }\n        } finally {\n            DataSourceUtils.releaseConnection(conn, dataSource);\n        }\n    }\n} ```\nIf the Spring application's database account has access to multiple catalogs, a malicious client can pass another catalog name via `catalog` and access or modify data in other tenants' databases.\nTo remediate this issue, ensure the catalog is determined exclusively by trusted, server-side logic, not directly from HTTP parameters, headers, or other untrusted input. In Spring applications:\n1. **Do not bind catalog/schema directly from request parameters.**\n  The controller should not have a `@RequestParam catalog` (or equivalent) that is passed into `setCatalog`.\n\n2. **Derive tenant/catalog from authentication context.**\n  Use Spring Security to determine the authenticated user/tenant (`Principal`, `@AuthenticationPrincipal`,\n  or a custom `TenantContext`) and map that to an allowed catalog using server-side configuration.\n\n3. **Use a strict whitelist/mapping.**\n  Maintain a fixed mapping on the server between tenant IDs and catalog names; do not use user-supplied strings as catalog names.\n\n4. **Enforce least privilege at the DB level.**\n  Configure the DataSource to connect with a DB user that only has access to the catalogs required for that tenant/application.\n\nSafer code example (Spring MVC with tenant → catalog mapping)\n```java @Component public class TenantCatalogResolver {\n\n    // Server-side, trusted mapping\n    private static final Map<String, String> TENANT_TO_CATALOG = Map.of(\n        \"tenantA\", \"tenant_a_db\",\n        \"tenantB\", \"tenant_b_db\"\n    );\n\n    public String resolveCatalogForTenant(String tenantId) {\n        String catalog = TENANT_TO_CATALOG.get(tenantId);\n        if (catalog == null) {\n            throw new IllegalArgumentException(\"Unknown tenant: \" + tenantId);\n        }\n        return catalog;\n    }\n}\n@RestController @RequestMapping(\"/users\") public class SafeUserController {\n\n    private final DataSource dataSource;\n    private final TenantCatalogResolver tenantCatalogResolver;\n\n    public SafeUserController(DataSource dataSource,\n                              TenantCatalogResolver tenantCatalogResolver) {\n        this.dataSource = dataSource;\n        this.tenantCatalogResolver = tenantCatalogResolver;\n    }\n\n    @GetMapping\n    public List<User> getUsers(\n            @RequestParam int id,\n            @AuthenticationPrincipal CustomUserDetails userDetails) throws SQLException {\n\n        String tenantId = userDetails.getTenantId(); // from Spring Security\n        String catalog = tenantCatalogResolver.resolveCatalogForTenant(tenantId);\n\n        Connection conn = DataSourceUtils.getConnection(dataSource);\n        try {\n            // Safe: catalog comes from trusted, server-side mapping\n            conn.setCatalog(catalog);\n\n            try (PreparedStatement ps = conn.prepareStatement(\n                    \"SELECT id, email FROM users WHERE id = ?\")) {\n                ps.setInt(1, id);\n                try (ResultSet rs = ps.executeQuery()) {\n                    List<User> result = new ArrayList<>();\n                    while (rs.next()) {\n                        User u = new User();\n                        u.setId(rs.getInt(\"id\"));\n                        u.setEmail(rs.getString(\"email\"));\n                        result.add(u);\n                    }\n                    return result;\n                }\n            }\n        } finally {\n            DataSourceUtils.releaseConnection(conn, dataSource);\n        }\n    }\n} ```\nIn more advanced Spring setups, you can also implement multi-tenancy by using `AbstractRoutingDataSource` or a similar mechanism, where routing is based on a trusted `TenantContext` and **not** on raw HTTP input."
              },
              "id": "java.security.sql-catalog-external-manipulation-in-spring-app",
              "name": "java.security.sql-catalog-external-manipulation-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-15"
                ]
              },
              "shortDescription": {
                "text": "External control of SQL catalog selection"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Found object deserialization using ObjectInputStream with user-controlled input. Deserialization of entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences.",
                "text": "Found object deserialization using ObjectInputStream with user-controlled input. Deserialization of entire Java objects is dangerous because malicious actors can create Java object streams with unintended consequences."
              },
              "id": "java.security.unsafe-object-mapper-in-servlet-app",
              "name": "java.security.unsafe-object-mapper-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-502"
                ]
              },
              "shortDescription": {
                "text": "Deserialization of untrusted data with ObjectMapper"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Seam's Logging API integrates with Java Expression Language (EL) so that any `#{...}`\nfound in log messages is evaluated against the Seam/JSF context before being written.\nIf user-controlled data is allowed to influence those expressions (or is concatenated inside `#{...}`),\nan attacker can inject arbitrary EL. This can lead to unauthorized data access, privilege escalation,\nor even remote code execution, depending on the available EL functions and Seam components.\n\nWhen developers assume that `log.info(\"...\")` just writes a literal string—without realizing that `#{}`\nis interpreted as EL—any untrusted input included inside or affecting `#{...}` can become an\nexpression language injection point.\n\n---\n\n**Vulnerable code sample**\n\n```java\nimport org.jboss.seam.annotations.Name;\nimport org.jboss.seam.log.Log;\nimport org.jboss.seam.log.Logging;\n\nimport javax.faces.context.FacesContext;\nimport java.util.Map;\n\n@Name(\"loginAction\")\npublic class LoginAction {\n\n    private static final Log log = Logging.getLog(LoginAction.class);\n\n    public void login() {\n        Map<String, String> params = FacesContext.getCurrentInstance()\n                .getExternalContext()\n                .getRequestParameterMap();\n\n        // Attacker controls the \"username\" request parameter\n        String username = params.get(\"username\");\n\n        // VULNERABLE: Seam will evaluate anything in #{...} as EL\n        // If \"username\" is something like: \"user} #{someDangerousBean.doSomething()} {\"\n        // the injected expression gets evaluated in the application context.\n        log.info(\"Login failed for user #{\"+ username +\"}\");\n\n        // ... authentication logic ...\n    }\n}\n```\n\n---\n\nTo remediate this issue, avoid evaluating EL on untrusted data and treat log messages as plain text.\nDo not build `#{...}` expressions from user input. Prefer parameterized logging that does **not** invoke EL,\nor escape/strip EL metacharacters if there is any chance they come from untrusted sources.\nIn many cases, the safest approach is to move away from Seam's EL-aware `Log` in favor of standard\nlogging frameworks (e.g., SLF4J + Logback/Log4j2).\n\n**Safer patterns:**\n\n1. **Use Seam's parameterized logging (no EL)**\n\n```java\n// This form uses MessageFormat-style parameters, not EL\nlog.info(\"Login failed for user {0}\", username);\n```\n\n2. **Or use a standard logging framework**\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class LoginAction {\n\n    private static final Logger logger = LoggerFactory.getLogger(LoginAction.class);\n\n    public void login() {\n        Map<String, String> params = FacesContext.getCurrentInstance()\n                .getExternalContext()\n                .getRequestParameterMap();\n\n        String username = params.get(\"username\");\n\n        // SLF4J-style placeholders — no EL evaluation\n        logger.info(\"Login failed for user '{}'\", username);\n\n        // ... authentication logic ...\n    }\n}\n```\n\n3. **Additional defensive steps:**\n\n- Do not construct strings containing `#{` and `}` from untrusted data.\n- If you must log raw user input, treat it as data only:\n  - Sanitize or escape `#`, `{`, and `}` if your logging configuration or any other layer might interpret EL.\n- Consider disabling or avoiding any logging mechanism that evaluates EL at runtime, especially on production systems exposed to untrusted users.\n- Apply general input validation where appropriate, but do not rely on validation alone to prevent EL injection.",
                "text": "Seam's Logging API integrates with Java Expression Language (EL) so that any `#{...}`\nfound in log messages is evaluated against the Seam/JSF context before being written.\nIf user-controlled data is allowed to influence those expressions (or is concatenated inside `#{...}`),\nan attacker can inject arbitrary EL. This can lead to unauthorized data access, privilege escalation,\nor even remote code execution, depending on the available EL functions and Seam components.\n\nWhen developers assume that `log.info(\"...\")` just writes a literal string—without realizing that `#{}`\nis interpreted as EL—any untrusted input included inside or affecting `#{...}` can become an\nexpression language injection point.\n\n---\n\n**Vulnerable code sample**\n\n```java\nimport org.jboss.seam.annotations.Name;\nimport org.jboss.seam.log.Log;\nimport org.jboss.seam.log.Logging;\n\nimport javax.faces.context.FacesContext;\nimport java.util.Map;\n\n@Name(\"loginAction\")\npublic class LoginAction {\n\n    private static final Log log = Logging.getLog(LoginAction.class);\n\n    public void login() {\n        Map<String, String> params = FacesContext.getCurrentInstance()\n                .getExternalContext()\n                .getRequestParameterMap();\n\n        // Attacker controls the \"username\" request parameter\n        String username = params.get(\"username\");\n\n        // VULNERABLE: Seam will evaluate anything in #{...} as EL\n        // If \"username\" is something like: \"user} #{someDangerousBean.doSomething()} {\"\n        // the injected expression gets evaluated in the application context.\n        log.info(\"Login failed for user #{\"+ username +\"}\");\n\n        // ... authentication logic ...\n    }\n}\n```\n\n---\n\nTo remediate this issue, avoid evaluating EL on untrusted data and treat log messages as plain text.\nDo not build `#{...}` expressions from user input. Prefer parameterized logging that does **not** invoke EL,\nor escape/strip EL metacharacters if there is any chance they come from untrusted sources.\nIn many cases, the safest approach is to move away from Seam's EL-aware `Log` in favor of standard\nlogging frameworks (e.g., SLF4J + Logback/Log4j2).\n\n**Safer patterns:**\n\n1. **Use Seam's parameterized logging (no EL)**\n\n```java\n// This form uses MessageFormat-style parameters, not EL\nlog.info(\"Login failed for user {0}\", username);\n```\n\n2. **Or use a standard logging framework**\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class LoginAction {\n\n    private static final Logger logger = LoggerFactory.getLogger(LoginAction.class);\n\n    public void login() {\n        Map<String, String> params = FacesContext.getCurrentInstance()\n                .getExternalContext()\n                .getRequestParameterMap();\n\n        String username = params.get(\"username\");\n\n        // SLF4J-style placeholders — no EL evaluation\n        logger.info(\"Login failed for user '{}'\", username);\n\n        // ... authentication logic ...\n    }\n}\n```\n\n3. **Additional defensive steps:**\n\n- Do not construct strings containing `#{` and `}` from untrusted data.\n- If you must log raw user input, treat it as data only:\n  - Sanitize or escape `#`, `{`, and `}` if your logging configuration or any other layer might interpret EL.\n- Consider disabling or avoiding any logging mechanism that evaluates EL at runtime, especially on production systems exposed to untrusted users.\n- Apply general input validation where appropriate, but do not rely on validation alone to prevent EL injection."
              },
              "id": "java.security.seam-log-injection",
              "name": "java.security.seam-log-injection",
              "properties": {
                "tags": [
                  "CWE-95"
                ]
              },
              "shortDescription": {
                "text": "Potential injection of unwanted Seam Logging API expression language"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "OGNL (Object-Graph Navigation Language) injection is a type of expression-language injection\nvulnerability where untrusted user input is evaluated as an OGNL expression on the server.\nOGNL is powerful and can access object properties, call methods, and instantiate classes;\nwhen attackers can influence OGNL expressions, they may achieve remote code execution (RCE),\nread or modify sensitive data, or bypass access controls. This vulnerability has historically\naffected frameworks such as Apache Struts 2 that use OGNL for data binding and expression\nevaluation in views and configuration.\n\nVulnerable code sample:\n\n```java\nimport ognl.Ognl;\nimport ognl.OgnlContext;\n\npublic class OgnlController {\n\n    public Object evaluateExpression(javax.servlet.http.HttpServletRequest request) throws Exception {\n        // Attacker controls the \"expr\" parameter\n        String expr = request.getParameter(\"expr\");\n\n        // Build OGNL context from application objects\n        OgnlContext context = new OgnlContext();\n        context.put(\"userService\", new UserService());\n        context.put(\"system\", java.lang.System.class);\n\n        // VULNERABLE: evaluating untrusted input as an OGNL expression\n        Object value = Ognl.getValue(expr, context, context.getRoot());\n\n        return value; // result potentially exposed to the client\n    }\n}\n```\n\nIn a Struts 2 application, a similar problem can occur when user-controllable data ends up\nin OGNL-evaluated attributes (e.g., misconfigured tags, parameters bound directly to OGNL\nexpressions in XML or JSPs).\n\nTo remediate this issue, never evaluate OGNL (or any expression language) on untrusted input,\nand ensure the framework is configured and updated to prevent such evaluation paths.\n\nKey steps:\n- Upgrade to the latest secure version of frameworks using OGNL (e.g., latest Struts 2 with\n  all OGNL-related security patches).\n- Disable or restrict dynamic method invocation and other features that expand the OGNL attack surface.\n- Avoid building OGNL expressions from request parameters or any user-controlled data.\n- Use strict input binding/whitelisting for parameters and models rather than generic expression evaluation.\n- Enforce strong input validation and encoding, but do not rely on it alone to secure expression evaluation.\n\nSafer approach (do not evaluate arbitrary OGNL; map user input to allowed operations):\n\n```java\npublic class SafeController {\n\n    private final UserService userService = new UserService();\n\n    public Object handleRequest(javax.servlet.http.HttpServletRequest request) {\n        String action = request.getParameter(\"action\");\n\n        // Whitelist of allowed actions; no OGNL evaluation\n        if (\"getProfile\".equals(action)) {\n            String userId = request.getParameter(\"userId\");\n            return userService.getProfile(userId);\n        } else if (\"listUsers\".equals(action)) {\n            return userService.listUsers();\n        } else {\n            throw new IllegalArgumentException(\"Unsupported action\");\n        }\n    }\n}\n```\n\nIn Struts 2, prefer:\n- Standard action properties and setters (no dynamic expressions built from user input).\n- Secure configuration (e.g., `struts2.allowed.action.names`, disabling `dynamicMethodInvocation`,\n  using “strict method invocation” and secure tag usage).",
                "text": "OGNL (Object-Graph Navigation Language) injection is a type of expression-language injection\nvulnerability where untrusted user input is evaluated as an OGNL expression on the server.\nOGNL is powerful and can access object properties, call methods, and instantiate classes;\nwhen attackers can influence OGNL expressions, they may achieve remote code execution (RCE),\nread or modify sensitive data, or bypass access controls. This vulnerability has historically\naffected frameworks such as Apache Struts 2 that use OGNL for data binding and expression\nevaluation in views and configuration.\n\nVulnerable code sample:\n\n```java\nimport ognl.Ognl;\nimport ognl.OgnlContext;\n\npublic class OgnlController {\n\n    public Object evaluateExpression(javax.servlet.http.HttpServletRequest request) throws Exception {\n        // Attacker controls the \"expr\" parameter\n        String expr = request.getParameter(\"expr\");\n\n        // Build OGNL context from application objects\n        OgnlContext context = new OgnlContext();\n        context.put(\"userService\", new UserService());\n        context.put(\"system\", java.lang.System.class);\n\n        // VULNERABLE: evaluating untrusted input as an OGNL expression\n        Object value = Ognl.getValue(expr, context, context.getRoot());\n\n        return value; // result potentially exposed to the client\n    }\n}\n```\n\nIn a Struts 2 application, a similar problem can occur when user-controllable data ends up\nin OGNL-evaluated attributes (e.g., misconfigured tags, parameters bound directly to OGNL\nexpressions in XML or JSPs).\n\nTo remediate this issue, never evaluate OGNL (or any expression language) on untrusted input,\nand ensure the framework is configured and updated to prevent such evaluation paths.\n\nKey steps:\n- Upgrade to the latest secure version of frameworks using OGNL (e.g., latest Struts 2 with\n  all OGNL-related security patches).\n- Disable or restrict dynamic method invocation and other features that expand the OGNL attack surface.\n- Avoid building OGNL expressions from request parameters or any user-controlled data.\n- Use strict input binding/whitelisting for parameters and models rather than generic expression evaluation.\n- Enforce strong input validation and encoding, but do not rely on it alone to secure expression evaluation.\n\nSafer approach (do not evaluate arbitrary OGNL; map user input to allowed operations):\n\n```java\npublic class SafeController {\n\n    private final UserService userService = new UserService();\n\n    public Object handleRequest(javax.servlet.http.HttpServletRequest request) {\n        String action = request.getParameter(\"action\");\n\n        // Whitelist of allowed actions; no OGNL evaluation\n        if (\"getProfile\".equals(action)) {\n            String userId = request.getParameter(\"userId\");\n            return userService.getProfile(userId);\n        } else if (\"listUsers\".equals(action)) {\n            return userService.listUsers();\n        } else {\n            throw new IllegalArgumentException(\"Unsupported action\");\n        }\n    }\n}\n```\n\nIn Struts 2, prefer:\n- Standard action properties and setters (no dynamic expressions built from user input).\n- Secure configuration (e.g., `struts2.allowed.action.names`, disabling `dynamicMethodInvocation`,\n  using “strict method invocation” and secure tag usage)."
              },
              "id": "java.security.ognl-injection-in-servlet-app",
              "name": "java.security.ognl-injection-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-94"
                ]
              },
              "shortDescription": {
                "text": "OGNL expression construction from user-controlled input"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Injection into `javax.script.ScriptEngine` occurs when untrusted input is evaluated as code by a\nJava Scripting Engine (e.g., Nashorn, JavaScript, etc.).\nIf attacker-controlled data is passed directly to `ScriptEngine.eval()` (or similar methods),\nan attacker can execute arbitrary script code in the context of the application's JVM.\nThis can lead to data exfiltration, privilege escalation, or full remote code execution,\ndepending on what the script engine can access (e.g., Java classes, filesystem, network, environment variables).\n\n```java\n// Vulnerable code sample\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\nimport javax.servlet.http.HttpServletRequest;\n\npublic class ScriptEvaluator {\n\n    public Object evaluateExpression(HttpServletRequest request) throws ScriptException {\n        // Attacker controls this parameter (e.g., ?expr=...)\n        String expr = request.getParameter(\"expr\");\n\n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"javascript\"); // or \"nashorn\", \"groovy\", etc.\n\n        // VULNERABLE: directly evaluates attacker-controlled code\n        return engine.eval(expr);\n    }\n}\n```\n\nTo remediate this issue, do not execute untrusted input as script code. Treat user input strictly\nas data, not as instructions. Where scripting is necessary:\n\n1. **Avoid passing user input into `eval`-like APIs as code.**\n  - If you only need to support simple operations (e.g., arithmetic), implement or use a dedicated\n    expression parser that does not allow arbitrary function calls or access to the underlying JVM.\n  - Never let the user control full script bodies, function definitions, or arbitrary expressions\n    that the engine will execute.\n\n2. **Use static scripts and bindings for data.**\n  Define the script code in your application (trusted), and pass user input only as variables/bindings:\n\n```java\nimport javax.script.*;\n\npublic class SafeScriptEvaluator {\n\n    private final ScriptEngine engine;\n    private final CompiledScript compiled; // optional, but more efficient and safer pattern\n\n    public SafeScriptEvaluator() throws ScriptException {\n        ScriptEngineManager manager = new ScriptEngineManager();\n        this.engine = manager.getEngineByName(\"javascript\");\n\n        // Trusted, static script embedded in the application\n        String script = \"function calculate(a, b) { return a + b; } \" +\n                        \"calculate(a, b);\";\n\n        this.compiled = ((Compilable) engine).compile(script);\n    }\n\n    public Object safeEvaluate(int a, int b) throws ScriptException {\n        Bindings bindings = engine.createBindings();\n        bindings.put(\"a\", a);   // user input as data\n        bindings.put(\"b\", b);   // user input as data\n\n        // Only the trusted script runs; user data cannot change the code\n        return compiled.eval(bindings);\n    }\n}\n```\n\n3. **Restrict the script engine's capabilities (sandboxing), if supported.**\n  - Disable or strictly limit access to `Java.type`, reflection, file I/O, process execution,\n    and network APIs from within the script.\n  - Run script engines in a constrained environment (e.g., separate process/container, or with\n    appropriate security manager / policy, if available).\n\n4. **Validate and constrain inputs on a strict allowlist.**\n  - If you must accept some form of “expression” from users, define a grammar or a very narrow\n    allowed syntax and reject anything outside that set.\n  - Do not assume that “it's just math” is safe; enforce it programmatically.",
                "text": "Injection into `javax.script.ScriptEngine` occurs when untrusted input is evaluated as code by a\nJava Scripting Engine (e.g., Nashorn, JavaScript, etc.).\nIf attacker-controlled data is passed directly to `ScriptEngine.eval()` (or similar methods),\nan attacker can execute arbitrary script code in the context of the application's JVM.\nThis can lead to data exfiltration, privilege escalation, or full remote code execution,\ndepending on what the script engine can access (e.g., Java classes, filesystem, network, environment variables).\n\n```java\n// Vulnerable code sample\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\nimport javax.servlet.http.HttpServletRequest;\n\npublic class ScriptEvaluator {\n\n    public Object evaluateExpression(HttpServletRequest request) throws ScriptException {\n        // Attacker controls this parameter (e.g., ?expr=...)\n        String expr = request.getParameter(\"expr\");\n\n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"javascript\"); // or \"nashorn\", \"groovy\", etc.\n\n        // VULNERABLE: directly evaluates attacker-controlled code\n        return engine.eval(expr);\n    }\n}\n```\n\nTo remediate this issue, do not execute untrusted input as script code. Treat user input strictly\nas data, not as instructions. Where scripting is necessary:\n\n1. **Avoid passing user input into `eval`-like APIs as code.**\n  - If you only need to support simple operations (e.g., arithmetic), implement or use a dedicated\n    expression parser that does not allow arbitrary function calls or access to the underlying JVM.\n  - Never let the user control full script bodies, function definitions, or arbitrary expressions\n    that the engine will execute.\n\n2. **Use static scripts and bindings for data.**\n  Define the script code in your application (trusted), and pass user input only as variables/bindings:\n\n```java\nimport javax.script.*;\n\npublic class SafeScriptEvaluator {\n\n    private final ScriptEngine engine;\n    private final CompiledScript compiled; // optional, but more efficient and safer pattern\n\n    public SafeScriptEvaluator() throws ScriptException {\n        ScriptEngineManager manager = new ScriptEngineManager();\n        this.engine = manager.getEngineByName(\"javascript\");\n\n        // Trusted, static script embedded in the application\n        String script = \"function calculate(a, b) { return a + b; } \" +\n                        \"calculate(a, b);\";\n\n        this.compiled = ((Compilable) engine).compile(script);\n    }\n\n    public Object safeEvaluate(int a, int b) throws ScriptException {\n        Bindings bindings = engine.createBindings();\n        bindings.put(\"a\", a);   // user input as data\n        bindings.put(\"b\", b);   // user input as data\n\n        // Only the trusted script runs; user data cannot change the code\n        return compiled.eval(bindings);\n    }\n}\n```\n\n3. **Restrict the script engine's capabilities (sandboxing), if supported.**\n  - Disable or strictly limit access to `Java.type`, reflection, file I/O, process execution,\n    and network APIs from within the script.\n  - Run script engines in a constrained environment (e.g., separate process/container, or with\n    appropriate security manager / policy, if available).\n\n4. **Validate and constrain inputs on a strict allowlist.**\n  - If you must accept some form of “expression” from users, define a grammar or a very narrow\n    allowed syntax and reject anything outside that set.\n  - Do not assume that “it's just math” is safe; enforce it programmatically."
              },
              "id": "java.security.script-engine-injection-in-servlet-app",
              "name": "java.security.script-engine-injection-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-94"
                ]
              },
              "shortDescription": {
                "text": "Injection into javax.script.ScriptEngine"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "SQL injection is a vulnerability where untrusted input is concatenated into SQL queries and\nsent to the database without proper validation or parameterization. In Spring-based applications\n(e.g., Spring MVC + JdbcTemplate or Spring Data/JPA), this typically occurs when request parameters\nor method arguments are directly embedded into SQL or JPQL/HQL strings. An attacker can craft input\nthat alters the query's structure, leading to data theft, data manipulation, or full database compromise.\n\nVulnerable code sample\n\n```java\n// Example: Spring MVC controller using JdbcTemplate insecurely\n\n@RestController\n@RequestMapping(\"/users\")\npublic class UserController {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public UserController(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    @GetMapping(\"/search\")\n    public User getUser(@RequestParam String username) {\n        // Vulnerable: username is concatenated directly into the SQL query\n        String sql = \"SELECT id, username, email FROM users WHERE username = '\" + username + \"'\";\n\n        return jdbcTemplate.queryForObject(\n                sql,\n                (rs, rowNum) -> new User(\n                        rs.getLong(\"id\"),\n                        rs.getString(\"username\"),\n                        rs.getString(\"email\")\n                )\n        );\n    }\n}\n```\n\nTo remediate this issue, always use parameterized queries\n(e.g., `JdbcTemplate` with `?` placeholders, `PreparedStatement`, or Spring Data JPA method queries)\ninstead of string concatenation, and validate input where appropriate. This ensures user input is treated as data, not executable SQL.\n\nSafe code sample using `JdbcTemplate` with parameters:\n\n```java\n@RestController\n@RequestMapping(\"/users\")\npublic class UserController {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public UserController(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    @GetMapping(\"/search\")\n    public User getUser(@RequestParam String username) {\n        // Optional but recommended: validate/normalize input\n        if (username == null || username.isBlank()) {\n            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"Invalid username\");\n        }\n\n        String sql = \"SELECT id, username, email FROM users WHERE username = ?\";\n\n        return jdbcTemplate.queryForObject(\n                sql,\n                new Object[]{username},    // bind parameter\n                (rs, rowNum) -> new User(\n                        rs.getLong(\"id\"),\n                        rs.getString(\"username\"),\n                        rs.getString(\"email\")\n                )\n        );\n    }\n}\n```\n\nSafe code sample using Spring Data JPA (also parameterized under the hood):\n\n```java\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n    // Derived query method — parameters are safely bound\n    Optional<User> findByUsername(String username);\n}\n\n@RestController\n@RequestMapping(\"/users\")\npublic class UserController {\n\n    private final UserRepository userRepository;\n\n    public UserController(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    @GetMapping(\"/search\")\n    public User getUser(@RequestParam String username) {\n        return userRepository.findByUsername(username)\n                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));\n    }\n}\n```\n\nAdditional best practices include using least-privilege database accounts, avoiding dynamic SQL/JPQL when possible, and centralizing data access in repositories or service layers that enforce safe patterns throughout the Spring application.",
                "text": "SQL injection is a vulnerability where untrusted input is concatenated into SQL queries and\nsent to the database without proper validation or parameterization. In Spring-based applications\n(e.g., Spring MVC + JdbcTemplate or Spring Data/JPA), this typically occurs when request parameters\nor method arguments are directly embedded into SQL or JPQL/HQL strings. An attacker can craft input\nthat alters the query's structure, leading to data theft, data manipulation, or full database compromise.\n\nVulnerable code sample\n\n```java\n// Example: Spring MVC controller using JdbcTemplate insecurely\n\n@RestController\n@RequestMapping(\"/users\")\npublic class UserController {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public UserController(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    @GetMapping(\"/search\")\n    public User getUser(@RequestParam String username) {\n        // Vulnerable: username is concatenated directly into the SQL query\n        String sql = \"SELECT id, username, email FROM users WHERE username = '\" + username + \"'\";\n\n        return jdbcTemplate.queryForObject(\n                sql,\n                (rs, rowNum) -> new User(\n                        rs.getLong(\"id\"),\n                        rs.getString(\"username\"),\n                        rs.getString(\"email\")\n                )\n        );\n    }\n}\n```\n\nTo remediate this issue, always use parameterized queries\n(e.g., `JdbcTemplate` with `?` placeholders, `PreparedStatement`, or Spring Data JPA method queries)\ninstead of string concatenation, and validate input where appropriate. This ensures user input is treated as data, not executable SQL.\n\nSafe code sample using `JdbcTemplate` with parameters:\n\n```java\n@RestController\n@RequestMapping(\"/users\")\npublic class UserController {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    public UserController(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    @GetMapping(\"/search\")\n    public User getUser(@RequestParam String username) {\n        // Optional but recommended: validate/normalize input\n        if (username == null || username.isBlank()) {\n            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"Invalid username\");\n        }\n\n        String sql = \"SELECT id, username, email FROM users WHERE username = ?\";\n\n        return jdbcTemplate.queryForObject(\n                sql,\n                new Object[]{username},    // bind parameter\n                (rs, rowNum) -> new User(\n                        rs.getLong(\"id\"),\n                        rs.getString(\"username\"),\n                        rs.getString(\"email\")\n                )\n        );\n    }\n}\n```\n\nSafe code sample using Spring Data JPA (also parameterized under the hood):\n\n```java\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n    // Derived query method — parameters are safely bound\n    Optional<User> findByUsername(String username);\n}\n\n@RestController\n@RequestMapping(\"/users\")\npublic class UserController {\n\n    private final UserRepository userRepository;\n\n    public UserController(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    @GetMapping(\"/search\")\n    public User getUser(@RequestParam String username) {\n        return userRepository.findByUsername(username)\n                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND));\n    }\n}\n```\n\nAdditional best practices include using least-privilege database accounts, avoiding dynamic SQL/JPQL when possible, and centralizing data access in repositories or service layers that enforce safe patterns throughout the Spring application."
              },
              "id": "java.security.sql-injection-in-spring-app",
              "name": "java.security.sql-injection-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-89"
                ]
              },
              "shortDescription": {
                "text": "Potential SQL injection"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Cross-Site Scripting (XSS) is a class of vulnerabilities that allows an attacker to inject malicious\nclient-side code (usually JavaScript) into web pages viewed by other users.\nIn Java servlet applications, this typically occurs when untrusted input\n(e.g., request parameters, headers, form fields, query strings) is included in the HTTP response without proper output encoding.\nAttackers can leverage this to steal session cookies, perform actions on behalf of victims, modify page content,\nor conduct phishing attacks within the trusted site context.\n\n**Vulnerable code sample**\n\n```java\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/greet\")\npublic class GreetingServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        response.setContentType(\"text/html;charset=UTF-8\");\n        PrintWriter out = response.getWriter();\n\n        // Untrusted input taken directly from the request\n        String name = request.getParameter(\"name\");\n\n        // VULNERABLE: Unencoded user input is directly embedded into HTML\n        out.println(\"<html>\");\n        out.println(\"<head><title>Greeting</title></head>\");\n        out.println(\"<body>\");\n        out.println(\"<h1>Hello, \" + name + \"!</h1>\"); // XSS if 'name' contains HTML/JS\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    }\n}\n```\n\nAn attacker could call `/greet?name=<script>alert('XSS')</script>` and the script would execute in the victim's browser.\n\n\nTo remediate this issue, always treat data from the client as untrusted and perform\n**context-appropriate output encoding** before including it in the response.\nFor HTML content, escape characters such as `<`, `>`, `&`, `\"`, `'` so they are rendered as text,\nnot executed as code. Also validate and constrain inputs on the server side to expected formats\n(e.g., names, IDs) and avoid reflecting unnecessary user data.\n\nBelow is a safer version using Apache Commons Text for HTML encoding:\n\n```xml\n<!-- Maven dependency example -->\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-text</artifactId>\n    <version>1.11.0</version>\n</dependency>\n```\n\n```java\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.apache.commons.text.StringEscapeUtils;\n\n@WebServlet(\"/greet\")\npublic class GreetingServletSafe extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        response.setContentType(\"text/html;charset=UTF-8\");\n        PrintWriter out = response.getWriter();\n\n        String name = request.getParameter(\"name\");\n        if (name == null) {\n            name = \"\";\n        }\n\n        // Encode untrusted input for HTML context\n        String safeName = StringEscapeUtils.escapeHtml4(name);\n\n        out.println(\"<html>\");\n        out.println(\"<head><title>Greeting</title></head>\");\n        out.println(\"<body>\");\n        out.println(\"<h1>Hello, \" + safeName + \"!</h1>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    }\n}\n```\n\nKey remediation steps:\n- Encode untrusted data according to the output context:\n  - HTML body → HTML escape\n  - HTML attributes → HTML attribute escape\n  - JavaScript context → JavaScript escape\n  - URL context → URL encode\n- Apply server-side validation and whitelisting of allowed characters/values.\n- Avoid constructing HTML/JavaScript by string concatenation where possible;\n  use safe templating or tag libraries that handle encoding (e.g., JSP `<c:out>`).\n- Use security libraries and frameworks that provide standard encoding utilities.\nreferences:\n  - https://owasp.org/www-community/attacks/xss/\nprovenance:\n- https://github.com/semgrep/semgrep-rules/blob/develop/java/spring/security/injection/tainted-html-string.yaml\n- https://github.com/semgrep/semgrep-rules/blob/develop/java/lang/security/audit/xss/no-direct-response-writer.yaml",
                "text": "Cross-Site Scripting (XSS) is a class of vulnerabilities that allows an attacker to inject malicious\nclient-side code (usually JavaScript) into web pages viewed by other users.\nIn Java servlet applications, this typically occurs when untrusted input\n(e.g., request parameters, headers, form fields, query strings) is included in the HTTP response without proper output encoding.\nAttackers can leverage this to steal session cookies, perform actions on behalf of victims, modify page content,\nor conduct phishing attacks within the trusted site context.\n\n**Vulnerable code sample**\n\n```java\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/greet\")\npublic class GreetingServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        response.setContentType(\"text/html;charset=UTF-8\");\n        PrintWriter out = response.getWriter();\n\n        // Untrusted input taken directly from the request\n        String name = request.getParameter(\"name\");\n\n        // VULNERABLE: Unencoded user input is directly embedded into HTML\n        out.println(\"<html>\");\n        out.println(\"<head><title>Greeting</title></head>\");\n        out.println(\"<body>\");\n        out.println(\"<h1>Hello, \" + name + \"!</h1>\"); // XSS if 'name' contains HTML/JS\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    }\n}\n```\n\nAn attacker could call `/greet?name=<script>alert('XSS')</script>` and the script would execute in the victim's browser.\n\n\nTo remediate this issue, always treat data from the client as untrusted and perform\n**context-appropriate output encoding** before including it in the response.\nFor HTML content, escape characters such as `<`, `>`, `&`, `\"`, `'` so they are rendered as text,\nnot executed as code. Also validate and constrain inputs on the server side to expected formats\n(e.g., names, IDs) and avoid reflecting unnecessary user data.\n\nBelow is a safer version using Apache Commons Text for HTML encoding:\n\n```xml\n<!-- Maven dependency example -->\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-text</artifactId>\n    <version>1.11.0</version>\n</dependency>\n```\n\n```java\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.apache.commons.text.StringEscapeUtils;\n\n@WebServlet(\"/greet\")\npublic class GreetingServletSafe extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        response.setContentType(\"text/html;charset=UTF-8\");\n        PrintWriter out = response.getWriter();\n\n        String name = request.getParameter(\"name\");\n        if (name == null) {\n            name = \"\";\n        }\n\n        // Encode untrusted input for HTML context\n        String safeName = StringEscapeUtils.escapeHtml4(name);\n\n        out.println(\"<html>\");\n        out.println(\"<head><title>Greeting</title></head>\");\n        out.println(\"<body>\");\n        out.println(\"<h1>Hello, \" + safeName + \"!</h1>\");\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    }\n}\n```\n\nKey remediation steps:\n- Encode untrusted data according to the output context:\n  - HTML body → HTML escape\n  - HTML attributes → HTML attribute escape\n  - JavaScript context → JavaScript escape\n  - URL context → URL encode\n- Apply server-side validation and whitelisting of allowed characters/values.\n- Avoid constructing HTML/JavaScript by string concatenation where possible;\n  use safe templating or tag libraries that handle encoding (e.g., JSP `<c:out>`).\n- Use security libraries and frameworks that provide standard encoding utilities.\nreferences:\n  - https://owasp.org/www-community/attacks/xss/\nprovenance:\n- https://github.com/semgrep/semgrep-rules/blob/develop/java/spring/security/injection/tainted-html-string.yaml\n- https://github.com/semgrep/semgrep-rules/blob/develop/java/lang/security/audit/xss/no-direct-response-writer.yaml"
              },
              "id": "java.security.xss-in-servlet-app",
              "name": "java.security.xss-in-servlet-app",
              "properties": {
                "tags": [
                  "CWE-79"
                ]
              },
              "shortDescription": {
                "text": "Potential cross-site scripting (XSS)"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "CRLF (Carriage Return + Line Feed, `\\r\\n`) injection into an SMTP `MimeMessage` occurs when untrusted input is placed directly into email headers (e.g., `Subject`, `To`, `From`, custom headers) without properly validating or stripping newline characters.\n\nBecause SMTP and MIME use `\\r\\n` to separate headers and the message body, an attacker who can inject `\\r\\n` into a header field can prematurely terminate that header and start injecting new headers or even alter the body. This can be abused to:\n\n- Add unintended recipients (`Bcc`, `Cc`, additional `To`).\n- Spoof or modify headers (e.g., `From`, `Reply-To`, `X-...`).\n- Manipulate message content or spam/abuse mail infrastructure.\n\nIn Java, this often happens when using `MimeMessage` (e.g., via Jakarta Mail / JavaMail) with user-supplied values for headers without sanitization, or when bypassing built-in validation by using low-level header methods.\n\n---\n\nVulnerable code sample\n\n```java\npublic void sendEmail(HttpServletRequest request) throws MessagingException {\n    String to = request.getParameter(\"to\");\n    String subject = request.getParameter(\"subject\");\n    String body = request.getParameter(\"message\");\n\n    Session session = getMailSession();\n    MimeMessage message = new MimeMessage(session);\n\n    // User-controlled values, no validation\n    message.setFrom(new InternetAddress(\"noreply@example.com\"));\n    message.setRecipient(Message.RecipientType.TO, new InternetAddress(to));\n\n    // Vulnerable: subject comes directly from user input\n    // If subject contains \"\\r\\nBcc: victim@example.com\", that may create a new header line\n    message.setHeader(\"Subject\", subject); // bad: manual header setting\n\n    // Also dangerous when using generic headers\n    String trackingId = request.getParameter(\"trackingId\");\n    message.setHeader(\"X-Tracking-Id\", trackingId); // unvalidated header value\n\n    message.setText(body);\n\n    Transport.send(message);\n}\n```\n\nIf an attacker supplies a value like:\n\n```text\nsubject = \"Hello\\r\\nBcc: attacker@example.com\"\n```\n\nand the underlying library does not strip or reject CR/LF characters for that header-setting method, the generated email may contain an injected `Bcc` header, silently copying all messages to the attacker.\n\n---\n\nTo remediate this issue, ensure that any user-controlled input used in email headers is strictly validated and cannot contain CR (`\\r`) or LF (`\\n`) characters, and avoid low-level header methods where safer, higher-level APIs exist.\n\nKey steps:\n\n1. **Disallow CR and LF in header fields**\n  Strip or reject any input that contains `\\r` or `\\n` if it will be used in a header (e.g., `Subject`, `From`, `To`, `Reply-To`, custom `X-*` headers).\n\n2. **Use high-level `MimeMessage` APIs**\n  Prefer methods like `setSubject`, `setFrom`, `setRecipients`, which usually perform syntax checks, instead of `setHeader` / `addHeader` with raw values. Do not manually craft header lines.\n\n3. **Apply strict validation**\n  - For email addresses: validate against a reasonable email regex and/or let `InternetAddress` parse and validate addresses, and reject invalid ones.\n  - For subjects / custom header values: define allowed character sets or patterns (e.g., letters, numbers, spaces, basic punctuation) and reject anything else.\n\n4. **Keep your mail library up to date**\n  Use the latest Jakarta Mail / JavaMail version, as many unsafe behaviors (including header validation) have been tightened over time. But even with updated libraries, you should still validate input.\n\nSafe code sample:\n\n```java\npublic void sendEmail(HttpServletRequest request) throws MessagingException {\n    String toParam = request.getParameter(\"to\");\n    String subjectParam = request.getParameter(\"subject\");\n    String bodyParam = request.getParameter(\"message\");\n    String trackingIdParam = request.getParameter(\"trackingId\");\n\n    // Basic null checks omitted for brevity\n\n    // 1. Validate and sanitize inputs\n\n    // Reject CR and LF in any header-bound fields\n    if (containsCRLF(subjectParam) || containsCRLF(trackingIdParam) || containsCRLF(toParam)) {\n        throw new IllegalArgumentException(\"Invalid input\");\n    }\n\n    // Validate email address format via InternetAddress\n    InternetAddress toAddress;\n    try {\n        toAddress = new InternetAddress(toParam, true); // 'true' for strict validation\n    } catch (AddressException ex) {\n        throw new IllegalArgumentException(\"Invalid recipient address\", ex);\n    }\n\n    // Optionally, normalize subject to a safe subset of characters\n    String safeSubject = subjectParam.replaceAll(\"[\\r\\n]\", \"\").trim();\n\n    // Optionally, validate custom header (e.g., alphanumeric + dash only)\n    String safeTrackingId = trackingIdParam.replaceAll(\"[^A-Za-z0-9\\\\-]\", \"\");\n\n    // 2. Use higher-level MimeMessage APIs\n\n    Session session = getMailSession();\n    MimeMessage message = new MimeMessage(session);\n\n    message.setFrom(new InternetAddress(\"noreply@example.com\"));\n    message.setRecipient(Message.RecipientType.TO, toAddress);\n\n    // Use setSubject, which encodes and validates header correctly\n    message.setSubject(safeSubject, \"UTF-8\");\n\n    // Custom headers: still only after sanitization\n    if (!safeTrackingId.isEmpty()) {\n        message.setHeader(\"X-Tracking-Id\", safeTrackingId);\n    }\n\n    message.setText(bodyParam, \"UTF-8\");\n\n    Transport.send(message);\n}\n\nprivate boolean containsCRLF(String value) {\n    return value != null && (value.indexOf('\\r') >= 0 || value.indexOf('\\n') >= 0);\n}\n```\n\nIn this remediated version:\n\n- All header-bound values are checked for `\\r` and `\\n`.\n- Email address is validated via `InternetAddress`.\n- `setSubject` is used instead of `setHeader(\"Subject\", …)`.\n- Custom header is sanitized to a safe character set before being used.",
                "text": "CRLF (Carriage Return + Line Feed, `\\r\\n`) injection into an SMTP `MimeMessage` occurs when untrusted input is placed directly into email headers (e.g., `Subject`, `To`, `From`, custom headers) without properly validating or stripping newline characters.\n\nBecause SMTP and MIME use `\\r\\n` to separate headers and the message body, an attacker who can inject `\\r\\n` into a header field can prematurely terminate that header and start injecting new headers or even alter the body. This can be abused to:\n\n- Add unintended recipients (`Bcc`, `Cc`, additional `To`).\n- Spoof or modify headers (e.g., `From`, `Reply-To`, `X-...`).\n- Manipulate message content or spam/abuse mail infrastructure.\n\nIn Java, this often happens when using `MimeMessage` (e.g., via Jakarta Mail / JavaMail) with user-supplied values for headers without sanitization, or when bypassing built-in validation by using low-level header methods.\n\n---\n\nVulnerable code sample\n\n```java\npublic void sendEmail(HttpServletRequest request) throws MessagingException {\n    String to = request.getParameter(\"to\");\n    String subject = request.getParameter(\"subject\");\n    String body = request.getParameter(\"message\");\n\n    Session session = getMailSession();\n    MimeMessage message = new MimeMessage(session);\n\n    // User-controlled values, no validation\n    message.setFrom(new InternetAddress(\"noreply@example.com\"));\n    message.setRecipient(Message.RecipientType.TO, new InternetAddress(to));\n\n    // Vulnerable: subject comes directly from user input\n    // If subject contains \"\\r\\nBcc: victim@example.com\", that may create a new header line\n    message.setHeader(\"Subject\", subject); // bad: manual header setting\n\n    // Also dangerous when using generic headers\n    String trackingId = request.getParameter(\"trackingId\");\n    message.setHeader(\"X-Tracking-Id\", trackingId); // unvalidated header value\n\n    message.setText(body);\n\n    Transport.send(message);\n}\n```\n\nIf an attacker supplies a value like:\n\n```text\nsubject = \"Hello\\r\\nBcc: attacker@example.com\"\n```\n\nand the underlying library does not strip or reject CR/LF characters for that header-setting method, the generated email may contain an injected `Bcc` header, silently copying all messages to the attacker.\n\n---\n\nTo remediate this issue, ensure that any user-controlled input used in email headers is strictly validated and cannot contain CR (`\\r`) or LF (`\\n`) characters, and avoid low-level header methods where safer, higher-level APIs exist.\n\nKey steps:\n\n1. **Disallow CR and LF in header fields**\n  Strip or reject any input that contains `\\r` or `\\n` if it will be used in a header (e.g., `Subject`, `From`, `To`, `Reply-To`, custom `X-*` headers).\n\n2. **Use high-level `MimeMessage` APIs**\n  Prefer methods like `setSubject`, `setFrom`, `setRecipients`, which usually perform syntax checks, instead of `setHeader` / `addHeader` with raw values. Do not manually craft header lines.\n\n3. **Apply strict validation**\n  - For email addresses: validate against a reasonable email regex and/or let `InternetAddress` parse and validate addresses, and reject invalid ones.\n  - For subjects / custom header values: define allowed character sets or patterns (e.g., letters, numbers, spaces, basic punctuation) and reject anything else.\n\n4. **Keep your mail library up to date**\n  Use the latest Jakarta Mail / JavaMail version, as many unsafe behaviors (including header validation) have been tightened over time. But even with updated libraries, you should still validate input.\n\nSafe code sample:\n\n```java\npublic void sendEmail(HttpServletRequest request) throws MessagingException {\n    String toParam = request.getParameter(\"to\");\n    String subjectParam = request.getParameter(\"subject\");\n    String bodyParam = request.getParameter(\"message\");\n    String trackingIdParam = request.getParameter(\"trackingId\");\n\n    // Basic null checks omitted for brevity\n\n    // 1. Validate and sanitize inputs\n\n    // Reject CR and LF in any header-bound fields\n    if (containsCRLF(subjectParam) || containsCRLF(trackingIdParam) || containsCRLF(toParam)) {\n        throw new IllegalArgumentException(\"Invalid input\");\n    }\n\n    // Validate email address format via InternetAddress\n    InternetAddress toAddress;\n    try {\n        toAddress = new InternetAddress(toParam, true); // 'true' for strict validation\n    } catch (AddressException ex) {\n        throw new IllegalArgumentException(\"Invalid recipient address\", ex);\n    }\n\n    // Optionally, normalize subject to a safe subset of characters\n    String safeSubject = subjectParam.replaceAll(\"[\\r\\n]\", \"\").trim();\n\n    // Optionally, validate custom header (e.g., alphanumeric + dash only)\n    String safeTrackingId = trackingIdParam.replaceAll(\"[^A-Za-z0-9\\\\-]\", \"\");\n\n    // 2. Use higher-level MimeMessage APIs\n\n    Session session = getMailSession();\n    MimeMessage message = new MimeMessage(session);\n\n    message.setFrom(new InternetAddress(\"noreply@example.com\"));\n    message.setRecipient(Message.RecipientType.TO, toAddress);\n\n    // Use setSubject, which encodes and validates header correctly\n    message.setSubject(safeSubject, \"UTF-8\");\n\n    // Custom headers: still only after sanitization\n    if (!safeTrackingId.isEmpty()) {\n        message.setHeader(\"X-Tracking-Id\", safeTrackingId);\n    }\n\n    message.setText(bodyParam, \"UTF-8\");\n\n    Transport.send(message);\n}\n\nprivate boolean containsCRLF(String value) {\n    return value != null && (value.indexOf('\\r') >= 0 || value.indexOf('\\n') >= 0);\n}\n```\n\nIn this remediated version:\n\n- All header-bound values are checked for `\\r` and `\\n`.\n- Email address is validated via `InternetAddress`.\n- `setSubject` is used instead of `setHeader(\"Subject\", …)`.\n- Custom header is sanitized to a safe character set before being used."
              },
              "id": "java.security.spring-smtp-crlf-injection",
              "name": "java.security.spring-smtp-crlf-injection",
              "properties": {
                "tags": [
                  "CWE-77"
                ]
              },
              "shortDescription": {
                "text": "CRLF injection into SMTP message"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Injection into `javax.script.ScriptEngine` occurs when untrusted input is evaluated as code by a\nJava Scripting Engine (e.g., Nashorn, JavaScript, etc.).\nIf attacker-controlled data is passed directly to `ScriptEngine.eval()` (or similar methods),\nan attacker can execute arbitrary script code in the context of the application's JVM.\nThis can lead to data exfiltration, privilege escalation, or full remote code execution,\ndepending on what the script engine can access (e.g., Java classes, filesystem, network, environment variables).\n\n```java\n// Vulnerable code sample\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\nimport javax.servlet.http.HttpServletRequest;\n\npublic class ScriptEvaluator {\n\n    public Object evaluateExpression(HttpServletRequest request) throws ScriptException {\n        // Attacker controls this parameter (e.g., ?expr=...)\n        String expr = request.getParameter(\"expr\");\n\n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"javascript\"); // or \"nashorn\", \"groovy\", etc.\n\n        // VULNERABLE: directly evaluates attacker-controlled code\n        return engine.eval(expr);\n    }\n}\n```\n\nTo remediate this issue, do not execute untrusted input as script code. Treat user input strictly\nas data, not as instructions. Where scripting is necessary:\n\n1. **Avoid passing user input into `eval`-like APIs as code.**\n  - If you only need to support simple operations (e.g., arithmetic), implement or use a dedicated\n    expression parser that does not allow arbitrary function calls or access to the underlying JVM.\n  - Never let the user control full script bodies, function definitions, or arbitrary expressions\n    that the engine will execute.\n\n2. **Use static scripts and bindings for data.**\n  Define the script code in your application (trusted), and pass user input only as variables/bindings:\n\n```java\nimport javax.script.*;\n\npublic class SafeScriptEvaluator {\n\n    private final ScriptEngine engine;\n    private final CompiledScript compiled; // optional, but more efficient and safer pattern\n\n    public SafeScriptEvaluator() throws ScriptException {\n        ScriptEngineManager manager = new ScriptEngineManager();\n        this.engine = manager.getEngineByName(\"javascript\");\n\n        // Trusted, static script embedded in the application\n        String script = \"function calculate(a, b) { return a + b; } \" +\n                        \"calculate(a, b);\";\n\n        this.compiled = ((Compilable) engine).compile(script);\n    }\n\n    public Object safeEvaluate(int a, int b) throws ScriptException {\n        Bindings bindings = engine.createBindings();\n        bindings.put(\"a\", a);   // user input as data\n        bindings.put(\"b\", b);   // user input as data\n\n        // Only the trusted script runs; user data cannot change the code\n        return compiled.eval(bindings);\n    }\n}\n```\n\n3. **Restrict the script engine's capabilities (sandboxing), if supported.**\n  - Disable or strictly limit access to `Java.type`, reflection, file I/O, process execution,\n    and network APIs from within the script.\n  - Run script engines in a constrained environment (e.g., separate process/container, or with\n    appropriate security manager / policy, if available).\n\n4. **Validate and constrain inputs on a strict allowlist.**\n  - If you must accept some form of “expression” from users, define a grammar or a very narrow\n    allowed syntax and reject anything outside that set.\n  - Do not assume that “it's just math” is safe; enforce it programmatically.",
                "text": "Injection into `javax.script.ScriptEngine` occurs when untrusted input is evaluated as code by a\nJava Scripting Engine (e.g., Nashorn, JavaScript, etc.).\nIf attacker-controlled data is passed directly to `ScriptEngine.eval()` (or similar methods),\nan attacker can execute arbitrary script code in the context of the application's JVM.\nThis can lead to data exfiltration, privilege escalation, or full remote code execution,\ndepending on what the script engine can access (e.g., Java classes, filesystem, network, environment variables).\n\n```java\n// Vulnerable code sample\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\nimport javax.servlet.http.HttpServletRequest;\n\npublic class ScriptEvaluator {\n\n    public Object evaluateExpression(HttpServletRequest request) throws ScriptException {\n        // Attacker controls this parameter (e.g., ?expr=...)\n        String expr = request.getParameter(\"expr\");\n\n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"javascript\"); // or \"nashorn\", \"groovy\", etc.\n\n        // VULNERABLE: directly evaluates attacker-controlled code\n        return engine.eval(expr);\n    }\n}\n```\n\nTo remediate this issue, do not execute untrusted input as script code. Treat user input strictly\nas data, not as instructions. Where scripting is necessary:\n\n1. **Avoid passing user input into `eval`-like APIs as code.**\n  - If you only need to support simple operations (e.g., arithmetic), implement or use a dedicated\n    expression parser that does not allow arbitrary function calls or access to the underlying JVM.\n  - Never let the user control full script bodies, function definitions, or arbitrary expressions\n    that the engine will execute.\n\n2. **Use static scripts and bindings for data.**\n  Define the script code in your application (trusted), and pass user input only as variables/bindings:\n\n```java\nimport javax.script.*;\n\npublic class SafeScriptEvaluator {\n\n    private final ScriptEngine engine;\n    private final CompiledScript compiled; // optional, but more efficient and safer pattern\n\n    public SafeScriptEvaluator() throws ScriptException {\n        ScriptEngineManager manager = new ScriptEngineManager();\n        this.engine = manager.getEngineByName(\"javascript\");\n\n        // Trusted, static script embedded in the application\n        String script = \"function calculate(a, b) { return a + b; } \" +\n                        \"calculate(a, b);\";\n\n        this.compiled = ((Compilable) engine).compile(script);\n    }\n\n    public Object safeEvaluate(int a, int b) throws ScriptException {\n        Bindings bindings = engine.createBindings();\n        bindings.put(\"a\", a);   // user input as data\n        bindings.put(\"b\", b);   // user input as data\n\n        // Only the trusted script runs; user data cannot change the code\n        return compiled.eval(bindings);\n    }\n}\n```\n\n3. **Restrict the script engine's capabilities (sandboxing), if supported.**\n  - Disable or strictly limit access to `Java.type`, reflection, file I/O, process execution,\n    and network APIs from within the script.\n  - Run script engines in a constrained environment (e.g., separate process/container, or with\n    appropriate security manager / policy, if available).\n\n4. **Validate and constrain inputs on a strict allowlist.**\n  - If you must accept some form of “expression” from users, define a grammar or a very narrow\n    allowed syntax and reject anything outside that set.\n  - Do not assume that “it's just math” is safe; enforce it programmatically."
              },
              "id": "java.security.script-engine-injection-in-spring-app",
              "name": "java.security.script-engine-injection-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-94"
                ]
              },
              "shortDescription": {
                "text": "Injection into javax.script.ScriptEngine"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Path traversal (also known as directory traversal) in Spring-based Java applications occurs when user-controlled input is used to construct filesystem paths in controllers, services, or static resource handlers without proper validation. Attackers can exploit this by sending values containing `../` or absolute paths to escape the intended directory and access sensitive files (e.g., `/etc/passwd`, configuration files, source code) on the server.\n\n**Vulnerable code sample**\n\n```java\nimport org.springframework.core.io.ByteArrayResource;\nimport org.springframework.http.*;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.io.IOException;\nimport java.nio.file.*;\n\n@RestController\n@RequestMapping(\"/files\")\npublic class FileDownloadController {\n\n    private static final String BASE_DIR = \"/var/app/uploads/\";\n\n    @GetMapping(\"/{*fileName}\")\n    public ResponseEntity<ByteArrayResource> download(@PathVariable String fileName) throws IOException {\n\n        // VULNERABLE: directly concatenating user input into a file path\n        Path path = Paths.get(BASE_DIR + fileName);\n\n        if (!Files.exists(path)) {\n            return ResponseEntity.notFound().build();\n        }\n\n        byte[] data = Files.readAllBytes(path);\n        ByteArrayResource resource = new ByteArrayResource(data);\n\n        return ResponseEntity.ok()\n                .contentType(MediaType.APPLICATION_OCTET_STREAM)\n                .header(HttpHeaders.CONTENT_DISPOSITION,\n                        \"attachment; filename=\\\"\" + path.getFileName().toString() + \"\\\"\")\n                .body(resource);\n    }\n}\n```\n\nAn attacker could call `/files/../../../../etc/passwd` or URL-encoded variants and potentially retrieve sensitive system files instead of only files under `/var/app/uploads/`.\n\nTo remediate this issue, validate and constrain all file-related input in Spring controllers and services, normalize the path, and ensure the final resolved path stays within an allowed base directory. Prefer allowlists (permitted filenames/IDs) instead of accepting arbitrary paths.\n\n**Safer Spring controller example using `Path` normalization and checks:**\n\n```java\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.UrlResource;\nimport org.springframework.http.*;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.server.ResponseStatusException;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.nio.file.*;\n\n@RestController\n@RequestMapping(\"/files\")\npublic class SafeFileDownloadController {\n\n    private static final Path BASE_DIR =\n            Paths.get(\"/var/app/uploads\").toAbsolutePath().normalize();\n\n    @GetMapping(\"/{*fileName}\")\n    public ResponseEntity<Resource> download(@PathVariable String fileName) {\n\n        // 1. Basic allowlist / pattern validation\n        if (fileName == null || !fileName.matches(\"[A-Za-z0-9._-]+\")) {\n            throw new ResponseStatusException(\n                    HttpStatus.BAD_REQUEST, \"Invalid file name\");\n        }\n\n        // 2. Resolve and normalize against a fixed base directory\n        Path target = BASE_DIR.resolve(fileName).normalize();\n\n        // 3. Enforce that the resolved path is still under BASE_DIR\n        if (!target.startsWith(BASE_DIR)) {\n            throw new ResponseStatusException(\n                    HttpStatus.FORBIDDEN, \"Access denied\");\n        }\n\n        if (!Files.exists(target) || !Files.isRegularFile(target)) {\n            throw new ResponseStatusException(\n                    HttpStatus.NOT_FOUND, \"File not found\");\n        }\n\n        Resource resource;\n        try {\n            resource = new UrlResource(target.toUri());\n        } catch (MalformedURLException e) {\n            throw new ResponseStatusException(\n                    HttpStatus.INTERNAL_SERVER_ERROR, \"Could not read file\", e);\n        }\n\n        return ResponseEntity.ok()\n                .contentType(MediaType.APPLICATION_OCTET_STREAM)\n                .header(HttpHeaders.CONTENT_DISPOSITION,\n                        \"attachment; filename=\\\"\" + target.getFileName().toString() + \"\\\"\")\n                .body(resource);\n    }\n}\n```\n\nAdditional Spring-specific recommendations:\n\n- For static resources (e.g., via `WebMvcConfigurer#addResourceHandlers`), use `PathResourceResolver` and configure `setAllowedLocations(...)` so that only predefined directories can be served.\n- Prefer storing and serving files from controlled locations (e.g., application storage directory or classpath) rather than arbitrary filesystem paths derived from user input.\n- Consider mapping user-visible IDs to filenames on the server rather than exposing filenames directly.",
                "text": "Path traversal (also known as directory traversal) in Spring-based Java applications occurs when user-controlled input is used to construct filesystem paths in controllers, services, or static resource handlers without proper validation. Attackers can exploit this by sending values containing `../` or absolute paths to escape the intended directory and access sensitive files (e.g., `/etc/passwd`, configuration files, source code) on the server.\n\n**Vulnerable code sample**\n\n```java\nimport org.springframework.core.io.ByteArrayResource;\nimport org.springframework.http.*;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.io.IOException;\nimport java.nio.file.*;\n\n@RestController\n@RequestMapping(\"/files\")\npublic class FileDownloadController {\n\n    private static final String BASE_DIR = \"/var/app/uploads/\";\n\n    @GetMapping(\"/{*fileName}\")\n    public ResponseEntity<ByteArrayResource> download(@PathVariable String fileName) throws IOException {\n\n        // VULNERABLE: directly concatenating user input into a file path\n        Path path = Paths.get(BASE_DIR + fileName);\n\n        if (!Files.exists(path)) {\n            return ResponseEntity.notFound().build();\n        }\n\n        byte[] data = Files.readAllBytes(path);\n        ByteArrayResource resource = new ByteArrayResource(data);\n\n        return ResponseEntity.ok()\n                .contentType(MediaType.APPLICATION_OCTET_STREAM)\n                .header(HttpHeaders.CONTENT_DISPOSITION,\n                        \"attachment; filename=\\\"\" + path.getFileName().toString() + \"\\\"\")\n                .body(resource);\n    }\n}\n```\n\nAn attacker could call `/files/../../../../etc/passwd` or URL-encoded variants and potentially retrieve sensitive system files instead of only files under `/var/app/uploads/`.\n\nTo remediate this issue, validate and constrain all file-related input in Spring controllers and services, normalize the path, and ensure the final resolved path stays within an allowed base directory. Prefer allowlists (permitted filenames/IDs) instead of accepting arbitrary paths.\n\n**Safer Spring controller example using `Path` normalization and checks:**\n\n```java\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.UrlResource;\nimport org.springframework.http.*;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.server.ResponseStatusException;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.nio.file.*;\n\n@RestController\n@RequestMapping(\"/files\")\npublic class SafeFileDownloadController {\n\n    private static final Path BASE_DIR =\n            Paths.get(\"/var/app/uploads\").toAbsolutePath().normalize();\n\n    @GetMapping(\"/{*fileName}\")\n    public ResponseEntity<Resource> download(@PathVariable String fileName) {\n\n        // 1. Basic allowlist / pattern validation\n        if (fileName == null || !fileName.matches(\"[A-Za-z0-9._-]+\")) {\n            throw new ResponseStatusException(\n                    HttpStatus.BAD_REQUEST, \"Invalid file name\");\n        }\n\n        // 2. Resolve and normalize against a fixed base directory\n        Path target = BASE_DIR.resolve(fileName).normalize();\n\n        // 3. Enforce that the resolved path is still under BASE_DIR\n        if (!target.startsWith(BASE_DIR)) {\n            throw new ResponseStatusException(\n                    HttpStatus.FORBIDDEN, \"Access denied\");\n        }\n\n        if (!Files.exists(target) || !Files.isRegularFile(target)) {\n            throw new ResponseStatusException(\n                    HttpStatus.NOT_FOUND, \"File not found\");\n        }\n\n        Resource resource;\n        try {\n            resource = new UrlResource(target.toUri());\n        } catch (MalformedURLException e) {\n            throw new ResponseStatusException(\n                    HttpStatus.INTERNAL_SERVER_ERROR, \"Could not read file\", e);\n        }\n\n        return ResponseEntity.ok()\n                .contentType(MediaType.APPLICATION_OCTET_STREAM)\n                .header(HttpHeaders.CONTENT_DISPOSITION,\n                        \"attachment; filename=\\\"\" + target.getFileName().toString() + \"\\\"\")\n                .body(resource);\n    }\n}\n```\n\nAdditional Spring-specific recommendations:\n\n- For static resources (e.g., via `WebMvcConfigurer#addResourceHandlers`), use `PathResourceResolver` and configure `setAllowedLocations(...)` so that only predefined directories can be served.\n- Prefer storing and serving files from controlled locations (e.g., application storage directory or classpath) rather than arbitrary filesystem paths derived from user input.\n- Consider mapping user-visible IDs to filenames on the server rather than exposing filenames directly."
              },
              "id": "java.security.path-traversal-in-spring-app",
              "name": "java.security.path-traversal-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-22"
                ]
              },
              "shortDescription": {
                "text": "Interaction with file system via untrusted path, potential path traversal"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "The Object Graph Navigation Language (OGNL) is an expression language that allows access to\nJava objects and properties stored in an ActionContext. Usage of these low-level\nfunctions is discouraged because they can effectively execute strings as code, leading to\nremote code execution vulnerabilities. Consider using struts tags when processing\nuser-supplied input and templates.\n\nMuch like the Struts security guide recommending to not use raw `${}` EL expressions,\ndo not call or use the following OGNL packages with user-supplied input:\n\n- `com.opensymphony.xwork2.ognl`\n- `com.opensymphony.xwork2.util`\n- `com.opensymphony.xwork2.util.reflection`\n- `org.apache.struts2.util.StrutsUtil`",
                "text": "The Object Graph Navigation Language (OGNL) is an expression language that allows access to\nJava objects and properties stored in an ActionContext. Usage of these low-level\nfunctions is discouraged because they can effectively execute strings as code, leading to\nremote code execution vulnerabilities. Consider using struts tags when processing\nuser-supplied input and templates.\n\nMuch like the Struts security guide recommending to not use raw `${}` EL expressions,\ndo not call or use the following OGNL packages with user-supplied input:\n\n- `com.opensymphony.xwork2.ognl`\n- `com.opensymphony.xwork2.util`\n- `com.opensymphony.xwork2.util.reflection`\n- `org.apache.struts2.util.StrutsUtil`"
              },
              "id": "java.security.ognl-injection-in-spring-app",
              "name": "java.security.ognl-injection-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-94"
                ]
              },
              "shortDescription": {
                "text": "OGNL expression construction from user-controlled input"
              }
            },
            {
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "markdown": "Groovy injection is a code-injection vulnerability that arises when untrusted input\nis used to build and execute Groovy code at runtime\n(for example via GroovyShell.evaluate, Eval.me, or a Groovy ScriptEngine).\nIf an attacker can control any part of the Groovy script string, they may execute\narbitrary Groovy/Java code with the application's privileges, leading to full server compromise,\ndata exfiltration, or lateral movement.\n\nExample (vulnerable):\n```\nString script = request.getParameter(\"script\"); // user-controlled\nGroovyShell shell = new GroovyShell();\nObject result = shell.evaluate(script);         // RCE: attacker controls code\n```\n\nTo remediate this issue, avoid evaluating dynamically constructed Groovy code whenever possible;\nprefer static scripts, fixed command mappings, or other non—code-based configuration.\nIf dynamic evaluation is truly required, strictly validate and constrain input\n(for example, by whitelisting a very limited grammar), avoid concatenating raw user data into scripts,\nand use Groovy sandboxing mechanisms such as SecureASTCustomizer plus a hardened SecurityManager.",
                "text": "Groovy injection is a code-injection vulnerability that arises when untrusted input\nis used to build and execute Groovy code at runtime\n(for example via GroovyShell.evaluate, Eval.me, or a Groovy ScriptEngine).\nIf an attacker can control any part of the Groovy script string, they may execute\narbitrary Groovy/Java code with the application's privileges, leading to full server compromise,\ndata exfiltration, or lateral movement.\n\nExample (vulnerable):\n```\nString script = request.getParameter(\"script\"); // user-controlled\nGroovyShell shell = new GroovyShell();\nObject result = shell.evaluate(script);         // RCE: attacker controls code\n```\n\nTo remediate this issue, avoid evaluating dynamically constructed Groovy code whenever possible;\nprefer static scripts, fixed command mappings, or other non—code-based configuration.\nIf dynamic evaluation is truly required, strictly validate and constrain input\n(for example, by whitelisting a very limited grammar), avoid concatenating raw user data into scripts,\nand use Groovy sandboxing mechanisms such as SecureASTCustomizer plus a hardened SecurityManager."
              },
              "id": "java.security.groovy-injection-in-spring-app",
              "name": "java.security.groovy-injection-in-spring-app",
              "properties": {
                "tags": [
                  "CWE-94"
                ]
              },
              "shortDescription": {
                "text": "Found Groovy invocation with user-controlled input"
              }
            }
          ],
          "semanticVersion": "2.1.0",
          "version": "2026.01.15.5d4ef99"
        }
      },
      "results": [
        {
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "executionOrder": 0,
                      "kinds": [
                        "taint"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:71)stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert(stirling.software.SPDF.model.api.security.SignPDFWithCertRequest):0:(pdf = request.getFileInput())",
                            "fullyQualifiedName": "stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert"
                          }
                        ],
                        "message": {
                          "text": "Method entry marks \"request\" as $UNTRUSTED"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/core/src/main/java/stirling/software/SPDF/controller/api/security/CertSignController.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 97,
                            "endLine": 166,
                            "startColumn": 12,
                            "startLine": 166
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": 1,
                      "kinds": [
                        "call"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:71)stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert(stirling.software.SPDF.model.api.security.SignPDFWithCertRequest):1:(certType = request.getCertType())",
                            "fullyQualifiedName": "stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert"
                          }
                        ],
                        "message": {
                          "text": "Calling \"getCertType\" with $UNTRUSTED data at the 1st argument of \"getCertType\""
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/core/src/main/java/stirling/software/SPDF/controller/api/security/CertSignController.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 47,
                            "endLine": 169,
                            "startColumn": 9,
                            "startLine": 169
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": 2,
                      "kinds": [
                        "unknown"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:71)stirling.software.SPDF.model.api.security.SignPDFWithCertRequest#getCertType():1:(return %0)",
                            "fullyQualifiedName": "stirling.software.SPDF.model.api.security.SignPDFWithCertRequest#getCertType"
                          }
                        ],
                        "message": {
                          "text": "The returning value is assigned marked data from \"this.certType\""
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/core/src/main/java/stirling/software/SPDF/model/api/security/SignPDFWithCertRequest.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 28,
                            "endLine": 20,
                            "startColumn": 13,
                            "startLine": 20
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": 3,
                      "kinds": [
                        "unknown"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:71)stirling.software.SPDF.model.api.security.SignPDFWithCertRequest#getCertType():1:(return %0)",
                            "fullyQualifiedName": "stirling.software.SPDF.model.api.security.SignPDFWithCertRequest#getCertType"
                          }
                        ],
                        "message": {
                          "text": "Exiting \"getCertType\""
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/core/src/main/java/stirling/software/SPDF/model/api/security/SignPDFWithCertRequest.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 28,
                            "endLine": 20,
                            "startColumn": 13,
                            "startLine": 20
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": 4,
                      "kinds": [
                        "unknown"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:71)stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert(stirling.software.SPDF.model.api.security.SignPDFWithCertRequest):1:(certType = request.getCertType())",
                            "fullyQualifiedName": "stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert"
                          }
                        ],
                        "message": {
                          "text": "Method \"getCertType\" propagates $UNTRUSTED data from \"request\" to \"certType\""
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/core/src/main/java/stirling/software/SPDF/controller/api/security/CertSignController.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 47,
                            "endLine": 169,
                            "startColumn": 9,
                            "startLine": 169
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": 5,
                      "kinds": [
                        "unknown"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:71)stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert(stirling.software.SPDF.model.api.security.SignPDFWithCertRequest):125:(%str = \"certificate type: \".concat(certType))",
                            "fullyQualifiedName": "stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert"
                          }
                        ],
                        "message": {
                          "text": "Method \"concat\" propagates $UNTRUSTED data from \"certType\" to a local variable"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/core/src/main/java/stirling/software/SPDF/controller/api/security/CertSignController.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 36,
                            "endLine": 242,
                            "startColumn": 23,
                            "startLine": 242
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": 6,
                      "kinds": [
                        "call"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:71)stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert(stirling.software.SPDF.model.api.security.SignPDFWithCertRequest):111:(%44 = stirling.software.common.util.ExceptionUtils.createIllegalArgumentException(\"error.invalidArgument\", \"Invalid argument: {0}\", %42))",
                            "fullyQualifiedName": "stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert"
                          }
                        ],
                        "message": {
                          "text": "Calling \"createIllegalArgumentException\" with $UNTRUSTED data at a local variable"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/core/src/main/java/stirling/software/SPDF/controller/api/security/CertSignController.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 56,
                            "endLine": 245,
                            "startColumn": 38,
                            "startLine": 242
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": 7,
                      "kinds": [
                        "unknown"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:72)stirling.software.common.util.ExceptionUtils#createIllegalArgumentException(java.lang.String, java.lang.String, java.lang.Object[]):0:(message = stirling.software.common.util.ExceptionUtils.getMessage(messageKey, defaultMessage, args))",
                            "fullyQualifiedName": "stirling.software.common.util.ExceptionUtils#createIllegalArgumentException"
                          }
                        ],
                        "message": {
                          "text": "Entering \"createIllegalArgumentException\" with marked data at \"args\""
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/common/src/main/java/stirling/software/common/util/ExceptionUtils.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 69,
                            "endLine": 633,
                            "startColumn": 19,
                            "startLine": 632
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": 8,
                      "kinds": [
                        "call"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:72)stirling.software.common.util.ExceptionUtils#createIllegalArgumentException(java.lang.String, java.lang.String, java.lang.Object[]):0:(message = stirling.software.common.util.ExceptionUtils.getMessage(messageKey, defaultMessage, args))",
                            "fullyQualifiedName": "stirling.software.common.util.ExceptionUtils#createIllegalArgumentException"
                          }
                        ],
                        "message": {
                          "text": "Calling \"getMessage\" with marked data at \"args\""
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/common/src/main/java/stirling/software/common/util/ExceptionUtils.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 69,
                            "endLine": 634,
                            "startColumn": 9,
                            "startLine": 634
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": 9,
                      "kinds": [
                        "unknown"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:72)stirling.software.common.util.ExceptionUtils#getMessage(java.lang.String, java.lang.String, java.lang.Object[]):0:(template = defaultMessage)",
                            "fullyQualifiedName": "stirling.software.common.util.ExceptionUtils#getMessage"
                          }
                        ],
                        "message": {
                          "text": "Entering \"getMessage\" with marked data at \"args\""
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/common/src/main/java/stirling/software/common/util/ExceptionUtils.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 94,
                            "endLine": 160,
                            "startColumn": 20,
                            "startLine": 160
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": 10,
                      "kinds": [
                        "unknown"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:72)stirling.software.common.util.ExceptionUtils#getMessage(java.lang.String, java.lang.String, java.lang.Object[]):17:(return %10)",
                            "fullyQualifiedName": "stirling.software.common.util.ExceptionUtils#getMessage"
                          }
                        ],
                        "message": {
                          "text": "The returning value is assigned marked data from \"format\" call"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/common/src/main/java/stirling/software/common/util/ExceptionUtils.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 98,
                            "endLine": 173,
                            "startColumn": 9,
                            "startLine": 173
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": 11,
                      "kinds": [
                        "unknown"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:72)stirling.software.common.util.ExceptionUtils#getMessage(java.lang.String, java.lang.String, java.lang.Object[]):17:(return %10)",
                            "fullyQualifiedName": "stirling.software.common.util.ExceptionUtils#getMessage"
                          }
                        ],
                        "message": {
                          "text": "Exiting \"getMessage\""
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/common/src/main/java/stirling/software/common/util/ExceptionUtils.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 5,
                            "endLine": 174,
                            "startColumn": 5,
                            "startLine": 174
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": 12,
                      "kinds": [
                        "unknown"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:72)stirling.software.common.util.ExceptionUtils#createIllegalArgumentException(java.lang.String, java.lang.String, java.lang.Object[]):0:(message = stirling.software.common.util.ExceptionUtils.getMessage(messageKey, defaultMessage, args))",
                            "fullyQualifiedName": "stirling.software.common.util.ExceptionUtils#createIllegalArgumentException"
                          }
                        ],
                        "message": {
                          "text": "Method \"getMessage\" propagates marked data from \"args\" to \"message\""
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/common/src/main/java/stirling/software/common/util/ExceptionUtils.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 69,
                            "endLine": 634,
                            "startColumn": 9,
                            "startLine": 634
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": 13,
                      "kinds": [
                        "unknown"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:72)stirling.software.common.util.ExceptionUtils#createIllegalArgumentException(java.lang.String, java.lang.String, java.lang.Object[]):3:(return %2)",
                            "fullyQualifiedName": "stirling.software.common.util.ExceptionUtils#createIllegalArgumentException"
                          }
                        ],
                        "message": {
                          "text": "Takes marked data at \"message\" and ends up with marked data at the returned value"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/common/src/main/java/stirling/software/common/util/ExceptionUtils.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 53,
                            "endLine": 635,
                            "startColumn": 9,
                            "startLine": 635
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": 14,
                      "kinds": [
                        "unknown"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:72)stirling.software.common.util.ExceptionUtils#createIllegalArgumentException(java.lang.String, java.lang.String, java.lang.Object[]):3:(return %2)",
                            "fullyQualifiedName": "stirling.software.common.util.ExceptionUtils#createIllegalArgumentException"
                          }
                        ],
                        "message": {
                          "text": "Exiting \"createIllegalArgumentException\""
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/common/src/main/java/stirling/software/common/util/ExceptionUtils.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 5,
                            "endLine": 636,
                            "startColumn": 5,
                            "startLine": 636
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": 15,
                      "kinds": [
                        "unknown"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:71)stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert(stirling.software.SPDF.model.api.security.SignPDFWithCertRequest):112:(throw %44)",
                            "fullyQualifiedName": "stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert"
                          }
                        ],
                        "message": {
                          "text": "Takes $UNTRUSTED data at a local variable and ends up with $UNTRUSTED data at thrown exception value"
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/core/src/main/java/stirling/software/SPDF/controller/api/security/CertSignController.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 36,
                            "endLine": 242,
                            "startColumn": 23,
                            "startLine": 242
                          }
                        }
                      }
                    },
                    {
                      "executionOrder": 16,
                      "kinds": [
                        "taint"
                      ],
                      "location": {
                        "logicalLocations": [
                          {
                            "decoratedName": "(id:71)stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert(stirling.software.SPDF.model.api.security.SignPDFWithCertRequest):112:(throw %44)",
                            "fullyQualifiedName": "stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert"
                          }
                        ],
                        "message": {
                          "text": "Potential XSS: writing user input directly to a web page."
                        },
                        "physicalLocation": {
                          "artifactLocation": {
                            "uri": "app/core/src/main/java/stirling/software/SPDF/controller/api/security/CertSignController.java",
                            "uriBaseId": "%SRCROOT%"
                          },
                          "region": {
                            "endColumn": 36,
                            "endLine": 242,
                            "startColumn": 23,
                            "startLine": 242
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "level": "error",
          "locations": [
            {
              "logicalLocations": [
                {
                  "decoratedName": "(id:71)stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert(stirling.software.SPDF.model.api.security.SignPDFWithCertRequest):112:(throw %44)",
                  "fullyQualifiedName": "stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert"
                }
              ],
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "app/core/src/main/java/stirling/software/SPDF/controller/api/security/CertSignController.java",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 36,
                  "endLine": 242,
                  "startColumn": 23,
                  "startLine": 242
                }
              }
            }
          ],
          "message": {
            "text": "Potential XSS: writing user input directly to a web page."
          },
          "relatedLocations": [
            {
              "logicalLocations": [
                {
                  "fullyQualifiedName": "POST /api/v1/security/cert-sign",
                  "index": 0,
                  "kind": "function",
                  "name": "stirling.software.SPDF.controller.api.security.CertSignController#signPDFWithCert"
                }
              ],
              "message": {
                "text": "Related Spring controller"
              },
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "app/core/src/main/java/stirling/software/SPDF/controller/api/security/CertSignController.java",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 168
                }
              }
            }
          ],
          "ruleId": "java.security.xss-in-spring-app"
        }
      ]
    }
  ]
}